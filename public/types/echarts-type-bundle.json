[
  {
    "path": "echarts/index.d.ts",
    "code": "/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n///////////////////////////////////////////////////////////////////////\n/// NOTE: types folder is generated by `npm run prepublish` command ///\n/// Make sure run it before edit this file.                         ///\n///////////////////////////////////////////////////////////////////////\n\nexport * from './types/echarts.all';\n\nexport {EChartsFullOption as EChartsOption} from './types/src/option';"
  },
  {
    "path": "echarts/types/echarts.all.d.ts",
    "code": "export * from './src/echarts';\nexport * from './src/export';\nimport './src/component/dataset';\nimport './src/component/transform';\nimport './src/chart/line';\nimport './src/chart/bar';\nimport './src/chart/pie';\nimport './src/chart/scatter';\nimport './src/chart/radar';\nimport './src/chart/map';\nimport './src/chart/tree';\nimport './src/chart/treemap';\nimport './src/chart/graph';\nimport './src/chart/gauge';\nimport './src/chart/funnel';\nimport './src/chart/parallel';\nimport './src/chart/sankey';\nimport './src/chart/boxplot';\nimport './src/chart/candlestick';\nimport './src/chart/effectScatter';\nimport './src/chart/lines';\nimport './src/chart/heatmap';\nimport './src/chart/pictorialBar';\nimport './src/chart/themeRiver';\nimport './src/chart/sunburst';\nimport './src/chart/custom';\nimport './src/component/grid';\nimport './src/component/polar';\nimport './src/component/geo';\nimport './src/component/singleAxis';\nimport './src/component/parallel';\nimport './src/component/calendar';\nimport './src/component/graphic';\nimport './src/component/toolbox';\nimport './src/component/tooltip';\nimport './src/component/axisPointer';\nimport './src/component/brush';\nimport './src/component/title';\nimport './src/component/timeline';\nimport './src/component/markPoint';\nimport './src/component/markLine';\nimport './src/component/markArea';\nimport './src/component/legendScroll';\nimport './src/component/legend';\nimport './src/component/dataZoom';\nimport './src/component/dataZoomInside';\nimport './src/component/dataZoomSlider';\nimport './src/component/visualMap';\nimport './src/component/visualMapContinuous';\nimport './src/component/visualMapPiecewise';\nimport 'zrender/esm/svg/svg';\n"
  },
  {
    "path": "echarts/types/echarts.blank.d.ts",
    "code": "export * from './src/echarts';\nexport * from './src/export';\nimport './src/component/dataset';\n"
  },
  {
    "path": "echarts/types/echarts.common.d.ts",
    "code": "export * from './src/echarts';\nexport * from './src/export';\nimport './src/component/dataset';\nimport './src/chart/line';\nimport './src/chart/bar';\nimport './src/chart/pie';\nimport './src/chart/scatter';\nimport './src/component/graphic';\nimport './src/component/tooltip';\nimport './src/component/axisPointer';\nimport './src/component/legendScroll';\nimport './src/component/grid';\nimport './src/component/title';\nimport './src/component/markPoint';\nimport './src/component/markLine';\nimport './src/component/markArea';\nimport './src/component/dataZoom';\nimport './src/component/toolbox';\nimport 'zrender/esm/svg/svg';\n"
  },
  {
    "path": "echarts/types/echarts.simple.d.ts",
    "code": "export * from './src/echarts';\nimport './src/component/dataset';\nimport './src/chart/line';\nimport './src/chart/bar';\nimport './src/chart/pie';\nimport './src/component/gridSimple';\n"
  },
  {
    "path": "echarts/types/src/action/changeAxisOrder.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/action/geoRoam.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/action/roamHelper.d.ts",
    "code": "import View from '../coord/View';\nimport { Payload } from '../util/types';\nexport interface RoamPaylod extends Payload {\n    dx: number;\n    dy: number;\n    zoom: number;\n    originX: number;\n    originY: number;\n}\nexport declare function updateCenterAndZoom(view: View, payload: RoamPaylod, zoomLimit?: {\n    min?: number;\n    max?: number;\n}): {\n    center: number[];\n    zoom: number;\n};\n"
  },
  {
    "path": "echarts/types/src/chart/bar.d.ts",
    "code": "import '../coord/cartesian/Grid';\nimport './bar/BarSeries';\nimport './bar/BarView';\nimport '../action/changeAxisOrder';\nimport '../component/gridSimple';\n"
  },
  {
    "path": "echarts/types/src/chart/bar/BarSeries.d.ts",
    "code": "import BaseBarSeriesModel, { BaseBarSeriesOption } from './BaseBarSeries';\nimport { ItemStyleOption, OptionDataValue, LabelOption, SeriesStackOptionMixin, StatesOptionMixin, OptionDataItemObject } from '../../util/types';\nimport Cartesian2D from '../../coord/cartesian/Cartesian2D';\nimport Polar from '../../coord/polar/Polar';\nimport List from '../../data/List';\nimport { BrushCommonSelectorsForSeries } from '../../component/brush/selector';\nexport interface BarStateOption {\n    itemStyle?: BarItemStyleOption;\n    label?: LabelOption;\n}\nexport interface BarItemStyleOption extends ItemStyleOption {\n    borderRadius?: number | number[];\n}\nexport interface BarDataItemOption extends BarStateOption, StatesOptionMixin<BarStateOption>, OptionDataItemObject<OptionDataValue> {\n    cursor?: string;\n}\nexport interface BarSeriesOption extends BaseBarSeriesOption<BarStateOption>, BarStateOption, SeriesStackOptionMixin {\n    type?: 'bar';\n    coordinateSystem?: 'cartesian2d' | 'polar';\n    clip?: boolean;\n    roundCap?: boolean;\n    showBackground?: boolean;\n    backgroundStyle?: ItemStyleOption & {\n        borderRadius?: number | number[];\n    };\n    data?: (BarDataItemOption | OptionDataValue | OptionDataValue[])[];\n    emphasis?: BarStateOption;\n    blur?: BarStateOption;\n    select?: BarStateOption;\n    realtimeSort?: boolean;\n}\ndeclare class BarSeriesModel extends BaseBarSeriesModel<BarSeriesOption> {\n    static type: string;\n    type: string;\n    static dependencies: string[];\n    coordinateSystem: Cartesian2D | Polar;\n    getProgressive(): number | false;\n    getProgressiveThreshold(): number;\n    brushSelector(dataIndex: number, data: List, selectors: BrushCommonSelectorsForSeries): boolean;\n    static defaultOption: BarSeriesOption;\n}\nexport default BarSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/bar/BarView.d.ts",
    "code": "import ChartView from '../../view/Chart';\nimport List, { DefaultDataVisual } from '../../data/List';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { StageHandlerProgressParams, OrdinalSortInfo, Payload } from '../../util/types';\nimport BarSeriesModel from './BarSeries';\nimport Axis2D from '../../coord/cartesian/Axis2D';\ndeclare class BarView extends ChartView {\n    static type: \"bar\";\n    type: \"bar\";\n    private _data;\n    private _isLargeDraw;\n    private _isFirstFrame;\n    private _onRendered;\n    private _backgroundGroup;\n    private _backgroundEls;\n    private _model;\n    constructor();\n    render(seriesModel: BarSeriesModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    incrementalPrepareRender(seriesModel: BarSeriesModel): void;\n    incrementalRender(params: StageHandlerProgressParams, seriesModel: BarSeriesModel): void;\n    private _updateDrawMode;\n    private _renderNormal;\n    private _renderLarge;\n    private _incrementalRenderLarge;\n    private _updateLargeClip;\n    _dataSort(data: List<BarSeriesModel, DefaultDataVisual>, idxMap: ((idx: number) => number)): OrdinalSortInfo[];\n    _isDataOrderChanged(data: List<BarSeriesModel, DefaultDataVisual>, orderMap: ((idx: number) => number), oldOrder: OrdinalSortInfo[]): boolean;\n    _updateSort(data: List<BarSeriesModel, DefaultDataVisual>, orderMap: ((idx: number) => number), baseAxis: Axis2D, api: ExtensionAPI): void;\n    _initSort(data: List<BarSeriesModel, DefaultDataVisual>, isHorizontal: boolean, baseAxis: Axis2D, api: ExtensionAPI): void;\n    remove(ecModel: GlobalModel, api: ExtensionAPI): void;\n    dispose(ecModel: GlobalModel, api: ExtensionAPI): void;\n    removeOnRenderedListener(api: ExtensionAPI): void;\n    private _clear;\n    private _removeBackground;\n}\nexport default BarView;\n"
  },
  {
    "path": "echarts/types/src/chart/bar/BaseBarSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { SeriesOption, SeriesOnCartesianOptionMixin, SeriesOnPolarOptionMixin, ScaleDataValue } from '../../util/types';\nimport GlobalModel from '../../model/Global';\nimport List from '../../data/List';\nexport interface BaseBarSeriesOption<StateOption, ExtraStateOption = unknown> extends SeriesOption<StateOption, ExtraStateOption>, SeriesOnCartesianOptionMixin, SeriesOnPolarOptionMixin {\n    barMinHeight?: number;\n    barMinAngle?: number;\n    barMaxWidth?: number;\n    barMinWidth?: number;\n    barWidth?: number | string;\n    barGap?: string | number;\n    barCategoryGap?: string | number;\n    large?: boolean;\n    largeThreshold?: number;\n}\ndeclare class BaseBarSeriesModel<Opts extends BaseBarSeriesOption<unknown> = BaseBarSeriesOption<unknown>> extends SeriesModel<Opts> {\n    static type: string;\n    type: string;\n    getInitialData(option: Opts, ecModel: GlobalModel): List;\n    getMarkerPosition(value: ScaleDataValue[]): number[];\n    static defaultOption: BaseBarSeriesOption<unknown, unknown>;\n}\nexport default BaseBarSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/bar/PictorialBarSeries.d.ts",
    "code": "import BaseBarSeriesModel, { BaseBarSeriesOption } from './BaseBarSeries';\nimport { OptionDataValue, ItemStyleOption, LabelOption, AnimationOptionMixin, SeriesStackOptionMixin, StatesOptionMixin, OptionDataItemObject } from '../../util/types';\nimport Cartesian2D from '../../coord/cartesian/Cartesian2D';\nexport interface PictorialBarStateOption {\n    itemStyle?: ItemStyleOption;\n    label?: LabelOption;\n}\ninterface PictorialBarSeriesSymbolOption {\n    symbol?: string;\n    symbolSize?: (number | string)[] | number | string;\n    symbolRotate?: number;\n    symbolPosition?: 'start' | 'end' | 'center';\n    symbolOffset?: (number | string)[] | number | string;\n    symbolMargin?: (number | string)[] | number | string;\n    symbolRepeat?: boolean | number | 'fixed';\n    symbolRepeatDirection?: 'start' | 'end';\n    symbolClip?: boolean;\n    symbolBoundingData?: number | number[];\n    symbolPatternSize?: number;\n}\ninterface ExtraStateOption {\n    emphasis?: {\n        scale?: boolean;\n    };\n}\nexport interface PictorialBarDataItemOption extends PictorialBarSeriesSymbolOption, AnimationOptionMixin, PictorialBarStateOption, StatesOptionMixin<PictorialBarStateOption, ExtraStateOption>, OptionDataItemObject<OptionDataValue> {\n    z?: number;\n    cursor?: string;\n}\nexport interface PictorialBarSeriesOption extends BaseBarSeriesOption<PictorialBarStateOption, ExtraStateOption>, PictorialBarStateOption, PictorialBarSeriesSymbolOption, SeriesStackOptionMixin {\n    type?: 'pictorialBar';\n    coordinateSystem?: 'cartesian2d';\n    data?: (PictorialBarDataItemOption | OptionDataValue | OptionDataValue[])[];\n}\ndeclare class PictorialBarSeriesModel extends BaseBarSeriesModel<PictorialBarSeriesOption> {\n    static type: string;\n    type: string;\n    static dependencies: string[];\n    coordinateSystem: Cartesian2D;\n    hasSymbolVisual: boolean;\n    defaultSymbol: string;\n    static defaultOption: PictorialBarSeriesOption;\n    getInitialData(option: PictorialBarSeriesOption): import(\"../../data/List\").default<import(\"../../model/Model\").default<any>, import(\"../../data/List\").DefaultDataVisual>;\n}\nexport default PictorialBarSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/bar/PictorialBarView.d.ts",
    "code": "import ChartView from '../../view/Chart';\nimport PictorialBarSeriesModel from './PictorialBarSeries';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport GlobalModel from '../../model/Global';\ndeclare class PictorialBarView extends ChartView {\n    static type: string;\n    readonly type: string;\n    private _data;\n    render(seriesModel: PictorialBarSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): import(\"../../util/types\").ViewRootGroup;\n    remove(ecModel: GlobalModel, api: ExtensionAPI): void;\n}\nexport default PictorialBarView;\n"
  },
  {
    "path": "echarts/types/src/chart/boxplot.d.ts",
    "code": "import './boxplot/BoxplotSeries';\nimport './boxplot/BoxplotView';\n"
  },
  {
    "path": "echarts/types/src/chart/boxplot/boxplotLayout.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nexport interface BoxplotItemLayout {\n    ends: number[][];\n    initBaseline: number;\n}\nexport default function (ecModel: GlobalModel): void;\n"
  },
  {
    "path": "echarts/types/src/chart/boxplot/BoxplotSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { WhiskerBoxCommonMixin } from '../helper/whiskerBoxCommon';\nimport { SeriesOption, SeriesOnCartesianOptionMixin, LayoutOrient, ItemStyleOption, LabelOption, OptionDataValueNumeric, StatesOptionMixin } from '../../util/types';\nimport Axis2D from '../../coord/cartesian/Axis2D';\nimport Cartesian2D from '../../coord/cartesian/Cartesian2D';\ndeclare type BoxplotDataValue = OptionDataValueNumeric[];\nexport interface BoxplotStateOption {\n    itemStyle?: ItemStyleOption;\n    label?: LabelOption;\n}\nexport interface BoxplotDataItemOption extends BoxplotStateOption, StatesOptionMixin<BoxplotStateOption, ExtraStateOption> {\n    value: BoxplotDataValue;\n}\ninterface ExtraStateOption {\n    emphasis?: {\n        scale?: boolean;\n    };\n}\nexport interface BoxplotSeriesOption extends SeriesOption<BoxplotStateOption, ExtraStateOption>, BoxplotStateOption, SeriesOnCartesianOptionMixin {\n    type?: 'boxplot';\n    coordinateSystem?: 'cartesian2d';\n    layout?: LayoutOrient;\n    boxWidth?: (string | number)[];\n    data?: (BoxplotDataValue | BoxplotDataItemOption)[];\n}\ndeclare class BoxplotSeriesModel extends SeriesModel<BoxplotSeriesOption> {\n    static readonly type = \"series.boxplot\";\n    readonly type = \"series.boxplot\";\n    static readonly dependencies: string[];\n    coordinateSystem: Cartesian2D;\n    defaultValueDimensions: {\n        name: string;\n        defaultTooltip: boolean;\n    }[];\n    dimensions: string[];\n    visualDrawType: \"stroke\";\n    static defaultOption: BoxplotSeriesOption;\n}\ninterface BoxplotSeriesModel extends WhiskerBoxCommonMixin<BoxplotSeriesOption> {\n    getBaseAxis(): Axis2D;\n}\nexport default BoxplotSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/boxplot/boxplotTransform.d.ts",
    "code": "import { DataTransformOption, ExternalDataTransform } from '../../data/helper/transform';\nimport { PrepareBoxplotDataOpt } from './prepareBoxplotData';\nexport interface BoxplotTransformOption extends DataTransformOption {\n    type: 'boxplot';\n    config: PrepareBoxplotDataOpt;\n}\nexport declare const boxplotTransform: ExternalDataTransform<BoxplotTransformOption>;\n"
  },
  {
    "path": "echarts/types/src/chart/boxplot/BoxplotView.d.ts",
    "code": "import ChartView from '../../view/Chart';\nimport BoxplotSeriesModel from './BoxplotSeries';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\ndeclare class BoxplotView extends ChartView {\n    static type: string;\n    type: string;\n    private _data;\n    render(seriesModel: BoxplotSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    remove(ecModel: GlobalModel): void;\n}\nexport default BoxplotView;\n"
  },
  {
    "path": "echarts/types/src/chart/boxplot/boxplotVisual.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nexport default function (ecModel: GlobalModel, api: ExtensionAPI): void;\n"
  },
  {
    "path": "echarts/types/src/chart/boxplot/prepareBoxplotData.d.ts",
    "code": "export interface PrepareBoxplotDataOpt {\n    boundIQR?: number | 'none';\n    itemNameFormatter?: string | ((params: {\n        value: number;\n    }) => string);\n}\nexport default function (rawData: number[][], opt: PrepareBoxplotDataOpt): {\n    boxData: (number | string)[][];\n    outliers: (number | string)[][];\n};\n"
  },
  {
    "path": "echarts/types/src/chart/candlestick.d.ts",
    "code": "import './candlestick/CandlestickSeries';\nimport './candlestick/CandlestickView';\n"
  },
  {
    "path": "echarts/types/src/chart/candlestick/candlestickLayout.d.ts",
    "code": "import { StageHandler } from '../../util/types';\nimport { RectLike } from 'zrender/esm/core/BoundingRect';\nexport interface CandlestickItemLayout {\n    sign: number;\n    initBaseline: number;\n    ends: number[][];\n    brushRect: RectLike;\n}\nexport interface CandlestickLayoutMeta {\n    candleWidth: number;\n    isSimpleBox: boolean;\n}\ndeclare const candlestickLayout: StageHandler;\nexport default candlestickLayout;\n"
  },
  {
    "path": "echarts/types/src/chart/candlestick/CandlestickSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { SeriesOption, SeriesOnCartesianOptionMixin, LayoutOrient, ItemStyleOption, ZRColor, ColorString, LabelOption, SeriesLargeOptionMixin, OptionDataValueNumeric, StatesOptionMixin } from '../../util/types';\nimport List from '../../data/List';\nimport Cartesian2D from '../../coord/cartesian/Cartesian2D';\nimport { BrushCommonSelectorsForSeries } from '../../component/brush/selector';\ndeclare type CandlestickDataValue = OptionDataValueNumeric[];\ninterface CandlestickItemStyleOption extends ItemStyleOption {\n    color0?: ZRColor;\n    borderColor0?: ColorString;\n}\nexport interface CandlestickStateOption {\n    itemStyle?: CandlestickItemStyleOption;\n    label?: LabelOption;\n}\nexport interface CandlestickDataItemOption extends CandlestickStateOption, StatesOptionMixin<CandlestickStateOption, ExtraStateOption> {\n    value: CandlestickDataValue;\n}\ninterface ExtraStateOption {\n    emphasis?: {\n        scale?: boolean;\n    };\n}\nexport interface CandlestickSeriesOption extends SeriesOption<CandlestickStateOption, ExtraStateOption>, CandlestickStateOption, SeriesOnCartesianOptionMixin, SeriesLargeOptionMixin {\n    type?: 'candlestick';\n    coordinateSystem?: 'cartesian2d';\n    layout?: LayoutOrient;\n    clip?: boolean;\n    barMaxWidth?: number | string;\n    barMinWidth?: number | string;\n    barWidth?: number | string;\n    data?: (CandlestickDataValue | CandlestickDataItemOption)[];\n}\ndeclare class CandlestickSeriesModel extends SeriesModel<CandlestickSeriesOption> {\n    static readonly type = \"series.candlestick\";\n    readonly type = \"series.candlestick\";\n    static readonly dependencies: string[];\n    coordinateSystem: Cartesian2D;\n    dimensions: string[];\n    defaultValueDimensions: {\n        name: string;\n        defaultTooltip: boolean;\n    }[];\n    static defaultOption: CandlestickSeriesOption;\n    getShadowDim(): string;\n    brushSelector(dataIndex: number, data: List, selectors: BrushCommonSelectorsForSeries): boolean;\n}\nexport default CandlestickSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/candlestick/CandlestickView.d.ts",
    "code": "import ChartView from '../../view/Chart';\nimport CandlestickSeriesModel from './CandlestickSeries';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { StageHandlerProgressParams } from '../../util/types';\ndeclare class CandlestickView extends ChartView {\n    static readonly type = \"candlestick\";\n    readonly type = \"candlestick\";\n    private _isLargeDraw;\n    private _data;\n    render(seriesModel: CandlestickSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    incrementalPrepareRender(seriesModel: CandlestickSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    incrementalRender(params: StageHandlerProgressParams, seriesModel: CandlestickSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    _updateDrawMode(seriesModel: CandlestickSeriesModel): void;\n    _renderNormal(seriesModel: CandlestickSeriesModel): void;\n    _renderLarge(seriesModel: CandlestickSeriesModel): void;\n    _incrementalRenderNormal(params: StageHandlerProgressParams, seriesModel: CandlestickSeriesModel): void;\n    _incrementalRenderLarge(params: StageHandlerProgressParams, seriesModel: CandlestickSeriesModel): void;\n    remove(ecModel: GlobalModel): void;\n    _clear(): void;\n}\nexport default CandlestickView;\n"
  },
  {
    "path": "echarts/types/src/chart/candlestick/candlestickVisual.d.ts",
    "code": "import { StageHandler } from '../../util/types';\ndeclare const candlestickVisual: StageHandler;\nexport default candlestickVisual;\n"
  },
  {
    "path": "echarts/types/src/chart/candlestick/preprocessor.d.ts",
    "code": "import { ECUnitOption } from '../../util/types';\nexport default function (option: ECUnitOption): void;\n"
  },
  {
    "path": "echarts/types/src/chart/custom.d.ts",
    "code": "import { OptionDataValue } from '../util/types';\nimport { CoordinateSystem } from '../coord/CoordinateSystem';\ninterface CustomSeriesRenderItemParamsCoordSys {\n    type: string;\n}\ninterface CustomSeriesRenderItemCoordinateSystemAPI {\n    coord(data: OptionDataValue | OptionDataValue[], clamp?: boolean): number[];\n    size?(dataSize: OptionDataValue | OptionDataValue[], dataItem: OptionDataValue | OptionDataValue[]): number | number[];\n}\nexport declare type PrepareCustomInfo = (coordSys: CoordinateSystem) => {\n    coordSys: CustomSeriesRenderItemParamsCoordSys;\n    api: CustomSeriesRenderItemCoordinateSystemAPI;\n};\nexport {};\n"
  },
  {
    "path": "echarts/types/src/chart/effectScatter.d.ts",
    "code": "import './effectScatter/EffectScatterSeries';\nimport './effectScatter/EffectScatterView';\n"
  },
  {
    "path": "echarts/types/src/chart/effectScatter/EffectScatterSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { SeriesOption, SeriesOnPolarOptionMixin, SeriesOnCartesianOptionMixin, SeriesOnCalendarOptionMixin, SeriesOnGeoOptionMixin, SeriesOnSingleOptionMixin, SymbolOptionMixin, OptionDataValue, ItemStyleOption, LabelOption, StatesOptionMixin } from '../../util/types';\nimport GlobalModel from '../../model/Global';\nimport List from '../../data/List';\nimport { SymbolDrawItemModelOption } from '../helper/SymbolDraw';\nimport { BrushCommonSelectorsForSeries } from '../../component/brush/selector';\ndeclare type ScatterDataValue = OptionDataValue | OptionDataValue[];\nexport interface EffectScatterStateOption {\n    itemStyle?: ItemStyleOption;\n    label?: LabelOption;\n}\nexport interface EffectScatterDataItemOption extends SymbolOptionMixin, EffectScatterStateOption, StatesOptionMixin<EffectScatterStateOption> {\n    name?: string;\n    value?: ScatterDataValue;\n    rippleEffect?: SymbolDrawItemModelOption['rippleEffect'];\n}\nexport interface EffectScatterSeriesOption extends SeriesOption<EffectScatterStateOption>, EffectScatterStateOption, SeriesOnCartesianOptionMixin, SeriesOnPolarOptionMixin, SeriesOnCalendarOptionMixin, SeriesOnGeoOptionMixin, SeriesOnSingleOptionMixin, SymbolOptionMixin {\n    type?: 'effectScatter';\n    coordinateSystem?: string;\n    effectType?: 'ripple';\n    showEffectOn?: 'render' | 'emphasis';\n    rippleEffect?: SymbolDrawItemModelOption['rippleEffect'];\n    data?: (EffectScatterDataItemOption | OptionDataValue)[];\n}\ndeclare class EffectScatterSeriesModel extends SeriesModel<EffectScatterSeriesOption> {\n    static readonly type = \"series.effectScatter\";\n    type: string;\n    static readonly dependencies: string[];\n    hasSymbolVisual: boolean;\n    getInitialData(option: EffectScatterSeriesOption, ecModel: GlobalModel): List;\n    brushSelector(dataIndex: number, data: List, selectors: BrushCommonSelectorsForSeries): boolean;\n    static defaultOption: EffectScatterSeriesOption;\n}\nexport default EffectScatterSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/effectScatter/EffectScatterView.d.ts",
    "code": "import ChartView from '../../view/Chart';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport EffectScatterSeriesModel from './EffectScatterSeries';\ndeclare class EffectScatterView extends ChartView {\n    static readonly type = \"effectScatter\";\n    readonly type = \"effectScatter\";\n    private _symbolDraw;\n    init(): void;\n    render(seriesModel: EffectScatterSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    updateTransform(seriesModel: EffectScatterSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    _updateGroupTransform(seriesModel: EffectScatterSeriesModel): void;\n    remove(ecModel: GlobalModel, api: ExtensionAPI): void;\n}\nexport default EffectScatterView;\n"
  },
  {
    "path": "echarts/types/src/chart/funnel.d.ts",
    "code": "import './funnel/FunnelSeries';\nimport './funnel/FunnelView';\n"
  },
  {
    "path": "echarts/types/src/chart/funnel/funnelLayout.d.ts",
    "code": "import ExtensionAPI from '../../ExtensionAPI';\nimport GlobalModel from '../../model/Global';\nexport default function (ecModel: GlobalModel, api: ExtensionAPI): void;\n"
  },
  {
    "path": "echarts/types/src/chart/funnel/FunnelSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { SeriesOption, BoxLayoutOptionMixin, HorizontalAlign, LabelOption, LabelLineOption, ItemStyleOption, OptionDataValueNumeric, StatesOptionMixin, OptionDataItemObject } from '../../util/types';\nimport GlobalModel from '../../model/Global';\nimport List from '../../data/List';\ndeclare type FunnelLabelOption = Omit<LabelOption, 'position'> & {\n    position?: LabelOption['position'] | 'outer' | 'inner' | 'center' | 'rightTop' | 'rightBottom' | 'leftTop' | 'leftBottom';\n};\nexport interface FunnelStateOption {\n    itemStyle?: ItemStyleOption;\n    label?: FunnelLabelOption;\n    labelLine?: LabelLineOption;\n}\nexport interface FunnelDataItemOption extends FunnelStateOption, StatesOptionMixin<FunnelStateOption>, OptionDataItemObject<OptionDataValueNumeric> {\n    itemStyle?: ItemStyleOption & {\n        height?: number | string;\n    };\n}\nexport interface FunnelSeriesOption extends SeriesOption<FunnelStateOption>, FunnelStateOption, BoxLayoutOptionMixin {\n    type?: 'funnel';\n    min?: number;\n    max?: number;\n    minSize?: number | string;\n    maxSize?: number | string;\n    sort?: 'ascending' | 'descending' | 'none';\n    gap?: number;\n    funnelAlign?: HorizontalAlign;\n    data?: (OptionDataValueNumeric | OptionDataValueNumeric[] | FunnelDataItemOption)[];\n}\ndeclare class FunnelSeriesModel extends SeriesModel<FunnelSeriesOption> {\n    static type: \"series.funnel\";\n    type: \"series.funnel\";\n    useColorPaletteOnData: boolean;\n    init(option: FunnelSeriesOption): void;\n    getInitialData(this: FunnelSeriesModel, option: FunnelSeriesOption, ecModel: GlobalModel): List;\n    _defaultLabelLine(option: FunnelSeriesOption): void;\n    getDataParams(dataIndex: number): import(\"../../util/types\").CallbackDataParams;\n    static defaultOption: FunnelSeriesOption;\n}\nexport default FunnelSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/funnel/FunnelView.d.ts",
    "code": "import ChartView from '../../view/Chart';\nimport FunnelSeriesModel from './FunnelSeries';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\ndeclare class FunnelView extends ChartView {\n    static type: \"funnel\";\n    type: \"funnel\";\n    private _data;\n    ignoreLabelLineUpdate: boolean;\n    render(seriesModel: FunnelSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    remove(): void;\n    dispose(): void;\n}\nexport default FunnelView;\n"
  },
  {
    "path": "echarts/types/src/chart/gauge.d.ts",
    "code": "import './gauge/GaugeSeries';\nimport './gauge/GaugeView';\n"
  },
  {
    "path": "echarts/types/src/chart/gauge/GaugeSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { SeriesOption, CircleLayoutOptionMixin, LineStyleOption, ColorString, LabelOption, ItemStyleOption, OptionDataValueNumeric, StatesOptionMixin } from '../../util/types';\nimport GlobalModel from '../../model/Global';\nimport List from '../../data/List';\ndeclare type GaugeColorStop = [number, ColorString];\ninterface LabelFormatter {\n    (value: number): string;\n}\ninterface PointerOption {\n    show?: boolean;\n    length?: number | string;\n    width?: number;\n}\nexport interface GaugeStateOption {\n    itemStyle?: ItemStyleOption;\n}\nexport interface GaugeDataItemOption extends GaugeStateOption, StatesOptionMixin<GaugeStateOption> {\n    name?: string;\n    value?: OptionDataValueNumeric;\n    pointer?: PointerOption;\n}\nexport interface GaugeSeriesOption extends SeriesOption<GaugeStateOption>, GaugeStateOption, CircleLayoutOptionMixin {\n    type?: 'gauge';\n    radius?: number | string;\n    startAngle?: number;\n    endAngle?: number;\n    clockwise?: boolean;\n    min?: number;\n    max?: number;\n    splitNumber?: number;\n    axisLine?: {\n        show?: boolean;\n        lineStyle: Omit<LineStyleOption, 'color'> & {\n            color: GaugeColorStop[];\n        };\n    };\n    splitLine?: {\n        show?: boolean;\n        length?: number;\n        lineStyle?: LineStyleOption;\n    };\n    axisTick?: {\n        show?: boolean;\n        splitNumber?: number;\n        length?: number | string;\n        lineStyle?: LineStyleOption;\n    };\n    axisLabel?: LabelOption & {\n        formatter?: LabelFormatter | string;\n    };\n    pointer?: PointerOption;\n    title?: LabelOption & {\n        offsetCenter?: (number | string)[];\n        formatter?: LabelFormatter | string;\n    };\n    detail?: LabelOption & {\n        offsetCenter?: (number | string)[];\n        formatter?: LabelFormatter | string;\n    };\n    data?: OptionDataValueNumeric | GaugeDataItemOption;\n}\ndeclare class GaugeSeriesModel extends SeriesModel<GaugeSeriesOption> {\n    static type: \"series.gauge\";\n    type: \"series.gauge\";\n    getInitialData(option: GaugeSeriesOption, ecModel: GlobalModel): List;\n    static defaultOption: GaugeSeriesOption;\n}\nexport default GaugeSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/gauge/GaugeView.d.ts",
    "code": "import ChartView from '../../view/Chart';\nimport GaugeSeriesModel from './GaugeSeries';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { ColorString } from '../../util/types';\ninterface PosInfo {\n    cx: number;\n    cy: number;\n    r: number;\n}\ndeclare class GaugeView extends ChartView {\n    static type: \"gauge\";\n    type: \"gauge\";\n    private _data;\n    render(seriesModel: GaugeSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    dispose(): void;\n    _renderMain(seriesModel: GaugeSeriesModel, ecModel: GlobalModel, api: ExtensionAPI, colorList: [number, ColorString][], posInfo: PosInfo): void;\n    _renderTicks(seriesModel: GaugeSeriesModel, ecModel: GlobalModel, api: ExtensionAPI, getColor: (percent: number) => ColorString, posInfo: PosInfo, startAngle: number, endAngle: number, clockwise: boolean): void;\n    _renderPointer(seriesModel: GaugeSeriesModel, ecModel: GlobalModel, api: ExtensionAPI, getColor: (percent: number) => ColorString, posInfo: PosInfo, startAngle: number, endAngle: number, clockwise: boolean): void;\n    _renderTitle(seriesModel: GaugeSeriesModel, ecModel: GlobalModel, api: ExtensionAPI, getColor: (percent: number) => ColorString, posInfo: PosInfo): void;\n    _renderDetail(seriesModel: GaugeSeriesModel, ecModel: GlobalModel, api: ExtensionAPI, getColor: (percent: number) => ColorString, posInfo: PosInfo): void;\n}\nexport default GaugeView;\n"
  },
  {
    "path": "echarts/types/src/chart/gauge/PointerPath.d.ts",
    "code": "import Path, { PathProps } from 'zrender/esm/graphic/Path';\ndeclare class PointerShape {\n    angle: number;\n    width: number;\n    r: number;\n    x: number;\n    y: number;\n}\ninterface PointerPathProps extends PathProps {\n    shape?: Partial<PointerShape>;\n}\nexport default class PointerPath extends Path<PointerPathProps> {\n    readonly type = \"pointer\";\n    shape: PointerShape;\n    constructor(opts?: PointerPathProps);\n    getDefaultShape(): PointerShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: PointerShape): void;\n}\nexport {};\n"
  },
  {
    "path": "echarts/types/src/chart/graph.d.ts",
    "code": "import './graph/GraphSeries';\nimport './graph/GraphView';\nimport './graph/graphAction';\n"
  },
  {
    "path": "echarts/types/src/chart/graph/adjustEdge.d.ts",
    "code": "import Graph from '../../data/Graph';\nexport default function (graph: Graph, scale: number): void;\n"
  },
  {
    "path": "echarts/types/src/chart/graph/categoryFilter.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nexport default function (ecModel: GlobalModel): void;\n"
  },
  {
    "path": "echarts/types/src/chart/graph/categoryVisual.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nexport default function (ecModel: GlobalModel): void;\n"
  },
  {
    "path": "echarts/types/src/chart/graph/circularLayout.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nexport default function (ecModel: GlobalModel): void;\n"
  },
  {
    "path": "echarts/types/src/chart/graph/circularLayoutHelper.d.ts",
    "code": "import GraphSeriesModel from './GraphSeries';\nexport declare function circularLayout(seriesModel: GraphSeriesModel, basedOn: 'value' | 'symbolSize'): void;\n"
  },
  {
    "path": "echarts/types/src/chart/graph/createView.d.ts",
    "code": "import View from '../../coord/View';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport GlobalModel from '../../model/Global';\nexport default function (ecModel: GlobalModel, api: ExtensionAPI): View[];\n"
  },
  {
    "path": "echarts/types/src/chart/graph/edgeVisual.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nexport default function (ecModel: GlobalModel): void;\n"
  },
  {
    "path": "echarts/types/src/chart/graph/forceHelper.d.ts",
    "code": "import * as vec2 from 'zrender/esm/core/vector';\nimport { RectLike } from 'zrender/esm/core/BoundingRect';\ninterface InputNode {\n    p?: vec2.VectorArray;\n    fixed?: boolean;\n    w: number;\n    rep: number;\n}\ninterface InputEdge {\n    ignoreForceLayout?: boolean;\n    n1: InputNode;\n    n2: InputNode;\n    d: number;\n}\ninterface LayoutCfg {\n    gravity?: number;\n    friction?: number;\n    rect?: RectLike;\n}\nexport declare function forceLayout<N extends InputNode, E extends InputEdge>(inNodes: N[], inEdges: E[], opts: LayoutCfg): {\n    warmUp: () => void;\n    setFixed: (idx: number) => void;\n    setUnfixed: (idx: number) => void;\n    beforeStep: (cb: (nodes: N[], edges: E[]) => void) => void;\n    afterStep: (cb: (nodes: N[], edges: E[], finished: boolean) => void) => void;\n    step: (cb?: (finished: boolean) => void) => void;\n};\nexport {};\n"
  },
  {
    "path": "echarts/types/src/chart/graph/forceLayout.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nexport interface ForceLayoutInstance {\n    step(cb: (stopped: boolean) => void): void;\n    warmUp(): void;\n    setFixed(idx: number): void;\n    setUnfixed(idx: number): void;\n}\nexport default function (ecModel: GlobalModel): void;\n"
  },
  {
    "path": "echarts/types/src/chart/graph/graphAction.d.ts",
    "code": "import '../helper/focusNodeAdjacencyAction';\n"
  },
  {
    "path": "echarts/types/src/chart/graph/graphHelper.d.ts",
    "code": "import GraphSeriesModel from './GraphSeries';\nimport { GraphNode } from '../../data/Graph';\nexport declare function getNodeGlobalScale(seriesModel: GraphSeriesModel): number;\nexport declare function getSymbolSize(node: GraphNode): number;\n"
  },
  {
    "path": "echarts/types/src/chart/graph/GraphSeries.d.ts",
    "code": "import List from '../../data/List';\nimport { SeriesOption, SeriesOnCartesianOptionMixin, SeriesOnPolarOptionMixin, SeriesOnCalendarOptionMixin, SeriesOnGeoOptionMixin, SeriesOnSingleOptionMixin, OptionDataValue, RoamOptionMixin, LabelOption, ItemStyleOption, LineStyleOption, SymbolOptionMixin, BoxLayoutOptionMixin, LabelFormatterCallback, Dictionary, LineLabelOption, StatesOptionMixin, GraphEdgeItemObject, OptionDataValueNumeric, TooltipRenderMode } from '../../util/types';\nimport SeriesModel from '../../model/Series';\nimport Graph from '../../data/Graph';\nimport GlobalModel from '../../model/Global';\nimport { VectorArray } from 'zrender/esm/core/vector';\nimport { ForceLayoutInstance } from './forceLayout';\nimport { LineDataVisual } from '../../visual/commonVisualTypes';\ndeclare type GraphDataValue = OptionDataValue | OptionDataValue[];\ninterface GraphEdgeLineStyleOption extends LineStyleOption {\n    curveness: number;\n}\nexport interface GraphNodeStateOption {\n    itemStyle?: ItemStyleOption;\n    label?: LabelOption;\n}\ninterface ExtraNodeStateOption {\n    emphasis?: {\n        focus?: 'adjacency';\n        scale?: boolean;\n    };\n}\ninterface ExtraEdgeStateOption {\n    emphasis?: {\n        focus?: 'adjacency';\n    };\n}\nexport interface GraphNodeItemOption extends SymbolOptionMixin, GraphNodeStateOption, GraphNodeStateOption, StatesOptionMixin<GraphNodeStateOption, ExtraNodeStateOption> {\n    id?: string;\n    name?: string;\n    value?: GraphDataValue;\n    x?: number;\n    y?: number;\n    fixed?: boolean;\n    category?: number | string;\n    draggable?: boolean;\n}\nexport interface GraphEdgeStateOption {\n    lineStyle?: GraphEdgeLineStyleOption;\n    label?: LineLabelOption;\n}\nexport interface GraphEdgeItemOption extends GraphEdgeStateOption, StatesOptionMixin<GraphEdgeStateOption, ExtraEdgeStateOption>, GraphEdgeItemObject<OptionDataValueNumeric> {\n    value?: number;\n    symbol?: string | string[];\n    symbolSize?: number | number[];\n    ignoreForceLayout?: boolean;\n}\nexport interface GraphCategoryItemOption extends SymbolOptionMixin, GraphNodeStateOption, StatesOptionMixin<GraphNodeStateOption> {\n    name?: string;\n    value?: OptionDataValue;\n}\nexport interface GraphSeriesOption extends SeriesOption, SeriesOnCartesianOptionMixin, SeriesOnPolarOptionMixin, SeriesOnCalendarOptionMixin, SeriesOnGeoOptionMixin, SeriesOnSingleOptionMixin, SymbolOptionMixin, RoamOptionMixin, BoxLayoutOptionMixin {\n    type?: 'graph';\n    coordinateSystem?: string;\n    legendHoverLink?: boolean;\n    layout?: 'none' | 'force' | 'circular';\n    data?: GraphNodeItemOption[];\n    nodes?: GraphNodeItemOption[];\n    edges?: GraphEdgeItemOption[];\n    links?: GraphEdgeItemOption[];\n    categories?: GraphCategoryItemOption[];\n    focusNodeAdjacency?: boolean;\n    nodeScaleRatio?: 0.6;\n    draggable?: boolean;\n    edgeSymbol?: string | string[];\n    edgeSymbolSize?: number | number[];\n    edgeLabel?: LineLabelOption & {\n        formatter?: LabelFormatterCallback | string;\n    };\n    label?: LabelOption & {\n        formatter?: LabelFormatterCallback | string;\n    };\n    itemStyle?: ItemStyleOption;\n    lineStyle?: GraphEdgeLineStyleOption;\n    emphasis?: {\n        focus?: GraphNodeItemOption['emphasis']['focus'];\n        scale?: boolean;\n        label?: LabelOption;\n        edgeLabel?: LabelOption;\n        itemStyle?: ItemStyleOption;\n        lineStyle?: LineStyleOption;\n    };\n    blur?: {\n        label?: LabelOption;\n        edgeLabel?: LabelOption;\n        itemStyle?: ItemStyleOption;\n        lineStyle?: LineStyleOption;\n    };\n    select?: {\n        label?: LabelOption;\n        edgeLabel?: LabelOption;\n        itemStyle?: ItemStyleOption;\n        lineStyle?: LineStyleOption;\n    };\n    circular?: {\n        rotateLabel?: boolean;\n    };\n    force?: {\n        initLayout?: 'circular' | 'none';\n        repulsion?: number | number[];\n        gravity?: number;\n        friction?: number;\n        edgeLength?: number | number[];\n        layoutAnimation?: boolean;\n    };\n}\ndeclare class GraphSeriesModel extends SeriesModel<GraphSeriesOption> {\n    static readonly type = \"series.graph\";\n    readonly type = \"series.graph\";\n    private _categoriesData;\n    private _categoriesModels;\n    preservedPoints?: Dictionary<VectorArray>;\n    forceLayout?: ForceLayoutInstance;\n    hasSymbolVisual: boolean;\n    init(option: GraphSeriesOption): void;\n    mergeOption(option: GraphSeriesOption): void;\n    mergeDefaultAndTheme(option: GraphSeriesOption): void;\n    getInitialData(option: GraphSeriesOption, ecModel: GlobalModel): List;\n    getGraph(): Graph;\n    getEdgeData(): List<GraphSeriesModel, LineDataVisual>;\n    getCategoriesData(): List;\n    formatTooltip(dataIndex: number, multipleSeries: boolean, dataType: string, renderMode: TooltipRenderMode): string | {\n        html: string;\n        markers: Dictionary<string>;\n    };\n    _updateCategoriesData(): void;\n    setZoom(zoom: number): void;\n    setCenter(center: number[]): void;\n    isAnimationEnabled(): boolean;\n    static defaultOption: GraphSeriesOption;\n}\nexport default GraphSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/graph/GraphView.d.ts",
    "code": "import ChartView from '../../view/Chart';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport GraphSeriesModel from './GraphSeries';\ndeclare class GraphView extends ChartView {\n    static readonly type = \"graph\";\n    readonly type = \"graph\";\n    private _symbolDraw;\n    private _lineDraw;\n    private _controller;\n    private _controllerHost;\n    private _firstRender;\n    private _model;\n    private _layoutTimeout;\n    private _layouting;\n    init(ecModel: GlobalModel, api: ExtensionAPI): void;\n    render(seriesModel: GraphSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    dispose(): void;\n    _startForceLayoutIteration(forceLayout: GraphSeriesModel['forceLayout'], layoutAnimation?: boolean): void;\n    _updateController(seriesModel: GraphSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    _updateNodeAndLinkScale(): void;\n    updateLayout(seriesModel: GraphSeriesModel): void;\n    remove(ecModel: GlobalModel, api: ExtensionAPI): void;\n}\nexport default GraphView;\n"
  },
  {
    "path": "echarts/types/src/chart/graph/simpleLayout.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nexport default function (ecModel: GlobalModel, api: ExtensionAPI): void;\n"
  },
  {
    "path": "echarts/types/src/chart/graph/simpleLayoutHelper.d.ts",
    "code": "import GraphSeriesModel from './GraphSeries';\nimport Graph from '../../data/Graph';\nexport declare function simpleLayout(seriesModel: GraphSeriesModel): void;\nexport declare function simpleLayoutEdge(graph: Graph): void;\n"
  },
  {
    "path": "echarts/types/src/chart/heatmap.d.ts",
    "code": "import './heatmap/HeatmapSeries';\nimport './heatmap/HeatmapView';\n"
  },
  {
    "path": "echarts/types/src/chart/heatmap/HeatmapLayer.d.ts",
    "code": "declare type ColorFunc = (grad: number, fastMode: boolean, output: number[]) => void;\ndeclare type ColorState = 'inRange' | 'outOfRange';\ndeclare class HeatmapLayer {\n    canvas: HTMLCanvasElement;\n    blurSize: number;\n    pointSize: number;\n    maxOpacity: number;\n    minOpacity: number;\n    private _brushCanvas;\n    private _gradientPixels;\n    constructor();\n    update(data: number[][], width: number, height: number, normalize: (value: number) => number, colorFunc: Record<ColorState, ColorFunc>, isInRange?: (grad?: number) => boolean): HTMLCanvasElement;\n    _getBrush(): HTMLCanvasElement;\n    _getGradient(colorFunc: Record<ColorState, ColorFunc>, state: ColorState): Uint8ClampedArray;\n}\nexport default HeatmapLayer;\n"
  },
  {
    "path": "echarts/types/src/chart/heatmap/HeatmapSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { SeriesOption, SeriesOnCartesianOptionMixin, SeriesOnGeoOptionMixin, ItemStyleOption, LabelOption, OptionDataValue, StatesOptionMixin } from '../../util/types';\nimport GlobalModel from '../../model/Global';\nimport List from '../../data/List';\nimport Geo from '../../coord/geo/Geo';\nimport Cartesian2D from '../../coord/cartesian/Cartesian2D';\nimport Calendar from '../../coord/calendar/Calendar';\ndeclare type HeatmapDataValue = OptionDataValue[];\nexport interface HeatmapStateOption {\n    itemStyle?: ItemStyleOption;\n    label?: LabelOption;\n}\nexport interface HeatmapDataItemOption extends HeatmapStateOption, StatesOptionMixin<HeatmapStateOption> {\n    value: HeatmapDataValue;\n}\nexport interface HeatmapSeriesOption extends SeriesOption<HeatmapStateOption>, HeatmapStateOption, SeriesOnCartesianOptionMixin, SeriesOnGeoOptionMixin {\n    type?: 'heatmap';\n    coordinateSystem?: 'cartesian2d' | 'geo' | 'calendar';\n    blurSize?: number;\n    pointSize?: number;\n    maxOpacity?: number;\n    minOpacity?: number;\n    data?: (HeatmapDataItemOption | HeatmapDataValue)[];\n}\ndeclare class HeatmapSeriesModel extends SeriesModel<HeatmapSeriesOption> {\n    static readonly type = \"series.heatmap\";\n    readonly type = \"series.heatmap\";\n    coordinateSystem: Cartesian2D | Geo | Calendar;\n    getInitialData(option: HeatmapSeriesOption, ecModel: GlobalModel): List;\n    preventIncremental(): boolean;\n    static defaultOption: HeatmapSeriesOption;\n}\nexport default HeatmapSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/heatmap/HeatmapView.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport ChartView from '../../view/Chart';\nimport HeatmapSeriesModel from './HeatmapSeries';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport VisualMapModel from '../../component/visualMap/VisualMapModel';\nimport { CoordinateSystem } from '../../coord/CoordinateSystem';\nimport { StageHandlerProgressParams } from '../../util/types';\ninterface GeoLikeCoordSys extends CoordinateSystem {\n    dimensions: ['lng', 'lat'];\n    getViewRect(): graphic.BoundingRect;\n}\ndeclare class HeatmapView extends ChartView {\n    static readonly type = \"heatmap\";\n    readonly type = \"heatmap\";\n    private _incrementalDisplayable;\n    private _hmLayer;\n    render(seriesModel: HeatmapSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    incrementalPrepareRender(seriesModel: HeatmapSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    incrementalRender(params: StageHandlerProgressParams, seriesModel: HeatmapSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    _renderOnCartesianAndCalendar(seriesModel: HeatmapSeriesModel, api: ExtensionAPI, start: number, end: number, incremental?: boolean): void;\n    _renderOnGeo(geo: GeoLikeCoordSys, seriesModel: HeatmapSeriesModel, visualMapModel: VisualMapModel, api: ExtensionAPI): void;\n}\nexport default HeatmapView;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/createClipPathFromCoordSys.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport SeriesModel from '../../model/Series';\nimport { SeriesOption } from '../../util/types';\nimport Cartesian2D from '../../coord/cartesian/Cartesian2D';\nimport Polar from '../../coord/polar/Polar';\nimport { CoordinateSystem } from '../../coord/CoordinateSystem';\ndeclare type SeriesModelWithLineWidth = SeriesModel<SeriesOption & {\n    lineStyle?: {\n        width?: number;\n    };\n}>;\ndeclare function createGridClipPath(cartesian: Cartesian2D, hasAnimation: boolean, seriesModel: SeriesModelWithLineWidth): graphic.Rect;\ndeclare function createPolarClipPath(polar: Polar, hasAnimation: boolean, seriesModel: SeriesModelWithLineWidth): graphic.Sector;\ndeclare function createClipPath(coordSys: CoordinateSystem, hasAnimation: boolean, seriesModel: SeriesModelWithLineWidth): graphic.Rect | graphic.Sector;\nexport { createGridClipPath, createPolarClipPath, createClipPath };\n"
  },
  {
    "path": "echarts/types/src/chart/helper/createGraphFromNodeEdge.d.ts",
    "code": "import List from '../../data/List';\nimport Graph from '../../data/Graph';\nimport { OptionSourceDataOriginal, GraphEdgeItemObject, OptionDataValue, OptionDataItemObject } from '../../util/types';\nimport SeriesModel from '../../model/Series';\nexport default function (nodes: OptionSourceDataOriginal<OptionDataValue, OptionDataItemObject<OptionDataValue>>, edges: OptionSourceDataOriginal<OptionDataValue, GraphEdgeItemObject<OptionDataValue>>, seriesModel: SeriesModel, directed: boolean, beforeLink: (nodeData: List, edgeData: List) => void): Graph;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/createListFromArray.d.ts",
    "code": "import List from '../../data/List';\nimport Source from '../../data/Source';\nimport { OptionSourceData, EncodeDefaulter } from '../../util/types';\nimport SeriesModel from '../../model/Series';\ndeclare function createListFromArray(source: Source | OptionSourceData, seriesModel: SeriesModel, opt?: {\n    generateCoord?: string;\n    useEncodeDefaulter?: boolean | EncodeDefaulter;\n}): List;\nexport default createListFromArray;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/createListSimply.d.ts",
    "code": "import { CreateDimensionsParams } from '../../data/helper/createDimensions';\nimport List from '../../data/List';\nimport SeriesModel from '../../model/Series';\nexport default function (seriesModel: SeriesModel, opt: CreateDimensionsParams | CreateDimensionsParams['coordDimensions'], nameList?: string[]): List;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/createRenderPlanner.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nexport default function (): (seriesModel: SeriesModel<import(\"../../util/types\").SeriesOption<any, unknown>>) => import(\"../../stream/task\").TaskPlanCallbackReturn;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/EffectLine.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport { createSymbol } from '../../util/symbol';\nimport List from '../../data/List';\nimport { LineDrawSeriesScope } from './LineDraw';\nexport declare type ECSymbolOnEffectLine = ReturnType<typeof createSymbol> & {\n    __t: number;\n    __lastT: number;\n    __p1: number[];\n    __p2: number[];\n    __cp1: number[];\n};\ndeclare class EffectLine extends graphic.Group {\n    private _symbolType;\n    private _period;\n    private _loop;\n    private _symbolScale;\n    constructor(lineData: List, idx: number, seriesScope: LineDrawSeriesScope);\n    createLine(lineData: List, idx: number, seriesScope: LineDrawSeriesScope): graphic.Group;\n    private _updateEffectSymbol;\n    private _updateEffectAnimation;\n    protected _getLineLength(symbol: ECSymbolOnEffectLine): number;\n    protected _updateAnimationPoints(symbol: ECSymbolOnEffectLine, points: number[][]): void;\n    updateData(lineData: List, idx: number, seriesScope: LineDrawSeriesScope): void;\n    protected _updateSymbolPosition(symbol: ECSymbolOnEffectLine): void;\n    updateLayout(lineData: List, idx: number): void;\n}\nexport default EffectLine;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/EffectPolyline.d.ts",
    "code": "import Polyline from './Polyline';\nimport EffectLine, { ECSymbolOnEffectLine } from './EffectLine';\nimport { LineDrawSeriesScope } from './LineDraw';\nimport List from '../../data/List';\ndeclare class EffectPolyline extends EffectLine {\n    private _lastFrame;\n    private _lastFramePercent;\n    private _length;\n    private _points;\n    private _offsets;\n    createLine(lineData: List, idx: number, seriesScope: LineDrawSeriesScope): Polyline;\n    protected _updateAnimationPoints(symbol: ECSymbolOnEffectLine, points: number[][]): void;\n    protected _getLineLength(): number;\n    protected _updateSymbolPosition(symbol: ECSymbolOnEffectLine): void;\n}\nexport default EffectPolyline;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/EffectSymbol.d.ts",
    "code": "import { Group } from '../../util/graphic';\nimport List from '../../data/List';\nimport { ZRColor } from '../../util/types';\ninterface RippleEffectCfg {\n    showEffectOn?: 'emphasis' | 'render';\n    rippleScale?: number;\n    brushType?: 'fill' | 'stroke';\n    period?: number;\n    effectOffset?: number;\n    z?: number;\n    zlevel?: number;\n    symbolType?: string;\n    color?: ZRColor;\n    rippleEffectColor?: ZRColor;\n}\ndeclare class EffectSymbol extends Group {\n    private _effectCfg;\n    constructor(data: List, idx: number);\n    stopEffectAnimation(): void;\n    startEffectAnimation(effectCfg: RippleEffectCfg): void;\n    updateEffectAnimation(effectCfg: RippleEffectCfg): void;\n    highlight(): void;\n    downplay(): void;\n    updateData(data: List, idx: number): void;\n    fadeOut(cb: () => void): void;\n}\nexport default EffectSymbol;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/focusNodeAdjacencyAction.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/chart/helper/labelHelper.d.ts",
    "code": "import List from '../../data/List';\nimport { ParsedValue } from '../../util/types';\nexport declare function getDefaultLabel(data: List, dataIndex: number, interpolatedValues?: ParsedValue | ParsedValue[]): string;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/LargeLineDraw.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport IncrementalDisplayable from 'zrender/esm/graphic/IncrementalDisplayable';\nimport { PathProps } from 'zrender/esm/graphic/Path';\nimport List from '../../data/List';\nimport { StageHandlerProgressParams, LineStyleOption } from '../../util/types';\nimport Model from '../../model/Model';\ndeclare class LargeLinesPathShape {\n    polyline: boolean;\n    curveness: number;\n    segs: ArrayLike<number>;\n}\ninterface LargeLinesPathProps extends PathProps {\n    shape?: Partial<LargeLinesPathShape>;\n}\ninterface LargeLinesCommonOption {\n    polyline?: boolean;\n    lineStyle?: LineStyleOption & {\n        curveness?: number;\n    };\n}\ndeclare type LargeLinesData = List<Model<LargeLinesCommonOption> & {\n    seriesIndex?: number;\n}>;\ndeclare class LargeLinesPath extends graphic.Path {\n    shape: LargeLinesPathShape;\n    __startIndex: number;\n    constructor(opts?: LargeLinesPathProps);\n    getDefaultStyle(): {\n        stroke: string;\n        fill: string;\n    };\n    getDefaultShape(): LargeLinesPathShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: LargeLinesPathShape): void;\n    findDataIndex(x: number, y: number): number;\n}\ndeclare class LargeLineDraw {\n    group: graphic.Group;\n    _incremental?: IncrementalDisplayable;\n    isPersistent(): boolean;\n    updateData(data: LargeLinesData): void;\n    incrementalPrepareUpdate(data: LargeLinesData): void;\n    incrementalUpdate(taskParams: StageHandlerProgressParams, data: LargeLinesData): void;\n    remove(): void;\n    _setCommon(lineEl: LargeLinesPath, data: LargeLinesData, isIncremental?: boolean): void;\n    _clearIncremental(): void;\n}\nexport default LargeLineDraw;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/LargeSymbolDraw.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport { createSymbol } from '../../util/symbol';\nimport IncrementalDisplayable from 'zrender/esm/graphic/IncrementalDisplayable';\nimport List from '../../data/List';\nimport { PathProps } from 'zrender/esm/graphic/Path';\nimport PathProxy from 'zrender/esm/core/PathProxy';\nimport { StageHandlerProgressParams } from '../../util/types';\nimport { CoordinateSystemClipArea } from '../../coord/CoordinateSystem';\ndeclare class LargeSymbolPathShape {\n    points: ArrayLike<number>;\n    size: number[];\n}\ndeclare type LargeSymbolPathProps = PathProps & {\n    shape?: Partial<LargeSymbolPathShape>;\n    startIndex?: number;\n    endIndex?: number;\n};\ndeclare type ECSymbol = ReturnType<typeof createSymbol>;\ndeclare class LargeSymbolPath extends graphic.Path<LargeSymbolPathProps> {\n    shape: LargeSymbolPathShape;\n    symbolProxy: ECSymbol;\n    softClipShape: CoordinateSystemClipArea;\n    startIndex: number;\n    endIndex: number;\n    private _ctx;\n    constructor(opts?: LargeSymbolPathProps);\n    getDefaultShape(): LargeSymbolPathShape;\n    setColor: ECSymbol['setColor'];\n    buildPath(path: PathProxy | CanvasRenderingContext2D, shape: LargeSymbolPathShape): void;\n    afterBrush(): void;\n    findDataIndex(x: number, y: number): number;\n}\ninterface UpdateOpt {\n    clipShape?: CoordinateSystemClipArea;\n}\ndeclare class LargeSymbolDraw {\n    group: graphic.Group;\n    _incremental: IncrementalDisplayable;\n    isPersistent(): boolean;\n    updateData(data: List, opt?: UpdateOpt): void;\n    updateLayout(data: List): void;\n    incrementalPrepareUpdate(data: List): void;\n    incrementalUpdate(taskParams: StageHandlerProgressParams, data: List, opt: UpdateOpt): void;\n    _setCommon(symbolEl: LargeSymbolPath, data: List, isIncremental: boolean, opt: UpdateOpt): void;\n    remove(): void;\n    _clearIncremental(): void;\n}\nexport default LargeSymbolDraw;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/Line.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport List from '../../data/List';\nimport SeriesModel from '../../model/Series';\nimport { LineDrawSeriesScope } from './LineDraw';\nimport { LineDataVisual } from '../../visual/commonVisualTypes';\ndeclare type LineList = List<SeriesModel, LineDataVisual>;\nexport interface LineLabel extends graphic.Text {\n    lineLabelOriginalOpacity: number;\n}\ndeclare class Line extends graphic.Group {\n    private _fromSymbolType;\n    private _toSymbolType;\n    constructor(lineData: List, idx: number, seriesScope?: LineDrawSeriesScope);\n    _createLine(lineData: LineList, idx: number, seriesScope?: LineDrawSeriesScope): void;\n    updateData(lineData: List, idx: number, seriesScope: LineDrawSeriesScope): void;\n    getLinePath(): graphic.Line;\n    _updateCommonStl(lineData: List, idx: number, seriesScope?: LineDrawSeriesScope): void;\n    highlight(): void;\n    downplay(): void;\n    updateLayout(lineData: List, idx: number): void;\n    setLinePoints(points: number[][]): void;\n    beforeUpdate(): void;\n}\nexport default Line;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/LineDraw.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport List from '../../data/List';\nimport { StageHandlerProgressParams, LineStyleOption, LineLabelOption, ColorString, AnimationOptionMixin, ZRStyleProps, StatesOptionMixin, DisplayState, LabelOption } from '../../util/types';\nimport Model from '../../model/Model';\ninterface LineLike extends graphic.Group {\n    updateData(data: List, idx: number, scope?: LineDrawSeriesScope): void;\n    updateLayout(data: List, idx: number): void;\n    fadeOut?(cb: () => void): void;\n}\ninterface LineLikeCtor {\n    new (data: List, idx: number, scope?: LineDrawSeriesScope): LineLike;\n}\ninterface LineDrawStateOption {\n    lineStyle?: LineStyleOption;\n    label?: LineLabelOption;\n}\nexport interface LineDrawModelOption extends LineDrawStateOption, StatesOptionMixin<LineDrawStateOption> {\n    effect?: {\n        show?: boolean;\n        period?: number;\n        delay?: number | ((idx: number) => number);\n        constantSpeed?: number;\n        symbol?: string;\n        symbolSize?: number | number[];\n        loop?: boolean;\n        trailLength?: number;\n        color?: ColorString;\n    };\n}\ndeclare type ListForLineDraw = List<Model<LineDrawModelOption & AnimationOptionMixin>>;\nexport interface LineDrawSeriesScope {\n    lineStyle?: ZRStyleProps;\n    emphasisLineStyle?: ZRStyleProps;\n    blurLineStyle?: ZRStyleProps;\n    selectLineStyle?: ZRStyleProps;\n    labelStatesModels: Record<DisplayState, Model<LabelOption>>;\n}\ndeclare class LineDraw {\n    group: graphic.Group;\n    private _LineCtor;\n    private _lineData;\n    private _seriesScope;\n    constructor(LineCtor?: LineLikeCtor);\n    isPersistent(): boolean;\n    updateData(lineData: ListForLineDraw): void;\n    updateLayout(): void;\n    incrementalPrepareUpdate(lineData: ListForLineDraw): void;\n    incrementalUpdate(taskParams: StageHandlerProgressParams, lineData: ListForLineDraw): void;\n    remove(): void;\n    private _doAdd;\n    private _doUpdate;\n}\nexport default LineDraw;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/LinePath.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport { PathProps } from 'zrender/esm/graphic/Path';\ndeclare class StraightLineShape {\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    percent: number;\n}\ndeclare class CurveShape extends StraightLineShape {\n    cpx1: number;\n    cpy1: number;\n}\ninterface ECLineProps extends PathProps {\n    shape?: Partial<StraightLineShape | CurveShape>;\n}\ndeclare class ECLinePath extends graphic.Path<ECLineProps> {\n    type: string;\n    shape: StraightLineShape | CurveShape;\n    constructor(opts?: ECLineProps);\n    getDefaultStyle(): {\n        stroke: string;\n        fill: string;\n    };\n    getDefaultShape(): StraightLineShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: StraightLineShape | CurveShape): void;\n    pointAt(t: number): number[];\n    tangentAt(t: number): number[];\n}\nexport default ECLinePath;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/Polyline.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport { LineDrawSeriesScope } from './LineDraw';\nimport List from '../../data/List';\ndeclare class Polyline extends graphic.Group {\n    constructor(lineData: List, idx: number, seriesScope: LineDrawSeriesScope);\n    private _createPolyline;\n    updateData(lineData: List, idx: number, seriesScope: LineDrawSeriesScope): void;\n    _updateCommonStl(lineData: List, idx: number, seriesScope: LineDrawSeriesScope): void;\n    updateLayout(lineData: List, idx: number): void;\n}\nexport default Polyline;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/Symbol.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport List from '../../data/List';\nimport { PathProps } from 'zrender/esm/graphic/Path';\nimport { SymbolDrawSeriesScope } from './SymbolDraw';\ninterface SymbolOpts {\n    useNameLabel?: boolean;\n    symbolInnerColor?: string;\n}\ndeclare class Symbol extends graphic.Group {\n    private _seriesModel;\n    private _symbolType;\n    private _sizeX;\n    private _sizeY;\n    private _z2;\n    constructor(data: List, idx: number, seriesScope?: SymbolDrawSeriesScope, opts?: SymbolOpts);\n    _createSymbol(symbolType: string, data: List, idx: number, symbolSize: number[], keepAspect: boolean): void;\n    stopSymbolAnimation(toLastFrame: boolean): void;\n    getSymbolPath(): graphic.Path<PathProps> & {\n        __isEmptyBrush?: boolean;\n        setColor: (color: string | import(\"zrender/esm/graphic/Pattern\").PatternObject | import(\"zrender/esm/graphic/LinearGradient\").LinearGradientObject | import(\"zrender/esm/graphic/RadialGradient\").RadialGradientObject, innerColor?: string) => void;\n        getColor: () => string | import(\"zrender/esm/graphic/Pattern\").PatternObject | import(\"zrender/esm/graphic/LinearGradient\").LinearGradientObject | import(\"zrender/esm/graphic/RadialGradient\").RadialGradientObject;\n    };\n    highlight(): void;\n    downplay(): void;\n    setZ(zlevel: number, z: number): void;\n    setDraggable(draggable: boolean): void;\n    updateData(data: List, idx: number, seriesScope?: SymbolDrawSeriesScope, opts?: SymbolOpts): void;\n    _updateCommon(data: List, idx: number, symbolSize: number[], seriesScope?: SymbolDrawSeriesScope, opts?: SymbolOpts): void;\n    setSymbolScale(scale: number): void;\n    fadeOut(cb: () => void, opt?: {\n        keepLabel: boolean;\n    }): void;\n    static getSymbolSize(data: List, idx: number): number[];\n}\nexport default Symbol;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/SymbolDraw.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport List from '../../data/List';\nimport { StageHandlerProgressParams, LabelOption, SymbolOptionMixin, ItemStyleOption, ZRColor, AnimationOptionMixin, ZRStyleProps, StatesOptionMixin, BlurScope, DisplayState } from '../../util/types';\nimport { CoordinateSystemClipArea } from '../../coord/CoordinateSystem';\nimport Model from '../../model/Model';\ninterface UpdateOpt {\n    isIgnore?(idx: number): boolean;\n    clipShape?: CoordinateSystemClipArea;\n}\ninterface SymbolLike extends graphic.Group {\n    updateData(data: List, idx: number, scope?: SymbolDrawSeriesScope): void;\n    fadeOut?(cb: () => void): void;\n}\ninterface SymbolLikeCtor {\n    new (data: List, idx: number, scope?: SymbolDrawSeriesScope): SymbolLike;\n}\ninterface RippleEffectOption {\n    period?: number;\n    scale?: number;\n    brushType?: 'fill' | 'stroke';\n    color?: ZRColor;\n}\ninterface SymbolDrawStateOption {\n    itemStyle?: ItemStyleOption;\n    label?: LabelOption;\n}\nexport interface SymbolDrawItemModelOption extends SymbolOptionMixin<object>, StatesOptionMixin<SymbolDrawStateOption, {\n    emphasis?: {\n        focus?: string;\n        scale?: boolean;\n    };\n}>, SymbolDrawStateOption {\n    cursor?: string;\n    rippleEffect?: RippleEffectOption;\n}\nexport interface SymbolDrawSeriesScope {\n    emphasisItemStyle?: ZRStyleProps;\n    blurItemStyle?: ZRStyleProps;\n    selectItemStyle?: ZRStyleProps;\n    focus?: string;\n    blurScope?: BlurScope;\n    symbolRotate?: number;\n    symbolOffset?: number[];\n    labelStatesModels: Record<DisplayState, Model<LabelOption>>;\n    itemModel?: Model<SymbolDrawItemModelOption>;\n    hoverScale?: boolean;\n    cursorStyle?: string;\n    fadeIn?: boolean;\n}\ndeclare type ListForSymbolDraw = List<Model<SymbolDrawItemModelOption & AnimationOptionMixin>>;\ndeclare class SymbolDraw {\n    group: graphic.Group;\n    private _data;\n    private _SymbolCtor;\n    private _seriesScope;\n    constructor(SymbolCtor?: SymbolLikeCtor);\n    updateData(data: ListForSymbolDraw, opt?: UpdateOpt): void;\n    isPersistent(): boolean;\n    updateLayout(): void;\n    incrementalPrepareUpdate(data: ListForSymbolDraw): void;\n    incrementalUpdate(taskParams: StageHandlerProgressParams, data: ListForSymbolDraw, opt?: UpdateOpt): void;\n    remove(enableAnimation?: boolean): void;\n}\nexport default SymbolDraw;\n"
  },
  {
    "path": "echarts/types/src/chart/helper/treeHelper.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { TreeNode } from '../../data/Tree';\nexport declare function retrieveTargetInfo(payload: {\n    type?: string;\n    targetNode?: string | TreeNode;\n    targetNodeId?: string;\n}, validPayloadTypes: string[], seriesModel: SeriesModel): {\n    node: TreeNode;\n};\nexport declare function getPathToRoot(node: TreeNode): TreeNode[];\nexport declare function aboveViewRoot(viewRoot: TreeNode, node: TreeNode): boolean;\nexport declare function wrapTreePathInfo<T = unknown>(node: TreeNode, seriesModel: SeriesModel): {\n    name: string;\n    dataIndex: number;\n    value: T;\n}[];\n"
  },
  {
    "path": "echarts/types/src/chart/helper/whiskerBoxCommon.d.ts",
    "code": "import { SeriesOption, SeriesOnCartesianOptionMixin, LayoutOrient } from '../../util/types';\nimport GlobalModel from '../../model/Global';\nimport SeriesModel from '../../model/Series';\nimport List from '../../data/List';\nimport Axis2D from '../../coord/cartesian/Axis2D';\nimport { CoordDimensionDefinition } from '../../data/helper/createDimensions';\ninterface CommonOption extends SeriesOption, SeriesOnCartesianOptionMixin {\n    layout?: LayoutOrient;\n}\ninterface WhiskerBoxCommonMixin<Opts extends CommonOption> extends SeriesModel<Opts> {\n}\ndeclare class WhiskerBoxCommonMixin<Opts extends CommonOption> {\n    _baseAxisDim: string;\n    defaultValueDimensions: CoordDimensionDefinition['dimsDef'];\n    getInitialData(option: Opts, ecModel: GlobalModel): List;\n    getBaseAxis(): Axis2D;\n}\nexport { WhiskerBoxCommonMixin };\n"
  },
  {
    "path": "echarts/types/src/chart/line.d.ts",
    "code": "import './line/LineSeries';\nimport './line/LineView';\nimport '../component/gridSimple';\n"
  },
  {
    "path": "echarts/types/src/chart/line/helper.d.ts",
    "code": "import Polar from '../../coord/polar/Polar';\nimport Cartesian2D from '../../coord/cartesian/Cartesian2D';\nimport List from '../../data/List';\nimport { LineSeriesOption } from './LineSeries';\ninterface CoordInfo {\n    dataDimsForPoint: string[];\n    valueStart: number;\n    valueAxisDim: string;\n    baseAxisDim: string;\n    stacked: boolean;\n    valueDim: string;\n    baseDim: string;\n    baseDataOffset: number;\n    stackedOverDimension: string;\n}\nexport declare function prepareDataCoordInfo(coordSys: Cartesian2D | Polar, data: List, valueOrigin?: LineSeriesOption['areaStyle']['origin']): CoordInfo;\nexport declare function getStackedOnPoint(dataCoordInfo: CoordInfo, coordSys: Cartesian2D | Polar, data: List, idx: number): number[];\nexport {};\n"
  },
  {
    "path": "echarts/types/src/chart/line/lineAnimationDiff.d.ts",
    "code": "import List from '../../data/List';\nimport Cartesian2D from '../../coord/cartesian/Cartesian2D';\nimport Polar from '../../coord/polar/Polar';\nimport { LineSeriesOption } from './LineSeries';\ninterface DiffItem {\n    cmd: '+' | '=' | '-';\n    idx: number;\n    idx1?: number;\n}\nexport default function (oldData: List, newData: List, oldStackedOnPoints: number[][], newStackedOnPoints: number[][], oldCoordSys: Cartesian2D | Polar, newCoordSys: Cartesian2D | Polar, oldValueOrigin: LineSeriesOption['areaStyle']['origin'], newValueOrigin: LineSeriesOption['areaStyle']['origin']): {\n    current: number[][];\n    next: number[][];\n    stackedOnCurrent: number[][];\n    stackedOnNext: number[][];\n    status: DiffItem[];\n};\nexport {};\n"
  },
  {
    "path": "echarts/types/src/chart/line/LineSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { SeriesOnCartesianOptionMixin, SeriesOption, SeriesOnPolarOptionMixin, SeriesStackOptionMixin, LabelOption, LineStyleOption, ItemStyleOption, AreaStyleOption, OptionDataValue, SymbolOptionMixin, SeriesSamplingOptionMixin, StatesOptionMixin } from '../../util/types';\nimport List from '../../data/List';\nimport Cartesian2D from '../../coord/cartesian/Cartesian2D';\nimport Polar from '../../coord/polar/Polar';\ndeclare type LineDataValue = OptionDataValue | OptionDataValue[];\ninterface ExtraStateOption {\n    emphasis?: {\n        scale?: boolean;\n    };\n}\nexport interface LineStateOption {\n    itemStyle?: ItemStyleOption;\n    label?: LabelOption;\n}\nexport interface LineDataItemOption extends SymbolOptionMixin, LineStateOption, StatesOptionMixin<LineStateOption, ExtraStateOption> {\n    name?: string;\n    value?: LineDataValue;\n}\nexport interface LineSeriesOption extends SeriesOption<LineStateOption, ExtraStateOption & {\n    emphasis?: {\n        lineStyle?: LineStyleOption | {\n            width?: 'bolder';\n        };\n        areaStyle?: AreaStyleOption;\n    };\n    blur?: {\n        lineStyle?: LineStyleOption;\n        areaStyle?: AreaStyleOption;\n    };\n}>, LineStateOption, SeriesOnCartesianOptionMixin, SeriesOnPolarOptionMixin, SeriesStackOptionMixin, SeriesSamplingOptionMixin, SymbolOptionMixin {\n    type?: 'line';\n    coordinateSystem?: 'cartesian2d' | 'polar';\n    clip?: boolean;\n    label?: LabelOption;\n    lineStyle?: LineStyleOption;\n    areaStyle?: AreaStyleOption & {\n        origin?: 'auto' | 'start' | 'end';\n    };\n    step?: false | 'start' | 'end' | 'middle';\n    smooth?: boolean;\n    smoothMonotone?: 'x' | 'y' | 'none';\n    connectNulls?: boolean;\n    showSymbol?: boolean;\n    showAllSymbol?: 'auto';\n    data?: (LineDataValue | LineDataItemOption)[];\n}\ndeclare class LineSeriesModel extends SeriesModel<LineSeriesOption> {\n    static readonly type = \"series.line\";\n    type: string;\n    static readonly dependencies: string[];\n    coordinateSystem: Cartesian2D | Polar;\n    hasSymbolVisual: boolean;\n    legendSymbol: string;\n    getInitialData(option: LineSeriesOption): List;\n    static defaultOption: LineSeriesOption;\n}\nexport default LineSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/line/LineView.d.ts",
    "code": "import ChartView from '../../view/Chart';\nexport default ChartView;\n"
  },
  {
    "path": "echarts/types/src/chart/line/poly.d.ts",
    "code": "import Path, { PathProps } from 'zrender/esm/graphic/Path';\ndeclare class ECPolylineShape {\n    points: number[][];\n    smooth: number;\n    smoothConstraint: boolean;\n    smoothMonotone: 'x' | 'y' | 'none';\n    connectNulls: boolean;\n}\ninterface ECPolylineProps extends PathProps {\n    shape?: Partial<ECPolylineShape>;\n}\nexport declare class ECPolyline extends Path<ECPolylineProps> {\n    readonly type = \"ec-polyline\";\n    shape: ECPolylineShape;\n    constructor(opts?: ECPolylineProps);\n    getDefaultStyle(): {\n        stroke: string;\n        fill: string;\n    };\n    getDefaultShape(): ECPolylineShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: ECPolylineShape): void;\n}\ndeclare class ECPolygonShape extends ECPolylineShape {\n    stackedOnPoints: number[][];\n    stackedOnSmooth: number;\n}\ninterface ECPolygonProps extends PathProps {\n    shape?: Partial<ECPolygonShape>;\n}\nexport declare class ECPolygon extends Path {\n    readonly type = \"ec-polygon\";\n    shape: ECPolygonShape;\n    constructor(opts?: ECPolygonProps);\n    getDefaultShape(): ECPolygonShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: ECPolygonShape): void;\n}\nexport {};\n"
  },
  {
    "path": "echarts/types/src/chart/lines.d.ts",
    "code": "import './lines/LinesSeries';\nimport './lines/LinesView';\n"
  },
  {
    "path": "echarts/types/src/chart/lines/linesLayout.d.ts",
    "code": "import { StageHandler } from '../../util/types';\ndeclare const linesLayout: StageHandler;\nexport default linesLayout;\n"
  },
  {
    "path": "echarts/types/src/chart/lines/LinesSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport List from '../../data/List';\nimport { SeriesOption, SeriesOnCartesianOptionMixin, SeriesOnGeoOptionMixin, SeriesOnPolarOptionMixin, SeriesOnCalendarOptionMixin, SeriesLargeOptionMixin, LineStyleOption, OptionDataValue, LineLabelOption, StatesOptionMixin, TooltipRenderMode } from '../../util/types';\nimport GlobalModel from '../../model/Global';\nimport { LineDrawModelOption } from '../helper/LineDraw';\ndeclare type LinesCoords = number[][];\ndeclare type LinesValue = OptionDataValue | OptionDataValue[];\ninterface LinesLineStyleOption extends LineStyleOption {\n    curveness?: number;\n}\nexport interface LinesStateOption {\n    lineStyle?: LinesLineStyleOption;\n    label?: LineLabelOption;\n}\nexport interface LinesDataItemOption extends LinesStateOption, StatesOptionMixin<LinesStateOption> {\n    name?: string;\n    fromName?: string;\n    toName?: string;\n    symbol?: string[] | string;\n    symbolSize?: number[] | number;\n    coords?: LinesCoords;\n    value?: LinesValue;\n}\nexport interface LinesSeriesOption extends SeriesOption<LinesStateOption>, LinesStateOption, SeriesOnCartesianOptionMixin, SeriesOnGeoOptionMixin, SeriesOnPolarOptionMixin, SeriesOnCalendarOptionMixin, SeriesLargeOptionMixin {\n    type?: 'lines';\n    coordinateSystem?: string;\n    symbol?: string[] | string;\n    symbolSize?: number[] | number;\n    effect?: LineDrawModelOption['effect'];\n    polyline?: boolean;\n    clip?: boolean;\n    data?: LinesDataItemOption[] | ArrayLike<number>;\n}\ndeclare class LinesSeriesModel extends SeriesModel<LinesSeriesOption> {\n    static readonly type = \"series.lines\";\n    readonly type = \"series.lines\";\n    static readonly dependencies: string[];\n    visualStyleAccessPath: string;\n    visualDrawType: \"stroke\";\n    private _flatCoords;\n    private _flatCoordsOffset;\n    init(option: LinesSeriesOption): void;\n    mergeOption(option: LinesSeriesOption): void;\n    appendData(params: Pick<LinesSeriesOption, 'data'>): void;\n    _getCoordsFromItemModel(idx: number): LinesCoords | (LinesDataItemOption & any[]);\n    getLineCoordsCount(idx: number): number;\n    getLineCoords(idx: number, out: number[][]): number;\n    _processFlatCoordsArray(data: LinesSeriesOption['data']): {\n        flatCoordsOffset: Uint32Array;\n        flatCoords: Float64Array;\n        count: number;\n    };\n    getInitialData(option: LinesSeriesOption, ecModel: GlobalModel): List<this, import(\"../../data/List\").DefaultDataVisual>;\n    formatTooltip(dataIndex: number, multipleSeries: boolean, dataType: string, renderMode: TooltipRenderMode): string;\n    preventIncremental(): boolean;\n    getProgressive(): number | false;\n    getProgressiveThreshold(): number;\n    static defaultOption: LinesSeriesOption;\n}\nexport default LinesSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/lines/LinesView.d.ts",
    "code": "import LineDraw from '../helper/LineDraw';\nimport LargeLineDraw from '../helper/LargeLineDraw';\nimport ChartView from '../../view/Chart';\nimport LinesSeriesModel from './LinesSeries';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { StageHandlerProgressParams } from '../../util/types';\nimport List from '../../data/List';\ndeclare class LinesView extends ChartView {\n    static readonly type = \"lines\";\n    readonly type = \"lines\";\n    private _lastZlevel;\n    private _finished;\n    private _lineDraw;\n    private _hasEffet;\n    private _isPolyline;\n    private _isLargeDraw;\n    render(seriesModel: LinesSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    incrementalPrepareRender(seriesModel: LinesSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    incrementalRender(taskParams: StageHandlerProgressParams, seriesModel: LinesSeriesModel, ecModel: GlobalModel): void;\n    updateTransform(seriesModel: LinesSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): {\n        readonly update: true;\n    };\n    _updateLineDraw(data: List, seriesModel: LinesSeriesModel): LineDraw | LargeLineDraw;\n    private _showEffect;\n    _clearLayer(api: ExtensionAPI): void;\n    remove(ecModel: GlobalModel, api: ExtensionAPI): void;\n}\nexport default LinesView;\n"
  },
  {
    "path": "echarts/types/src/chart/lines/linesVisual.d.ts",
    "code": "import { StageHandler } from '../../util/types';\ndeclare const linesVisual: StageHandler;\nexport default linesVisual;\n"
  },
  {
    "path": "echarts/types/src/chart/map.d.ts",
    "code": "import './map/MapSeries';\nimport './map/MapView';\nimport '../action/geoRoam';\nimport '../coord/geo/geoCreator';\n"
  },
  {
    "path": "echarts/types/src/chart/map/mapDataStatistic.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nexport default function (ecModel: GlobalModel): void;\n"
  },
  {
    "path": "echarts/types/src/chart/map/MapSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { SeriesOption, BoxLayoutOptionMixin, SeriesEncodeOptionMixin, LabelOption, SeriesTooltipOption, OptionDataItemObject, OptionDataValueNumeric, ParsedValue, SeriesOnGeoOptionMixin, StatesOptionMixin, TooltipRenderMode } from '../../util/types';\nimport { Dictionary } from 'zrender/esm/core/types';\nimport GeoModel, { GeoCommonOptionMixin, GeoItemStyleOption } from '../../coord/geo/GeoModel';\nimport List from '../../data/List';\nimport Model from '../../model/Model';\nimport Geo from '../../coord/geo/Geo';\nexport interface MapStateOption {\n    itemStyle?: GeoItemStyleOption;\n    label?: LabelOption;\n}\nexport interface MapDataItemOption extends MapStateOption, StatesOptionMixin<MapStateOption>, OptionDataItemObject<OptionDataValueNumeric> {\n    cursor?: string;\n}\nexport declare type MapValueCalculationType = 'sum' | 'average' | 'min' | 'max';\nexport interface MapSeriesOption extends SeriesOption<MapStateOption>, MapStateOption, GeoCommonOptionMixin, SeriesOnGeoOptionMixin, BoxLayoutOptionMixin, SeriesEncodeOptionMixin {\n    type?: 'map';\n    coordinateSystem?: string;\n    silent?: boolean;\n    tooltip?: SeriesTooltipOption;\n    markLine?: any;\n    markPoint?: any;\n    markArea?: any;\n    mapValueCalculation?: MapValueCalculationType;\n    showLegendSymbol?: boolean;\n    geoCoord?: Dictionary<number[]>;\n    data?: OptionDataValueNumeric[] | OptionDataValueNumeric[][] | MapDataItemOption[];\n    nameProperty: string;\n}\ndeclare class MapSeries extends SeriesModel<MapSeriesOption> {\n    static type: \"series.map\";\n    type: \"series.map\";\n    static dependencies: string[];\n    static layoutMode: \"box\";\n    coordinateSystem: Geo;\n    originalData: List;\n    mainSeries: MapSeries;\n    needsDrawMap: boolean;\n    seriesGroup: MapSeries[];\n    getInitialData(this: MapSeries, option: MapSeriesOption): List;\n    getHostGeoModel(): GeoModel;\n    getMapType(): string;\n    getRawValue(dataIndex: number): ParsedValue;\n    getRegionModel(regionName: string): Model<MapDataItemOption>;\n    formatTooltip(dataIndex: number, multipleSeries: boolean, dataType: string, renderMode: TooltipRenderMode): string;\n    getTooltipPosition: (this: MapSeries, dataIndex: number) => number[];\n    setZoom(zoom: number): void;\n    setCenter(center: number[]): void;\n    static defaultOption: MapSeriesOption;\n}\nexport default MapSeries;\n"
  },
  {
    "path": "echarts/types/src/chart/map/mapSymbolLayout.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nexport default function (ecModel: GlobalModel): void;\n"
  },
  {
    "path": "echarts/types/src/chart/map/MapView.d.ts",
    "code": "import ChartView from '../../view/Chart';\nimport MapSeries from './MapSeries';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { Payload } from '../../util/types';\ndeclare class MapView extends ChartView {\n    static type: \"map\";\n    readonly type: \"map\";\n    private _mapDraw;\n    render(mapModel: MapSeries, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    remove(): void;\n    dispose(): void;\n    private _renderSymbols;\n}\nexport default MapView;\n"
  },
  {
    "path": "echarts/types/src/chart/parallel.d.ts",
    "code": "import '../component/parallel';\nimport './parallel/ParallelSeries';\nimport './parallel/ParallelView';\n"
  },
  {
    "path": "echarts/types/src/chart/parallel/ParallelSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { SeriesOption, SeriesEncodeOptionMixin, LineStyleOption, LabelOption, SeriesTooltipOption, OptionDataValue, StatesOptionMixin } from '../../util/types';\nimport GlobalModel from '../../model/Global';\nimport List from '../../data/List';\nimport { ParallelActiveState, ParallelAxisOption } from '../../coord/parallel/AxisModel';\nimport Parallel from '../../coord/parallel/Parallel';\ndeclare type ParallelSeriesDataValue = OptionDataValue[];\nexport interface ParallelStateOption {\n    lineStyle?: LineStyleOption;\n    label?: LabelOption;\n}\nexport interface ParallelSeriesDataItemOption extends ParallelStateOption, StatesOptionMixin<ParallelStateOption> {\n    value?: ParallelSeriesDataValue[];\n}\nexport interface ParallelSeriesOption extends SeriesOption<ParallelStateOption>, ParallelStateOption, SeriesEncodeOptionMixin {\n    type?: 'parallel';\n    coordinateSystem?: string;\n    parallelIndex?: number;\n    parallelId?: string;\n    inactiveOpacity?: number;\n    activeOpacity?: number;\n    smooth?: boolean | number;\n    realtime?: boolean;\n    tooltip?: SeriesTooltipOption;\n    parallelAxisDefault?: ParallelAxisOption;\n    emphasis?: {\n        label?: LabelOption;\n        lineStyle?: LineStyleOption;\n    };\n    data?: (ParallelSeriesDataValue | ParallelSeriesDataItemOption)[];\n}\ndeclare class ParallelSeriesModel extends SeriesModel<ParallelSeriesOption> {\n    static type: string;\n    readonly type: string;\n    static dependencies: string[];\n    visualStyleAccessPath: string;\n    visualDrawType: \"stroke\";\n    coordinateSystem: Parallel;\n    getInitialData(this: ParallelSeriesModel, option: ParallelSeriesOption, ecModel: GlobalModel): List;\n    getRawIndicesByActiveState(activeState: ParallelActiveState): number[];\n    static defaultOption: ParallelSeriesOption;\n}\nexport default ParallelSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/parallel/ParallelView.d.ts",
    "code": "import ChartView from '../../view/Chart';\nimport ParallelSeriesModel from './ParallelSeries';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { StageHandlerProgressParams, Payload } from '../../util/types';\ndeclare class ParallelView extends ChartView {\n    static type: string;\n    type: string;\n    private _dataGroup;\n    private _data;\n    private _initialized;\n    init(): void;\n    render(seriesModel: ParallelSeriesModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    incrementalPrepareRender(seriesModel: ParallelSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    incrementalRender(taskParams: StageHandlerProgressParams, seriesModel: ParallelSeriesModel, ecModel: GlobalModel): void;\n    remove(): void;\n}\nexport default ParallelView;\n"
  },
  {
    "path": "echarts/types/src/chart/parallel/parallelVisual.d.ts",
    "code": "import { StageHandler } from '../../util/types';\ndeclare const parallelVisual: StageHandler;\nexport default parallelVisual;\n"
  },
  {
    "path": "echarts/types/src/chart/pictorialBar.d.ts",
    "code": "import '../coord/cartesian/Grid';\nimport './bar/PictorialBarSeries';\nimport './bar/PictorialBarView';\nimport '../component/gridSimple';\n"
  },
  {
    "path": "echarts/types/src/chart/pie.d.ts",
    "code": "import './pie/PieSeries';\nimport './pie/PieView';\n"
  },
  {
    "path": "echarts/types/src/chart/pie/labelLayout.d.ts",
    "code": "import PieSeriesModel from './PieSeries';\nexport default function (seriesModel: PieSeriesModel): void;\n"
  },
  {
    "path": "echarts/types/src/chart/pie/pieLayout.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nexport default function (seriesType: 'pie', ecModel: GlobalModel, api: ExtensionAPI): void;\n"
  },
  {
    "path": "echarts/types/src/chart/pie/PieSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { SeriesOption, CallbackDataParams, CircleLayoutOptionMixin, LabelLineOption, ItemStyleOption, LabelOption, BoxLayoutOptionMixin, OptionDataValueNumeric, SeriesEncodeOptionMixin, OptionDataItemObject, StatesOptionMixin } from '../../util/types';\nimport List from '../../data/List';\nexport interface PieStateOption {\n    itemStyle?: ItemStyleOption;\n    label?: PieLabelOption;\n    labelLine?: PieLabelLineOption;\n}\ninterface PieLabelOption extends Omit<LabelOption, 'rotate' | 'position'> {\n    rotate?: number;\n    alignTo?: 'none' | 'labelLine' | 'edge';\n    edgeDistance?: string | number;\n    bleedMargin?: number;\n    distanceToLabelLine?: number;\n    position?: LabelOption['position'] | 'outer' | 'inner' | 'center';\n}\ninterface PieLabelLineOption extends LabelLineOption {\n    maxSurfaceAngle?: number;\n}\ninterface ExtraStateOption {\n    emphasis?: {\n        scale?: boolean;\n        scaleSize?: number;\n    };\n}\nexport interface PieDataItemOption extends OptionDataItemObject<OptionDataValueNumeric>, PieStateOption, StatesOptionMixin<PieStateOption, ExtraStateOption> {\n    cursor?: string;\n}\nexport interface PieSeriesOption extends Omit<SeriesOption<PieStateOption, ExtraStateOption>, 'labelLine'>, PieStateOption, CircleLayoutOptionMixin, BoxLayoutOptionMixin, SeriesEncodeOptionMixin {\n    type: 'pie';\n    roseType?: 'radius' | 'area';\n    clockwise?: boolean;\n    startAngle?: number;\n    minAngle?: number;\n    minShowLabelAngle?: number;\n    selectedOffset?: number;\n    avoidLabelOverlap?: boolean;\n    percentPrecision?: number;\n    stillShowZeroSum?: boolean;\n    animationType?: 'expansion' | 'scale';\n    animationTypeUpdate?: 'transition' | 'expansion';\n    data?: OptionDataValueNumeric[] | OptionDataValueNumeric[][] | PieDataItemOption[];\n}\ndeclare class PieSeriesModel extends SeriesModel<PieSeriesOption> {\n    static type: \"series.pie\";\n    useColorPaletteOnData: boolean;\n    init(option: PieSeriesOption): void;\n    mergeOption(): void;\n    getInitialData(this: PieSeriesModel): List;\n    getDataParams(dataIndex: number): CallbackDataParams;\n    private _defaultLabelLine;\n    static defaultOption: Omit<PieSeriesOption, 'type'>;\n}\nexport default PieSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/pie/PieView.d.ts",
    "code": "import ChartView from '../../view/Chart';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { Payload } from '../../util/types';\nimport PieSeriesModel from './PieSeries';\ndeclare class PieView extends ChartView {\n    static type: string;\n    ignoreLabelLineUpdate: boolean;\n    private _sectorGroup;\n    private _data;\n    init(): void;\n    render(seriesModel: PieSeriesModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    dispose(): void;\n    containPoint(point: number[], seriesModel: PieSeriesModel): boolean;\n}\nexport default PieView;\n"
  },
  {
    "path": "echarts/types/src/chart/radar.d.ts",
    "code": "import '../component/radar';\nimport './radar/RadarSeries';\nimport './radar/RadarView';\n"
  },
  {
    "path": "echarts/types/src/chart/radar/backwardCompat.d.ts",
    "code": "export default function (option: any): void;\n"
  },
  {
    "path": "echarts/types/src/chart/radar/radarLayout.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nexport default function (ecModel: GlobalModel): void;\n"
  },
  {
    "path": "echarts/types/src/chart/radar/RadarSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { SeriesOption, LineStyleOption, LabelOption, SymbolOptionMixin, ItemStyleOption, AreaStyleOption, OptionDataValue, StatesOptionMixin, OptionDataItemObject, TooltipRenderMode, TooltipOrderMode } from '../../util/types';\nimport GlobalModel from '../../model/Global';\nimport List from '../../data/List';\nimport Radar from '../../coord/radar/Radar';\ndeclare type RadarSeriesDataValue = OptionDataValue[];\nexport interface RadarSeriesStateOption {\n    lineStyle?: LineStyleOption;\n    areaStyle?: AreaStyleOption;\n    label?: LabelOption;\n    itemStyle?: ItemStyleOption;\n}\nexport interface RadarSeriesDataItemOption extends SymbolOptionMixin, RadarSeriesStateOption, StatesOptionMixin<RadarSeriesStateOption>, OptionDataItemObject<RadarSeriesDataValue> {\n}\nexport interface RadarSeriesOption extends SeriesOption<RadarSeriesStateOption>, RadarSeriesStateOption, SymbolOptionMixin {\n    type?: 'radar';\n    coordinateSystem: 'radar';\n    radarIndex?: number;\n    radarId?: string;\n    data?: RadarSeriesStateOption[];\n}\ndeclare class RadarSeriesModel extends SeriesModel<RadarSeriesOption> {\n    static readonly type = \"series.radar\";\n    readonly type = \"series.radar\";\n    static dependencies: string[];\n    coordinateSystem: Radar;\n    useColorPaletteOnData: boolean;\n    hasSymbolVisual: boolean;\n    init(option: RadarSeriesOption): void;\n    getInitialData(option: RadarSeriesOption, ecModel: GlobalModel): List;\n    formatTooltip(dataIndex: number, multipleSeries?: boolean, dataType?: string, renderMode?: TooltipRenderMode, order?: TooltipOrderMode): string;\n    getTooltipPosition(dataIndex: number): number[];\n    static defaultOption: RadarSeriesOption;\n}\nexport default RadarSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/radar/RadarView.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/chart/sankey.d.ts",
    "code": "import './sankey/SankeySeries';\nimport './sankey/SankeyView';\nimport './sankey/sankeyAction';\n"
  },
  {
    "path": "echarts/types/src/chart/sankey/sankeyAction.d.ts",
    "code": "import '../helper/focusNodeAdjacencyAction';\n"
  },
  {
    "path": "echarts/types/src/chart/sankey/sankeyLayout.d.ts",
    "code": "import ExtensionAPI from '../../ExtensionAPI';\nimport GlobalModel from '../../model/Global';\nexport default function (ecModel: GlobalModel, api: ExtensionAPI): void;\n"
  },
  {
    "path": "echarts/types/src/chart/sankey/SankeySeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport Model from '../../model/Model';\nimport { SeriesOption, BoxLayoutOptionMixin, OptionDataValue, LabelOption, ItemStyleOption, LineStyleOption, LayoutOrient, ColorString, StatesOptionMixin, OptionDataItemObject, GraphEdgeItemObject, OptionDataValueNumeric, TooltipRenderMode } from '../../util/types';\nimport GlobalModel from '../../model/Global';\nimport List from '../../data/List';\nimport { LayoutRect } from '../../util/layout';\ndeclare type FocusNodeAdjacency = boolean | 'inEdges' | 'outEdges' | 'allEdges';\nexport interface SankeyNodeStateOption {\n    label?: LabelOption;\n    itemStyle?: ItemStyleOption;\n}\nexport interface SankeyEdgeStateOption {\n    lineStyle?: SankeyEdgeStyleOption;\n}\ninterface SankeyBothStateOption extends SankeyNodeStateOption, SankeyEdgeStateOption {\n}\ninterface SankeyEdgeStyleOption extends LineStyleOption {\n    curveness?: number;\n}\ninterface ExtraStateOption {\n    emphasis?: {\n        focus?: 'adjacency';\n    };\n}\nexport interface SankeyNodeItemOption extends SankeyNodeStateOption, StatesOptionMixin<SankeyNodeStateOption, ExtraStateOption>, OptionDataItemObject<OptionDataValue> {\n    id?: string;\n    localX?: number;\n    localY?: number;\n    depth?: number;\n    draggable?: boolean;\n    focusNodeAdjacency?: FocusNodeAdjacency;\n}\nexport interface SankeyEdgeItemOption extends SankeyEdgeStateOption, StatesOptionMixin<SankeyEdgeStateOption, ExtraStateOption>, GraphEdgeItemObject<OptionDataValueNumeric> {\n    focusNodeAdjacency?: FocusNodeAdjacency;\n}\nexport interface SankeyLevelOption {\n    depth: number;\n}\nexport interface SankeySeriesOption extends SeriesOption<SankeyBothStateOption, ExtraStateOption>, SankeyBothStateOption, BoxLayoutOptionMixin {\n    type?: 'sankey';\n    color?: ColorString[];\n    coordinateSystem?: 'view';\n    orient?: LayoutOrient;\n    nodeWidth?: number;\n    nodeGap?: number;\n    draggable?: boolean;\n    focusNodeAdjacency?: FocusNodeAdjacency;\n    layoutIterations?: number;\n    nodeAlign?: 'justify' | 'left' | 'right';\n    data?: SankeyNodeItemOption[];\n    nodes?: SankeyNodeItemOption[];\n    edges?: SankeyEdgeItemOption[];\n    links?: SankeyEdgeItemOption[];\n    levels?: SankeyLevelOption[];\n}\ndeclare class SankeySeriesModel extends SeriesModel<SankeySeriesOption> {\n    static readonly type = \"series.sankey\";\n    readonly type = \"series.sankey\";\n    levelModels: Model<SankeyLevelOption>[];\n    layoutInfo: LayoutRect;\n    getInitialData(option: SankeySeriesOption, ecModel: GlobalModel): List<Model<any>, import(\"../../data/List\").DefaultDataVisual>;\n    setNodePosition(dataIndex: number, localPosition: number[]): void;\n    getGraph(): import(\"../../data/Graph\").default;\n    getEdgeData(): List<Model<any>, import(\"../../data/List\").DefaultDataVisual>;\n    formatTooltip(dataIndex: number, multipleSeries: boolean, dataType: 'node' | 'edge', renderMode: TooltipRenderMode): string | {\n        html: string;\n        markers: import(\"zrender/esm/core/types\").Dictionary<string>;\n    };\n    optionUpdated(): void;\n    getDataParams(dataIndex: number, dataType: 'node' | 'edge'): import(\"../../util/types\").CallbackDataParams;\n    static defaultOption: SankeySeriesOption;\n}\nexport default SankeySeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/sankey/SankeyView.d.ts",
    "code": "import SankeySeriesModel from './SankeySeries';\nimport ChartView from '../../view/Chart';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\ndeclare class SankeyView extends ChartView {\n    static readonly type = \"sankey\";\n    readonly type = \"sankey\";\n    private _model;\n    private _focusAdjacencyDisabled;\n    private _data;\n    render(seriesModel: SankeySeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    dispose(): void;\n}\nexport default SankeyView;\n"
  },
  {
    "path": "echarts/types/src/chart/sankey/sankeyVisual.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nexport default function (ecModel: GlobalModel): void;\n"
  },
  {
    "path": "echarts/types/src/chart/scatter.d.ts",
    "code": "import './scatter/ScatterSeries';\nimport './scatter/ScatterView';\nimport '../component/gridSimple';\n"
  },
  {
    "path": "echarts/types/src/chart/scatter/ScatterSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { SeriesOption, SeriesOnCartesianOptionMixin, SeriesOnPolarOptionMixin, SeriesOnCalendarOptionMixin, SeriesOnGeoOptionMixin, SeriesOnSingleOptionMixin, OptionDataValue, ItemStyleOption, LabelOption, SeriesLargeOptionMixin, SeriesStackOptionMixin, SymbolOptionMixin, StatesOptionMixin, OptionDataItemObject } from '../../util/types';\nimport GlobalModel from '../../model/Global';\nimport List from '../../data/List';\nimport { BrushCommonSelectorsForSeries } from '../../component/brush/selector';\ninterface ScatterStateOption {\n    itemStyle?: ItemStyleOption;\n    label?: LabelOption;\n}\ninterface ExtraStateOption {\n    emphasis?: {\n        scale?: boolean;\n    };\n}\nexport interface ScatterDataItemOption extends SymbolOptionMixin, ScatterStateOption, StatesOptionMixin<ScatterStateOption, ExtraStateOption>, OptionDataItemObject<OptionDataValue> {\n}\nexport interface ScatterSeriesOption extends SeriesOption<ScatterStateOption, ExtraStateOption>, ScatterStateOption, SeriesOnCartesianOptionMixin, SeriesOnPolarOptionMixin, SeriesOnCalendarOptionMixin, SeriesOnGeoOptionMixin, SeriesOnSingleOptionMixin, SeriesLargeOptionMixin, SeriesStackOptionMixin, SymbolOptionMixin {\n    type?: 'scatter';\n    coordinateSystem?: string;\n    cursor?: string;\n    clip?: boolean;\n    data?: (ScatterDataItemOption | OptionDataValue | OptionDataValue[])[] | ArrayLike<number>;\n}\ndeclare class ScatterSeriesModel extends SeriesModel<ScatterSeriesOption> {\n    static readonly type = \"series.scatter\";\n    type: string;\n    static readonly dependencies: string[];\n    hasSymbolVisual: boolean;\n    getInitialData(option: ScatterSeriesOption, ecModel: GlobalModel): List;\n    getProgressive(): number | false;\n    getProgressiveThreshold(): number;\n    brushSelector(dataIndex: number, data: List, selectors: BrushCommonSelectorsForSeries): boolean;\n    static defaultOption: ScatterSeriesOption;\n}\nexport default ScatterSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/scatter/ScatterView.d.ts",
    "code": "import SymbolDraw from '../helper/SymbolDraw';\nimport LargeSymbolDraw from '../helper/LargeSymbolDraw';\nimport ChartView from '../../view/Chart';\nimport ScatterSeriesModel from './ScatterSeries';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport List from '../../data/List';\nimport { TaskProgressParams } from '../../stream/task';\ndeclare class ScatterView extends ChartView {\n    static readonly type = \"scatter\";\n    type: string;\n    _finished: boolean;\n    _isLargeDraw: boolean;\n    _symbolDraw: SymbolDraw | LargeSymbolDraw;\n    render(seriesModel: ScatterSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    incrementalPrepareRender(seriesModel: ScatterSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    incrementalRender(taskParams: TaskProgressParams, seriesModel: ScatterSeriesModel, ecModel: GlobalModel): void;\n    updateTransform(seriesModel: ScatterSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void | {\n        update: true;\n    };\n    _getClipShape(seriesModel: ScatterSeriesModel): import(\"../../coord/CoordinateSystem\").CoordinateSystemClipArea;\n    _updateSymbolDraw(data: List, seriesModel: ScatterSeriesModel): SymbolDraw | LargeSymbolDraw;\n    remove(ecModel: GlobalModel, api: ExtensionAPI): void;\n    dispose(): void;\n}\nexport default ScatterView;\n"
  },
  {
    "path": "echarts/types/src/chart/sunburst.d.ts",
    "code": "import './sunburst/SunburstSeries';\nimport './sunburst/SunburstView';\nimport './sunburst/sunburstAction';\n"
  },
  {
    "path": "echarts/types/src/chart/sunburst/sunburstAction.d.ts",
    "code": "export declare const ROOT_TO_NODE_ACTION = \"sunburstRootToNode\";\n"
  },
  {
    "path": "echarts/types/src/chart/sunburst/sunburstLayout.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nexport default function (seriesType: 'sunburst', ecModel: GlobalModel, api: ExtensionAPI): void;\n"
  },
  {
    "path": "echarts/types/src/chart/sunburst/SunburstPiece.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport { TreeNode } from '../../data/Tree';\nimport SunburstSeriesModel from './SunburstSeries';\nimport GlobalModel from '../../model/Global';\ndeclare class SunburstPiece extends graphic.Sector {\n    node: TreeNode;\n    private _seriesModel;\n    private _ecModel;\n    constructor(node: TreeNode, seriesModel: SunburstSeriesModel, ecModel: GlobalModel);\n    updateData(firstCreate: boolean, node: TreeNode, seriesModel?: SunburstSeriesModel, ecModel?: GlobalModel): void;\n    _updateLabel(seriesModel: SunburstSeriesModel): void;\n}\nexport default SunburstPiece;\n"
  },
  {
    "path": "echarts/types/src/chart/sunburst/SunburstSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { TreeNode } from '../../data/Tree';\nimport { SeriesOption, CircleLayoutOptionMixin, LabelOption, ItemStyleOption, OptionDataValue, CallbackDataParams, StatesOptionMixin, OptionDataItemObject } from '../../util/types';\nimport GlobalModel from '../../model/Global';\ninterface SunburstLabelOption extends Omit<LabelOption, 'rotate' | 'position'> {\n    rotate?: 'radial' | 'tangential' | number;\n    minAngle?: number;\n    silent?: boolean;\n    position?: LabelOption['position'] | 'outside';\n}\ninterface SunburstDataParams extends CallbackDataParams {\n    treePathInfo: {\n        name: string;\n        dataIndex: number;\n        value: SunburstSeriesNodeItemOption['value'];\n    }[];\n}\ninterface ExtraStateOption {\n    emphasis?: {\n        focus?: 'descendant' | 'ancestor';\n    };\n}\nexport interface SunburstStateOption {\n    itemStyle?: ItemStyleOption;\n    label?: SunburstLabelOption;\n}\nexport interface SunburstSeriesNodeItemOption extends SunburstStateOption, StatesOptionMixin<SunburstStateOption, ExtraStateOption>, OptionDataItemObject<OptionDataValue> {\n    nodeClick?: 'rootToNode' | 'link';\n    link?: string;\n    target?: string;\n    children?: SunburstSeriesNodeItemOption[];\n    collapsed?: boolean;\n    cursor?: string;\n}\nexport interface SunburstSeriesLevelOption extends SunburstStateOption, StatesOptionMixin<SunburstStateOption> {\n    highlight?: {\n        itemStyle?: ItemStyleOption;\n        label?: SunburstLabelOption;\n    };\n}\nexport interface SunburstSeriesOption extends SeriesOption<SunburstStateOption, ExtraStateOption>, SunburstStateOption, CircleLayoutOptionMixin {\n    type?: 'sunburst';\n    clockwise?: boolean;\n    startAngle?: number;\n    minAngle?: number;\n    stillShowZeroSum?: boolean;\n    nodeClick?: 'rootToNode' | 'link';\n    renderLabelForZeroData?: boolean;\n    levels?: SunburstSeriesLevelOption[];\n    animationType?: 'expansion' | 'scale';\n    sort?: 'desc' | 'asc' | ((a: TreeNode, b: TreeNode) => number);\n}\ninterface SunburstSeriesModel {\n    getFormattedLabel(dataIndex: number, state?: 'emphasis' | 'normal' | 'highlight' | 'blur' | 'select'): string;\n}\ndeclare class SunburstSeriesModel extends SeriesModel<SunburstSeriesOption> {\n    static readonly type = \"series.sunburst\";\n    readonly type = \"series.sunburst\";\n    ignoreStyleOnData: boolean;\n    private _viewRoot;\n    getInitialData(option: SunburstSeriesOption, ecModel: GlobalModel): import(\"../../data/List\").default<import(\"../../model/Model\").default<any>, import(\"../../data/List\").DefaultDataVisual>;\n    optionUpdated(): void;\n    getDataParams(dataIndex: number): SunburstDataParams;\n    static defaultOption: SunburstSeriesOption;\n    getViewRoot(): TreeNode;\n    resetViewRoot(viewRoot?: TreeNode): void;\n}\nexport default SunburstSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/sunburst/SunburstView.d.ts",
    "code": "import ChartView from '../../view/Chart';\nimport SunburstPiece from './SunburstPiece';\nimport SunburstSeriesModel from './SunburstSeries';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { TreeNode } from '../../data/Tree';\ninterface DrawTreeNode extends TreeNode {\n    parentNode: DrawTreeNode;\n    piece: SunburstPiece;\n    children: DrawTreeNode[];\n}\ndeclare class SunburstView extends ChartView {\n    static readonly type = \"sunburst\";\n    readonly type = \"sunburst\";\n    seriesModel: SunburstSeriesModel;\n    api: ExtensionAPI;\n    ecModel: GlobalModel;\n    virtualPiece: SunburstPiece;\n    private _oldChildren;\n    render(seriesModel: SunburstSeriesModel, ecModel: GlobalModel, api: ExtensionAPI, payload: any): void;\n    _initEvents(): void;\n    _rootToNode(node: DrawTreeNode): void;\n    containPoint(point: number[], seriesModel: SunburstSeriesModel): boolean;\n}\nexport default SunburstView;\n"
  },
  {
    "path": "echarts/types/src/chart/sunburst/sunburstVisual.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nexport default function (ecModel: GlobalModel): void;\n"
  },
  {
    "path": "echarts/types/src/chart/themeRiver.d.ts",
    "code": "import '../component/singleAxis';\nimport './themeRiver/ThemeRiverSeries';\nimport './themeRiver/ThemeRiverView';\n"
  },
  {
    "path": "echarts/types/src/chart/themeRiver/themeRiverLayout.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { ThemeRiverSeriesOption } from './ThemeRiverSeries';\nimport { RectLike } from 'zrender/esm/core/BoundingRect';\nexport interface ThemeRiverLayoutInfo {\n    rect: RectLike;\n    boundaryGap: ThemeRiverSeriesOption['boundaryGap'];\n}\nexport default function (ecModel: GlobalModel, api: ExtensionAPI): void;\n"
  },
  {
    "path": "echarts/types/src/chart/themeRiver/ThemeRiverSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport List from '../../data/List';\nimport * as zrUtil from 'zrender/esm/core/util';\nimport { SeriesOption, SeriesOnSingleOptionMixin, LabelOption, OptionDataValueDate, OptionDataValueNumeric, ItemStyleOption, BoxLayoutOptionMixin, ZRColor, TooltipRenderMode } from '../../util/types';\nimport SingleAxis from '../../coord/single/SingleAxis';\nimport GlobalModel from '../../model/Global';\nimport Single from '../../coord/single/Single';\ninterface ThemeRiverSeriesLabelOption extends LabelOption {\n    margin?: number;\n}\nexport interface ThemeRiverStateOption {\n    label?: ThemeRiverSeriesLabelOption;\n    itemStyle?: ItemStyleOption;\n}\nexport interface ThemeRiverSeriesOption extends SeriesOption<ThemeRiverStateOption>, ThemeRiverStateOption, SeriesOnSingleOptionMixin, BoxLayoutOptionMixin {\n    type?: 'themeRiver';\n    color?: ZRColor[];\n    coordinateSystem: 'singleAxis';\n    boundaryGap: (string | number)[];\n    data?: [OptionDataValueDate, OptionDataValueNumeric, string][];\n}\ndeclare class ThemeRiverSeriesModel extends SeriesModel<ThemeRiverSeriesOption> {\n    static readonly type = \"series.themeRiver\";\n    readonly type = \"series.themeRiver\";\n    static readonly dependencies: string[];\n    nameMap: zrUtil.HashMap<number, string>;\n    coordinateSystem: Single;\n    useColorPaletteOnData: boolean;\n    init(option: ThemeRiverSeriesOption): void;\n    fixData(data: ThemeRiverSeriesOption['data']): [string | number | Date, OptionDataValueNumeric, string][];\n    getInitialData(option: ThemeRiverSeriesOption, ecModel: GlobalModel): List;\n    getLayerSeries(): {\n        name: string;\n        indices: number[];\n    }[];\n    getAxisTooltipData(dim: string | string[], value: number, baseAxis: SingleAxis): {\n        dataIndices: number[];\n        nestestValue: number;\n    };\n    formatTooltip(dataIndex: number, multipleSeries: boolean, dataType: string, renderMode: TooltipRenderMode): string;\n    static defaultOption: ThemeRiverSeriesOption;\n}\nexport default ThemeRiverSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/themeRiver/ThemeRiverView.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/chart/tree.d.ts",
    "code": "import './tree/TreeSeries';\nimport './tree/TreeView';\nimport './tree/treeAction';\n"
  },
  {
    "path": "echarts/types/src/chart/tree/layoutHelper.d.ts",
    "code": "import * as layout from '../../util/layout';\nimport { TreeNode } from '../../data/Tree';\nimport TreeSeriesModel from './TreeSeries';\nimport ExtensionAPI from '../../ExtensionAPI';\ninterface HierNode {\n    defaultAncestor: TreeLayoutNode;\n    ancestor: TreeLayoutNode;\n    prelim: number;\n    modifier: number;\n    change: number;\n    shift: number;\n    i: number;\n    thread: TreeLayoutNode;\n}\nexport interface TreeLayoutNode extends TreeNode {\n    parentNode: TreeLayoutNode;\n    hierNode: HierNode;\n    children: TreeLayoutNode[];\n}\nexport declare function init(inRoot: TreeNode): void;\nexport declare function firstWalk(node: TreeLayoutNode, separation: SeparationFunc): void;\nexport declare function secondWalk(node: TreeLayoutNode): void;\nexport declare function separation(cb?: SeparationFunc): SeparationFunc;\nexport declare function radialCoordinate(rad: number, r: number): {\n    x: number;\n    y: number;\n};\nexport declare function getViewRect(seriesModel: TreeSeriesModel, api: ExtensionAPI): layout.LayoutRect;\ninterface SeparationFunc {\n    (node1: TreeLayoutNode, node2: TreeLayoutNode): number;\n}\nexport {};\n"
  },
  {
    "path": "echarts/types/src/chart/tree/traversalHelper.d.ts",
    "code": "import { TreeNode } from '../../data/Tree';\ndeclare function eachAfter<T>(root: TreeNode, callback: (node: TreeNode, separation: T) => void, separation: T): void;\ndeclare function eachBefore(root: TreeNode, callback: (node: TreeNode) => void): void;\nexport { eachAfter, eachBefore };\n"
  },
  {
    "path": "echarts/types/src/chart/tree/treeAction.d.ts",
    "code": "import { Payload } from '../../util/types';\nexport interface TreeExpandAndCollapsePayload extends Payload {\n    dataIndex: number;\n}\n"
  },
  {
    "path": "echarts/types/src/chart/tree/treeLayout.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nexport default function (ecModel: GlobalModel, api: ExtensionAPI): void;\n"
  },
  {
    "path": "echarts/types/src/chart/tree/TreeSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { SeriesOption, SymbolOptionMixin, BoxLayoutOptionMixin, RoamOptionMixin, LineStyleOption, ItemStyleOption, LabelOption, OptionDataValue, StatesOptionMixin, OptionDataItemObject, TooltipRenderMode } from '../../util/types';\nimport List from '../../data/List';\nimport View from '../../coord/View';\nimport { LayoutRect } from '../../util/layout';\ninterface CurveLineStyleOption extends LineStyleOption {\n    curveness?: number;\n}\nexport interface TreeSeriesStateOption {\n    itemStyle?: ItemStyleOption;\n    lineStyle?: CurveLineStyleOption;\n    label?: LabelOption;\n}\ninterface ExtraStateOption {\n    emphasis?: {\n        focus?: 'ancestor' | 'descendant';\n        scale?: boolean;\n    };\n}\nexport interface TreeSeriesNodeItemOption extends SymbolOptionMixin, TreeSeriesStateOption, StatesOptionMixin<TreeSeriesStateOption, ExtraStateOption>, OptionDataItemObject<OptionDataValue> {\n    children?: TreeSeriesNodeItemOption[];\n    collapsed?: boolean;\n    link?: string;\n    target?: string;\n}\nexport interface TreeSeriesLeavesOption extends TreeSeriesStateOption, StatesOptionMixin<TreeSeriesStateOption> {\n}\nexport interface TreeSeriesOption extends SeriesOption<TreeSeriesStateOption, ExtraStateOption>, TreeSeriesStateOption, SymbolOptionMixin, BoxLayoutOptionMixin, RoamOptionMixin {\n    type?: 'tree';\n    layout?: 'orthogonal' | 'radial';\n    edgeShape?: 'polyline' | 'curve';\n    edgeForkPosition?: string | number;\n    nodeScaleRatio?: number;\n    orient?: 'LR' | 'TB' | 'RL' | 'BT' | 'horizontal' | 'vertical';\n    expandAndCollapse?: boolean;\n    initialTreeDepth?: number;\n    leaves?: TreeSeriesLeavesOption;\n    data?: TreeSeriesNodeItemOption[];\n}\ndeclare class TreeSeriesModel extends SeriesModel<TreeSeriesOption> {\n    static readonly type = \"series.tree\";\n    static readonly layoutMode = \"box\";\n    coordinateSystem: View;\n    layoutInfo: LayoutRect;\n    hasSymbolVisual: boolean;\n    ignoreStyleOnData: boolean;\n    getInitialData(option: TreeSeriesOption): List;\n    getOrient(): \"BT\" | \"LR\" | \"TB\" | \"RL\";\n    setZoom(zoom: number): void;\n    setCenter(center: number[]): void;\n    formatTooltip(dataIndex: number, multipleSeries: boolean, dataType: string, renderMode: TooltipRenderMode): string;\n    static defaultOption: TreeSeriesOption;\n}\nexport default TreeSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/tree/TreeView.d.ts",
    "code": "import ChartView from '../../view/Chart';\nimport TreeSeriesModel from './TreeSeries';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\ndeclare class TreeView extends ChartView {\n    static readonly type = \"tree\";\n    readonly type = \"tree\";\n    private _mainGroup;\n    private _controller;\n    private _controllerHost;\n    private _data;\n    private _nodeScaleRatio;\n    private _min;\n    private _max;\n    init(ecModel: GlobalModel, api: ExtensionAPI): void;\n    render(seriesModel: TreeSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    _updateViewCoordSys(seriesModel: TreeSeriesModel): void;\n    _updateController(seriesModel: TreeSeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    _updateNodeAndLinkScale(seriesModel: TreeSeriesModel): void;\n    _getNodeGlobalScale(seriesModel: TreeSeriesModel): number;\n    dispose(): void;\n    remove(): void;\n}\nexport default TreeView;\n"
  },
  {
    "path": "echarts/types/src/chart/tree/treeVisual.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nexport default function (ecModel: GlobalModel): void;\n"
  },
  {
    "path": "echarts/types/src/chart/treemap.d.ts",
    "code": "import './treemap/TreemapSeries';\nimport './treemap/TreemapView';\nimport './treemap/treemapAction';\n"
  },
  {
    "path": "echarts/types/src/chart/treemap/Breadcrumb.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport TreemapSeriesModel, { TreemapSeriesOption } from './TreemapSeries';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { TreeNode } from '../../data/Tree';\nimport { ZRElementEvent, BoxLayoutOptionMixin } from '../../util/types';\nimport Model from '../../model/Model';\ninterface OnSelectCallback {\n    (node: TreeNode, e: ZRElementEvent): void;\n}\ninterface LayoutParam {\n    pos: BoxLayoutOptionMixin;\n    box: {\n        width: number;\n        height: number;\n    };\n    emptyItemWidth: number;\n    totalWidth: number;\n    renderList: {\n        node: TreeNode;\n        text: string;\n        width: number;\n    }[];\n}\ndeclare type BreadcrumbItemStyleModel = Model<TreemapSeriesOption['breadcrumb']['itemStyle']>;\ndeclare type BreadcrumbTextStyleModel = Model<TreemapSeriesOption['breadcrumb']['itemStyle']['textStyle']>;\ndeclare class Breadcrumb {\n    group: graphic.Group;\n    constructor(containerGroup: graphic.Group);\n    render(seriesModel: TreemapSeriesModel, api: ExtensionAPI, targetNode: TreeNode, onSelect: OnSelectCallback): void;\n    _prepare(targetNode: TreeNode, layoutParam: LayoutParam, textStyleModel: BreadcrumbTextStyleModel): void;\n    _renderContent(seriesModel: TreemapSeriesModel, layoutParam: LayoutParam, normalStyleModel: BreadcrumbItemStyleModel, textStyleModel: BreadcrumbTextStyleModel, onSelect: OnSelectCallback): void;\n    remove(): void;\n}\nexport default Breadcrumb;\n"
  },
  {
    "path": "echarts/types/src/chart/treemap/treemapAction.d.ts",
    "code": "import { Payload } from '../../util/types';\nimport { TreeNode } from '../../data/Tree';\nimport { RectLike } from 'zrender/esm/core/BoundingRect';\nexport interface TreemapZoomToNodePayload extends Payload {\n    type: 'treemapZoomToNode';\n}\nexport interface TreemapRenderPayload extends Payload {\n    type: 'treemapRender';\n    rootRect?: RectLike;\n}\nexport interface TreemapMovePayload extends Payload {\n    type: 'treemapMove';\n    rootRect?: RectLike;\n}\nexport interface TreemapRootToNodePayload extends Payload {\n    type: 'treemapRootToNode';\n    targetNode?: TreeNode | string;\n    targetNodeId?: string;\n    direction?: 'rollUp' | 'drillDown';\n}\n"
  },
  {
    "path": "echarts/types/src/chart/treemap/treemapLayout.d.ts",
    "code": "import { RectLike } from 'zrender/esm/core/BoundingRect';\nimport TreemapSeriesModel from './TreemapSeries';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { TreeNode } from '../../data/Tree';\nimport { TreemapRenderPayload, TreemapMovePayload, TreemapZoomToNodePayload } from './treemapAction';\nexport interface TreemapLayoutNode extends TreeNode {\n    parentNode: TreemapLayoutNode;\n    children: TreemapLayoutNode[];\n    viewChildren: TreemapLayoutNode[];\n}\nexport interface TreemapItemLayout extends RectLike {\n    area: number;\n    isLeafRoot: boolean;\n    dataExtent: [number, number];\n    borderWidth: number;\n    upperHeight: number;\n    upperLabelHeight: number;\n    isInView: boolean;\n    invisible: boolean;\n    isAboveViewRoot: boolean;\n}\ndeclare const _default: {\n    seriesType: string;\n    reset: (seriesModel: TreemapSeriesModel, ecModel: GlobalModel, api: ExtensionAPI, payload?: TreemapZoomToNodePayload | TreemapRenderPayload | TreemapMovePayload) => void;\n};\nexport default _default;\n"
  },
  {
    "path": "echarts/types/src/chart/treemap/TreemapSeries.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport { TreeNode } from '../../data/Tree';\nimport Model from '../../model/Model';\nimport { SeriesOption, BoxLayoutOptionMixin, ItemStyleOption, LabelOption, RoamOptionMixin, TooltipRenderMode, CallbackDataParams, ColorString, StatesOptionMixin } from '../../util/types';\nimport GlobalModel from '../../model/Global';\nimport { LayoutRect } from '../../util/layout';\nimport List from '../../data/List';\ndeclare type TreemapSeriesDataValue = number | number[];\ninterface BreadcrumbItemStyleOption extends ItemStyleOption {\n    textStyle?: LabelOption;\n}\ninterface TreemapSeriesLabelOption extends LabelOption {\n    ellipsis?: boolean;\n    formatter?: string | ((params: CallbackDataParams) => string);\n}\ninterface TreemapSeriesItemStyleOption extends ItemStyleOption {\n    borderRadius?: number | number[];\n    colorAlpha?: number;\n    colorSaturation?: number;\n    borderColorSaturation?: number;\n    gapWidth?: number;\n}\ninterface TreePathInfo {\n    name: string;\n    dataIndex: number;\n    value: TreemapSeriesDataValue;\n}\ninterface TreemapSeriesCallbackDataParams extends CallbackDataParams {\n    treePathInfo?: TreePathInfo[];\n}\ninterface ExtraStateOption {\n    emphasis?: {\n        focus?: 'descendant' | 'ancestor';\n    };\n}\nexport interface TreemapStateOption {\n    itemStyle?: TreemapSeriesItemStyleOption;\n    label?: TreemapSeriesLabelOption;\n    upperLabel?: TreemapSeriesLabelOption;\n}\nexport interface TreemapSeriesVisualOption {\n    visualDimension?: number | string;\n    colorMappingBy?: 'value' | 'index' | 'id';\n    visualMin?: number;\n    visualMax?: number;\n    colorAlpha?: number[] | 'none';\n    colorSaturation?: number[] | 'none';\n    visibleMin?: number;\n    childrenVisibleMin?: number;\n}\nexport interface TreemapSeriesLevelOption extends TreemapSeriesVisualOption, TreemapStateOption, StatesOptionMixin<TreemapStateOption, ExtraStateOption> {\n    color?: ColorString[] | 'none';\n}\nexport interface TreemapSeriesNodeItemOption extends TreemapSeriesVisualOption, TreemapStateOption, StatesOptionMixin<TreemapStateOption, ExtraStateOption> {\n    id?: string;\n    name?: string;\n    value?: TreemapSeriesDataValue;\n    children?: TreemapSeriesNodeItemOption[];\n    color?: ColorString[] | 'none';\n}\nexport interface TreemapSeriesOption extends SeriesOption<TreemapStateOption, ExtraStateOption>, TreemapStateOption, BoxLayoutOptionMixin, RoamOptionMixin, TreemapSeriesVisualOption {\n    type?: 'treemap';\n    size?: (number | string)[];\n    sort?: boolean | 'asc' | 'desc';\n    clipWindow?: 'origin' | 'fullscreen';\n    squareRatio: number;\n    leafDepth: number;\n    drillDownIcon?: string;\n    zoomToNodeRatio?: number;\n    nodeClick?: 'zoomToNode' | 'link';\n    breadcrumb?: BoxLayoutOptionMixin & {\n        show?: boolean;\n        height?: number;\n        emptyItemWidth: number;\n        itemStyle?: BreadcrumbItemStyleOption;\n        emphasis?: {\n            itemStyle?: BreadcrumbItemStyleOption;\n        };\n    };\n    levels?: TreemapSeriesLevelOption[];\n    data?: TreemapSeriesNodeItemOption[];\n}\ndeclare class TreemapSeriesModel extends SeriesModel<TreemapSeriesOption> {\n    static type: string;\n    type: string;\n    static layoutMode: \"box\";\n    preventUsingHoverLayer: boolean;\n    layoutInfo: LayoutRect;\n    private _viewRoot;\n    private _idIndexMap;\n    private _idIndexMapCount;\n    static defaultOption: TreemapSeriesOption;\n    getInitialData(option: TreemapSeriesOption, ecModel: GlobalModel): List<Model<any>, import(\"../../data/List\").DefaultDataVisual>;\n    optionUpdated(): void;\n    formatTooltip(dataIndex: number, multipleSeries: boolean, dataType: string, renderMode: TooltipRenderMode): string;\n    getDataParams(dataIndex: number): TreemapSeriesCallbackDataParams;\n    setLayoutInfo(layoutInfo: LayoutRect): void;\n    mapIdToIndex(id: string): number;\n    getViewRoot(): TreeNode;\n    resetViewRoot(viewRoot?: TreeNode): void;\n}\nexport default TreemapSeriesModel;\n"
  },
  {
    "path": "echarts/types/src/chart/treemap/TreemapView.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/chart/treemap/treemapVisual.d.ts",
    "code": "import TreemapSeriesModel from './TreemapSeries';\ndeclare const _default: {\n    seriesType: string;\n    reset(seriesModel: TreemapSeriesModel): void;\n};\nexport default _default;\n"
  },
  {
    "path": "echarts/types/src/component/angleAxis.d.ts",
    "code": "import '../coord/polar/polarCreator';\nimport './axis/AngleAxisView';\n"
  },
  {
    "path": "echarts/types/src/component/axis.d.ts",
    "code": "import '../coord/cartesian/AxisModel';\nimport './axis/CartesianAxisView';\n"
  },
  {
    "path": "echarts/types/src/component/axis/AngleAxisView.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/axis/AxisBuilder.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport { AxisBaseModel } from '../../coord/AxisBaseModel';\ndeclare type AxisIndexKey = 'xAxisIndex' | 'yAxisIndex' | 'radiusAxisIndex' | 'angleAxisIndex' | 'singleAxisIndex';\ndeclare type AxisEventData = {\n    componentType: string;\n    componentIndex: number;\n    targetType: 'axisName' | 'axisLabel';\n    name?: string;\n    value?: string | number;\n} & {\n    [key in AxisIndexKey]?: number;\n};\nexport interface AxisBuilderCfg {\n    position?: number[];\n    rotation?: number;\n    nameDirection?: number;\n    tickDirection?: number;\n    labelDirection?: number;\n    labelOffset?: number;\n    axisLabelShow?: boolean;\n    axisName?: string;\n    axisNameAvailableWidth?: number;\n    labelRotate?: number;\n    strokeContainThreshold?: number;\n    nameTruncateMaxWidth?: number;\n    silent?: boolean;\n    handleAutoShown?(elementType: 'axisLine' | 'axisTick'): boolean;\n}\ndeclare class AxisBuilder {\n    axisModel: AxisBaseModel;\n    opt: AxisBuilderCfg;\n    readonly group: graphic.Group;\n    private _transformGroup;\n    constructor(axisModel: AxisBaseModel, opt?: AxisBuilderCfg);\n    hasBuilder(name: keyof typeof builders): boolean;\n    add(name: keyof typeof builders): void;\n    getGroup(): graphic.Group;\n    static innerTextLayout(axisRotation: number, textRotation: number, direction: number): {\n        rotation: number;\n        textAlign: import(\"zrender/esm/core/types\").TextAlign;\n        textVerticalAlign: import(\"zrender/esm/core/types\").TextVerticalAlign;\n    };\n    static makeAxisEventDataBase(axisModel: AxisBaseModel): AxisEventData;\n    static isLabelSilent(axisModel: AxisBaseModel): boolean;\n}\ninterface AxisElementsBuilder {\n    (opt: AxisBuilderCfg, axisModel: AxisBaseModel, group: graphic.Group, transformGroup: graphic.Group): void;\n}\ndeclare const builders: Record<'axisLine' | 'axisTickLabel' | 'axisName', AxisElementsBuilder>;\nexport default AxisBuilder;\n"
  },
  {
    "path": "echarts/types/src/component/axis/axisSplitHelper.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport GridModel from '../../coord/cartesian/GridModel';\nimport SingleAxisView from './SingleAxisView';\nimport CartesianAxisView from './CartesianAxisView';\nimport SingleAxisModel from '../../coord/single/AxisModel';\nimport CartesianAxisModel from '../../coord/cartesian/AxisModel';\nexport declare function rectCoordAxisBuildSplitArea(axisView: SingleAxisView | CartesianAxisView, axisGroup: graphic.Group, axisModel: SingleAxisModel | CartesianAxisModel, gridModel: GridModel | SingleAxisModel): void;\nexport declare function rectCoordAxisHandleRemove(axisView: SingleAxisView | CartesianAxisView): void;\n"
  },
  {
    "path": "echarts/types/src/component/axis/AxisView.d.ts",
    "code": "import ComponentView from '../../view/Component';\nimport { AxisBaseModel } from '../../coord/AxisBaseModel';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { Payload } from '../../util/types';\nimport BaseAxisPointer from '../axisPointer/BaseAxisPointer';\ninterface AxisPointerConstructor {\n    new (): BaseAxisPointer;\n}\ndeclare class AxisView extends ComponentView {\n    static type: string;\n    type: string;\n    private _axisPointer;\n    axisPointerClass: string;\n    render(axisModel: AxisBaseModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    updateAxisPointer(axisModel: AxisBaseModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    remove(ecModel: GlobalModel, api: ExtensionAPI): void;\n    dispose(ecModel: GlobalModel, api: ExtensionAPI): void;\n    private _doUpdateAxisPointerClass;\n    private _disposeAxisPointer;\n    static registerAxisPointerClass(type: string, clazz: AxisPointerConstructor): void;\n    static getAxisPointerClass(type: string): AxisPointerConstructor;\n}\nexport default AxisView;\n"
  },
  {
    "path": "echarts/types/src/component/axis/CartesianAxisView.d.ts",
    "code": "import AxisView from './AxisView';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport CartesianAxisModel from '../../coord/cartesian/AxisModel';\nimport { Payload } from '../../util/types';\ndeclare class CartesianAxisView extends AxisView {\n    static type: string;\n    type: string;\n    axisPointerClass: string;\n    private _axisGroup;\n    render(axisModel: CartesianAxisModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    remove(): void;\n}\nexport default CartesianAxisView;\n"
  },
  {
    "path": "echarts/types/src/component/axis/parallelAxisAction.d.ts",
    "code": "import { Payload } from '../../util/types';\nexport interface ParallelAxisExpandPayload extends Payload {\n    axisExpandWindow?: number[];\n}\n"
  },
  {
    "path": "echarts/types/src/component/axis/ParallelAxisView.d.ts",
    "code": "import { BrushControllerEvents } from '../helper/BrushController';\nimport ComponentView from '../../view/Component';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport GlobalModel from '../../model/Global';\nimport ParallelAxisModel, { ParallelAreaSelectStyleProps } from '../../coord/parallel/AxisModel';\nimport { Payload } from '../../util/types';\nimport ParallelModel from '../../coord/parallel/ParallelModel';\nimport { ParallelAxisLayoutInfo } from '../../coord/parallel/Parallel';\ndeclare class ParallelAxisView extends ComponentView {\n    static type: string;\n    readonly type: string;\n    private _brushController;\n    private _axisGroup;\n    axisModel: ParallelAxisModel;\n    api: ExtensionAPI;\n    init(ecModel: GlobalModel, api: ExtensionAPI): void;\n    render(axisModel: ParallelAxisModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    _refreshBrushController(builderOpt: Pick<ParallelAxisLayoutInfo, 'position' | 'rotation'>, areaSelectStyle: ParallelAreaSelectStyleProps, axisModel: ParallelAxisModel, coordSysModel: ParallelModel, areaWidth: ParallelAreaSelectStyleProps['width'], api: ExtensionAPI): void;\n    _onBrush(eventParam: BrushControllerEvents['brush']): void;\n    dispose(): void;\n}\nexport default ParallelAxisView;\n"
  },
  {
    "path": "echarts/types/src/component/axis/RadiusAxisView.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/axis/SingleAxisView.d.ts",
    "code": "import AxisView from './AxisView';\nimport SingleAxisModel from '../../coord/single/AxisModel';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { Payload } from '../../util/types';\ndeclare class SingleAxisView extends AxisView {\n    static readonly type = \"singleAxis\";\n    readonly type = \"singleAxis\";\n    private _axisGroup;\n    axisPointerClass: string;\n    render(axisModel: SingleAxisModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    remove(): void;\n}\nexport default SingleAxisView;\n"
  },
  {
    "path": "echarts/types/src/component/axisPointer.d.ts",
    "code": "import './axisPointer/AxisPointerView';\nimport './axisPointer/CartesianAxisPointer';\n"
  },
  {
    "path": "echarts/types/src/component/axisPointer/AxisPointer.d.ts",
    "code": "import { AxisBaseModel } from '../../coord/AxisBaseModel';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { CommonAxisPointerOption } from '../../util/types';\nimport Model from '../../model/Model';\nexport interface AxisPointer {\n    render(axisModel: AxisBaseModel, axisPointerModel: Model<CommonAxisPointerOption>, api: ExtensionAPI, forceRender?: boolean): void;\n    remove(api: ExtensionAPI): void;\n    dispose(api: ExtensionAPI): void;\n}\n"
  },
  {
    "path": "echarts/types/src/component/axisPointer/AxisPointerModel.d.ts",
    "code": "import ComponentModel from '../../model/Component';\nimport { ComponentOption, ScaleDataValue, CommonAxisPointerOption } from '../../util/types';\ninterface MapperParamAxisInfo {\n    axisIndex: number;\n    axisName: string;\n    axisId: string;\n    axisDim: string;\n}\ninterface AxisPointerLink {\n    xAxisIndex?: number[] | 'all';\n    yAxisIndex?: number[] | 'all';\n    xAxisId?: string[];\n    yAxisId?: string[];\n    xAxisName?: string[] | string;\n    yAxisName?: string[] | string;\n    radiusAxisIndex?: number[] | 'all';\n    angleAxisIndex?: number[] | 'all';\n    radiusAxisId?: string[];\n    angleAxisId?: string[];\n    radiusAxisName?: string[] | string;\n    angleAxisName?: string[] | string;\n    singleAxisIndex?: number[] | 'all';\n    singleAxisId?: string[];\n    singleAxisName?: string[] | string;\n    mapper?(sourceVal: ScaleDataValue, sourceAxisInfo: MapperParamAxisInfo, targetAxisInfo: MapperParamAxisInfo): CommonAxisPointerOption['value'];\n}\nexport interface AxisPointerOption extends ComponentOption, Omit<CommonAxisPointerOption, 'type'> {\n    type?: 'line' | 'shadow' | 'cross' | 'none';\n    link?: AxisPointerLink[];\n}\ndeclare class AxisPointerModel extends ComponentModel<AxisPointerOption> {\n    static type: \"axisPointer\";\n    type: \"axisPointer\";\n    coordSysAxesInfo: unknown;\n    static defaultOption: AxisPointerOption;\n}\nexport default AxisPointerModel;\n"
  },
  {
    "path": "echarts/types/src/component/axisPointer/AxisPointerView.d.ts",
    "code": "import ComponentView from '../../view/Component';\nimport AxisPointerModel from './AxisPointerModel';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\ndeclare class AxisPointerView extends ComponentView {\n    static type: \"axisPointer\";\n    type: \"axisPointer\";\n    render(globalAxisPointerModel: AxisPointerModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    remove(ecModel: GlobalModel, api: ExtensionAPI): void;\n    dispose(ecModel: GlobalModel, api: ExtensionAPI): void;\n}\nexport default AxisPointerView;\n"
  },
  {
    "path": "echarts/types/src/component/axisPointer/axisTrigger.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { Payload, CommonAxisPointerOption } from '../../util/types';\ndeclare type AxisValue = CommonAxisPointerOption['value'];\ninterface AxisTriggerPayload extends Payload {\n    currTrigger?: 'click' | 'mousemove' | 'leave';\n    x?: number;\n    y?: number;\n    seriesIndex?: number;\n    dataIndex: number;\n    axesInfo?: {\n        axisDim?: string;\n        axisIndex?: number;\n        value?: AxisValue;\n    }[];\n    dispatchAction: ExtensionAPI['dispatchAction'];\n}\nexport default function (payload: AxisTriggerPayload, ecModel: GlobalModel, api: ExtensionAPI): AxisTriggerPayload;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/component/axisPointer/BaseAxisPointer.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport { AxisPointer } from './AxisPointer';\nimport { AxisBaseModel } from '../../coord/AxisBaseModel';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport Element from 'zrender/esm/Element';\nimport { VerticalAlign, HorizontalAlign, CommonAxisPointerOption } from '../../util/types';\nimport { PathProps } from 'zrender/esm/graphic/Path';\nimport Model from '../../model/Model';\nimport { TextProps } from 'zrender/esm/graphic/Text';\ninterface Transform {\n    x: number;\n    y: number;\n    rotation: number;\n}\ndeclare type AxisValue = CommonAxisPointerOption['value'];\ndeclare type AxisPointerModel = Model<CommonAxisPointerOption>;\ninterface BaseAxisPointer {\n    getHandleTransform(value: AxisValue, axisModel: AxisBaseModel, axisPointerModel: AxisPointerModel): Transform;\n    updateHandleTransform(transform: Transform, delta: number[], axisModel: AxisBaseModel, axisPointerModel: AxisPointerModel): Transform & {\n        cursorPoint: number[];\n        tooltipOption?: {\n            verticalAlign?: VerticalAlign;\n            align?: HorizontalAlign;\n        };\n    };\n}\nexport interface AxisPointerElementOptions {\n    graphicKey: string;\n    pointer: PathProps & {\n        type: 'Line' | 'Rect' | 'Circle' | 'Sector';\n    };\n    label: TextProps;\n}\ndeclare class BaseAxisPointer implements AxisPointer {\n    private _group;\n    private _lastGraphicKey;\n    private _handle;\n    private _dragging;\n    private _lastValue;\n    private _lastStatus;\n    private _payloadInfo;\n    private _moveAnimation;\n    private _axisModel;\n    private _axisPointerModel;\n    private _api;\n    protected animationThreshold: number;\n    render(axisModel: AxisBaseModel, axisPointerModel: AxisPointerModel, api: ExtensionAPI, forceRender?: boolean): void;\n    remove(api: ExtensionAPI): void;\n    dispose(api: ExtensionAPI): void;\n    determineAnimation(axisModel: AxisBaseModel, axisPointerModel: AxisPointerModel): boolean;\n    makeElOption(elOption: AxisPointerElementOptions, value: AxisValue, axisModel: AxisBaseModel, axisPointerModel: AxisPointerModel, api: ExtensionAPI): void;\n    createPointerEl(group: graphic.Group, elOption: AxisPointerElementOptions, axisModel: AxisBaseModel, axisPointerModel: AxisPointerModel): void;\n    createLabelEl(group: graphic.Group, elOption: AxisPointerElementOptions, axisModel: AxisBaseModel, axisPointerModel: AxisPointerModel): void;\n    updatePointerEl(group: graphic.Group, elOption: AxisPointerElementOptions, updateProps: (el: Element, props: PathProps) => void): void;\n    updateLabelEl(group: graphic.Group, elOption: AxisPointerElementOptions, updateProps: (el: Element, props: PathProps) => void, axisPointerModel: AxisPointerModel): void;\n    _renderHandle(value: AxisValue): void;\n    private _moveHandleToValue;\n    private _onHandleDragMove;\n    _doDispatchAxisPointer(): void;\n    private _onHandleDragEnd;\n    clear(api: ExtensionAPI): void;\n    doClear(): void;\n    buildLabel(xy: number[], wh: number[], xDimIndex: 0 | 1): {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n    };\n}\nexport default BaseAxisPointer;\n"
  },
  {
    "path": "echarts/types/src/component/axisPointer/CartesianAxisPointer.d.ts",
    "code": "import BaseAxisPointer, { AxisPointerElementOptions } from './BaseAxisPointer';\nimport CartesianAxisModel from '../../coord/cartesian/AxisModel';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { ScaleDataValue, CommonAxisPointerOption } from '../../util/types';\nimport Model from '../../model/Model';\ndeclare type AxisPointerModel = Model<CommonAxisPointerOption>;\ndeclare class CartesianAxisPointer extends BaseAxisPointer {\n    makeElOption(elOption: AxisPointerElementOptions, value: ScaleDataValue, axisModel: CartesianAxisModel, axisPointerModel: AxisPointerModel, api: ExtensionAPI): void;\n    getHandleTransform(value: ScaleDataValue, axisModel: CartesianAxisModel, axisPointerModel: AxisPointerModel): {\n        x: number;\n        y: number;\n        rotation: number;\n    };\n    updateHandleTransform(transform: {\n        x: number;\n        y: number;\n        rotation: number;\n    }, delta: number[], axisModel: CartesianAxisModel, axisPointerModel: AxisPointerModel): {\n        x: number;\n        y: number;\n        rotation: number;\n        cursorPoint: number[];\n        tooltipOption: {\n            verticalAlign?: import(\"zrender/esm/core/types\").TextVerticalAlign;\n            align?: import(\"zrender/esm/core/types\").TextAlign;\n        };\n    };\n}\nexport default CartesianAxisPointer;\n"
  },
  {
    "path": "echarts/types/src/component/axisPointer/findPointFromSeries.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nimport Element from 'zrender/esm/Element';\nexport default function (finder: {\n    seriesIndex?: number;\n    dataIndex?: number | number[];\n    dataIndexInside?: number | number[];\n    name?: string | string[];\n    isStacked?: boolean;\n}, ecModel: GlobalModel): {\n    point: number[];\n    el?: Element;\n};\n"
  },
  {
    "path": "echarts/types/src/component/axisPointer/globalListener.d.ts",
    "code": "import ExtensionAPI from '../../ExtensionAPI';\nimport { ZRElementEvent } from '../../util/types';\ndeclare type DispatchActionMethod = ExtensionAPI['dispatchAction'];\ndeclare type Handler = (currTrigger: 'click' | 'mousemove' | 'leave', event: ZRElementEvent, dispatchAction: DispatchActionMethod) => void;\nexport declare function register(key: string, api: ExtensionAPI, handler?: Handler): void;\nexport declare function unregister(key: string, api: ExtensionAPI): void;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/component/axisPointer/modelHelper.d.ts",
    "code": "import Model from '../../model/Model';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { AxisPointerOption } from './AxisPointerModel';\nimport Axis from '../../coord/Axis';\nimport SeriesModel from '../../model/Series';\nimport { CommonAxisPointerOption, Dictionary } from '../../util/types';\nimport { AxisBaseModel } from '../../coord/AxisBaseModel';\nimport ComponentModel from '../../model/Component';\nimport { CoordinateSystemMaster } from '../../coord/CoordinateSystem';\ninterface LinkGroup {\n    mapper: AxisPointerOption['link'][number]['mapper'];\n    axesInfo: Dictionary<AxisInfo>;\n}\ninterface AxisInfo {\n    axis: Axis;\n    key: string;\n    coordSys: CoordinateSystemMaster;\n    axisPointerModel: Model<CommonAxisPointerOption>;\n    triggerTooltip: boolean;\n    involveSeries: boolean;\n    snap: boolean;\n    useHandle: boolean;\n    seriesModels: SeriesModel[];\n    linkGroup?: LinkGroup;\n    seriesDataCount?: number;\n}\ninterface CollectionResult {\n    coordSysAxesInfo: Dictionary<Dictionary<AxisInfo>>;\n    axesInfo: Dictionary<AxisInfo>;\n    coordSysMap: Dictionary<CoordinateSystemMaster>;\n    seriesInvolved: boolean;\n}\nexport declare function collect(ecModel: GlobalModel, api: ExtensionAPI): CollectionResult;\nexport declare function fixValue(axisModel: AxisBaseModel): void;\nexport declare function getAxisInfo(axisModel: AxisBaseModel): AxisInfo;\nexport declare function getAxisPointerModel(axisModel: AxisBaseModel): Model<CommonAxisPointerOption>;\nexport declare function makeKey(model: ComponentModel): string;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/component/axisPointer/PolarAxisPointer.d.ts",
    "code": "import BaseAxisPointer, { AxisPointerElementOptions } from './BaseAxisPointer';\nimport { OptionDataValue, CommonAxisPointerOption } from '../../util/types';\nimport { PolarAxisModel } from '../../coord/polar/AxisModel';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport Model from '../../model/Model';\ndeclare class PolarAxisPointer extends BaseAxisPointer {\n    makeElOption(elOption: AxisPointerElementOptions, value: OptionDataValue, axisModel: PolarAxisModel, axisPointerModel: Model<CommonAxisPointerOption>, api: ExtensionAPI): void;\n}\nexport default PolarAxisPointer;\n"
  },
  {
    "path": "echarts/types/src/component/axisPointer/SingleAxisPointer.d.ts",
    "code": "import BaseAxisPointer, { AxisPointerElementOptions } from './BaseAxisPointer';\nimport { ScaleDataValue, CommonAxisPointerOption } from '../../util/types';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport SingleAxisModel from '../../coord/single/AxisModel';\nimport Model from '../../model/Model';\ndeclare type AxisPointerModel = Model<CommonAxisPointerOption>;\ndeclare class SingleAxisPointer extends BaseAxisPointer {\n    makeElOption(elOption: AxisPointerElementOptions, value: ScaleDataValue, axisModel: SingleAxisModel, axisPointerModel: AxisPointerModel, api: ExtensionAPI): void;\n    getHandleTransform(value: ScaleDataValue, axisModel: SingleAxisModel, axisPointerModel: AxisPointerModel): {\n        x: number;\n        y: number;\n        rotation: number;\n    };\n    updateHandleTransform(transform: {\n        x: number;\n        y: number;\n        rotation: number;\n    }, delta: number[], axisModel: SingleAxisModel, axisPointerModel: AxisPointerModel): {\n        x: number;\n        y: number;\n        rotation: number;\n        cursorPoint: number[];\n        tooltipOption: {\n            verticalAlign: import(\"zrender/esm/core/types\").TextVerticalAlign;\n        };\n    };\n}\nexport default SingleAxisPointer;\n"
  },
  {
    "path": "echarts/types/src/component/axisPointer/viewHelper.d.ts",
    "code": "import Axis from '../../coord/Axis';\nimport { ScaleDataValue, ZRTextAlign, ZRTextVerticalAlign, CommonAxisPointerOption } from '../../util/types';\nimport { VectorArray } from 'zrender/esm/core/vector';\nimport GlobalModel from '../../model/Global';\nimport { AxisPointerElementOptions } from './BaseAxisPointer';\nimport { AxisBaseModel } from '../../coord/AxisBaseModel';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport CartesianAxisModel from '../../coord/cartesian/AxisModel';\nimport Model from '../../model/Model';\nimport { PathStyleProps } from 'zrender/esm/graphic/Path';\ninterface LayoutInfo {\n    position: VectorArray;\n    rotation: number;\n    labelOffset?: number;\n    labelDirection?: number;\n    labelMargin?: number;\n}\ndeclare type AxisPointerModel = Model<CommonAxisPointerOption>;\nexport declare function buildElStyle(axisPointerModel: AxisPointerModel): PathStyleProps;\nexport declare function buildLabelElOption(elOption: AxisPointerElementOptions, axisModel: AxisBaseModel, axisPointerModel: AxisPointerModel, api: ExtensionAPI, labelPos: {\n    align?: ZRTextAlign;\n    verticalAlign?: ZRTextVerticalAlign;\n    position: number[];\n}): void;\nexport declare function getValueLabel(value: ScaleDataValue, axis: Axis, ecModel: GlobalModel, seriesDataIndices: CommonAxisPointerOption['seriesDataIndices'], opt?: {\n    precision?: number | 'auto';\n    formatter?: CommonAxisPointerOption['label']['formatter'];\n}): string;\nexport declare function getTransformedPosition(axis: Axis, value: ScaleDataValue, layoutInfo: LayoutInfo): number[];\nexport declare function buildCartesianSingleLabelElOption(value: ScaleDataValue, elOption: AxisPointerElementOptions, layoutInfo: LayoutInfo, axisModel: CartesianAxisModel, axisPointerModel: AxisPointerModel, api: ExtensionAPI): void;\nexport declare function makeLineShape(p1: number[], p2: number[], xDimIndex?: number): {\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n};\nexport declare function makeRectShape(xy: number[], wh: number[], xDimIndex?: number): {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n};\nexport declare function makeSectorShape(cx: number, cy: number, r0: number, r: number, startAngle: number, endAngle: number): {\n    cx: number;\n    cy: number;\n    r0: number;\n    r: number;\n    startAngle: number;\n    endAngle: number;\n    clockwise: boolean;\n};\nexport {};\n"
  },
  {
    "path": "echarts/types/src/component/brush.d.ts",
    "code": "import './brush/visualEncoding';\nimport './brush/BrushModel';\nimport './brush/BrushView';\nimport './brush/brushAction';\nimport './toolbox/feature/Brush';\n"
  },
  {
    "path": "echarts/types/src/component/brush/brushAction.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/brush/BrushModel.d.ts",
    "code": "import { ComponentOption, ZRColor, VisualOptionFixed } from '../../util/types';\nimport ComponentModel from '../../model/Component';\nimport BrushTargetManager from '../helper/BrushTargetManager';\nimport { BrushCoverCreatorConfig, BrushMode, BrushCoverConfig, BrushDimensionMinMax, BrushAreaRange, BrushTypeUncertain, BrushType } from '../helper/BrushController';\nimport { ModelFinderObject } from '../../util/model';\nexport interface BrushAreaParam extends ModelFinderObject {\n    brushType: BrushCoverConfig['brushType'];\n    id?: BrushCoverConfig['id'];\n    range?: BrushCoverConfig['range'];\n    panelId?: BrushCoverConfig['panelId'];\n    coordRange?: BrushAreaRange;\n    coordRanges?: BrushAreaRange[];\n}\nexport interface BrushAreaParamInternal extends BrushAreaParam {\n    brushMode: BrushMode;\n    brushStyle: BrushCoverConfig['brushStyle'];\n    transformable: BrushCoverConfig['transformable'];\n    removeOnClick: BrushCoverConfig['removeOnClick'];\n    z: BrushCoverConfig['z'];\n    __rangeOffset?: {\n        offset: BrushDimensionMinMax | BrushDimensionMinMax[];\n        xyMinMax: BrushDimensionMinMax[];\n    };\n}\nexport declare type BrushToolboxIconType = BrushType | 'keep' | 'clear';\nexport interface BrushOption extends ComponentOption, ModelFinderObject {\n    toolbox?: BrushToolboxIconType[];\n    brushLink?: number[] | 'all' | 'none';\n    throttleType?: 'fixRate' | 'debounce';\n    throttleDelay?: number;\n    inBrush?: VisualOptionFixed;\n    outOfBrush?: VisualOptionFixed;\n    brushType: BrushTypeUncertain;\n    brushStyle: {\n        borderWidth: number;\n        color: ZRColor;\n        borderColor: ZRColor;\n    };\n    transformable: boolean;\n    brushMode: BrushMode;\n    removeOnClick: boolean;\n}\ndeclare class BrushModel extends ComponentModel<BrushOption> {\n    static type: \"brush\";\n    type: \"brush\";\n    static dependencies: string[];\n    static defaultOption: BrushOption;\n    areas: BrushAreaParamInternal[];\n    brushType: BrushTypeUncertain;\n    brushOption: BrushCoverCreatorConfig;\n    brushTargetManager: BrushTargetManager;\n    optionUpdated(newOption: BrushOption, isInit: boolean): void;\n    setAreas(areas?: BrushAreaParam[]): void;\n    setBrushOption(brushOption: BrushCoverCreatorConfig): void;\n}\nexport default BrushModel;\n"
  },
  {
    "path": "echarts/types/src/component/brush/BrushView.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/brush/preprocessor.d.ts",
    "code": "import { ECUnitOption } from '../../util/types';\nexport default function (option: ECUnitOption, isNew: boolean): void;\n"
  },
  {
    "path": "echarts/types/src/component/brush/selector.d.ts",
    "code": "import BoundingRect, { RectLike } from 'zrender/esm/core/BoundingRect';\nimport { BrushType } from '../helper/BrushController';\nimport { BrushAreaParamInternal } from './BrushModel';\nexport interface BrushSelectableArea extends BrushAreaParamInternal {\n    boundingRect: BoundingRect;\n    selectors: BrushCommonSelectorsForSeries;\n}\ninterface BrushSelectorOnBrushType {\n    point(itemLayout: number[], selectors: BrushCommonSelectorsForSeries, area: BrushSelectableArea): boolean;\n    rect(itemLayout: RectLike, selectors: BrushCommonSelectorsForSeries, area: BrushSelectableArea): boolean;\n}\nexport interface BrushCommonSelectorsForSeries {\n    point(itemLayout: number[]): boolean;\n    rect(itemLayout: RectLike): boolean;\n}\nexport declare function makeBrushCommonSelectorForSeries(area: BrushSelectableArea): BrushCommonSelectorsForSeries;\ndeclare const selector: Record<BrushType, BrushSelectorOnBrushType>;\nexport default selector;\n"
  },
  {
    "path": "echarts/types/src/component/brush/visualEncoding.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nexport declare function layoutCovers(ecModel: GlobalModel): void;\n"
  },
  {
    "path": "echarts/types/src/component/calendar.d.ts",
    "code": "import '../coord/calendar/Calendar';\nimport '../coord/calendar/CalendarModel';\nimport './calendar/CalendarView';\n"
  },
  {
    "path": "echarts/types/src/component/calendar/CalendarView.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/dataset.d.ts",
    "code": "import ComponentModel from '../model/Component';\nimport { ComponentOption, SeriesEncodeOptionMixin, OptionSourceData, SeriesLayoutBy, OptionSourceHeader } from '../util/types';\nimport { DataTransformOption, PipedDataTransformOption } from '../data/helper/transform';\nimport GlobalModel from '../model/Global';\nimport Model from '../model/Model';\nimport { SourceManager } from '../data/helper/sourceManager';\nexport interface DatasetOption extends Pick<ComponentOption, 'type' | 'id' | 'name'>, Pick<SeriesEncodeOptionMixin, 'dimensions'> {\n    seriesLayoutBy?: SeriesLayoutBy;\n    sourceHeader?: OptionSourceHeader;\n    source?: OptionSourceData;\n    fromDatasetIndex?: number;\n    fromDatasetId?: string;\n    transform?: DataTransformOption | PipedDataTransformOption;\n    fromTransformResult?: number;\n}\nexport declare class DatasetModel<Opts extends DatasetOption = DatasetOption> extends ComponentModel<Opts> {\n    type: string;\n    static type: string;\n    static defaultOption: DatasetOption;\n    private _sourceManager;\n    init(option: Opts, parentModel: Model, ecModel: GlobalModel): void;\n    mergeOption(newOption: Opts, ecModel: GlobalModel): void;\n    optionUpdated(): void;\n    getSourceManager(): SourceManager;\n}\n"
  },
  {
    "path": "echarts/types/src/component/dataZoom.d.ts",
    "code": "import './dataZoomSlider';\nimport './dataZoomInside';\n"
  },
  {
    "path": "echarts/types/src/component/dataZoom/AxisProxy.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nimport SeriesModel from '../../model/Series';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport DataZoomModel from './DataZoomModel';\nimport { AxisBaseModel } from '../../coord/AxisBaseModel';\nimport { DataZoomAxisDimension } from './helper';\ninterface MinMaxSpan {\n    minSpan: number;\n    maxSpan: number;\n    minValueSpan: number;\n    maxValueSpan: number;\n}\ndeclare class AxisProxy {\n    ecModel: GlobalModel;\n    private _dimName;\n    private _axisIndex;\n    private _valueWindow;\n    private _percentWindow;\n    private _dataExtent;\n    private _minMaxSpan;\n    private _dataZoomModel;\n    constructor(dimName: DataZoomAxisDimension, axisIndex: number, dataZoomModel: DataZoomModel, ecModel: GlobalModel);\n    hostedBy(dataZoomModel: DataZoomModel): boolean;\n    getDataValueWindow(): [number, number];\n    getDataPercentWindow(): [number, number];\n    getTargetSeriesModels(): SeriesModel<import(\"../../util/types\").SeriesOption<any, unknown>>[];\n    getAxisModel(): AxisBaseModel;\n    getMinMaxSpan(): MinMaxSpan;\n    calculateDataWindow(opt?: {\n        start?: number;\n        end?: number;\n        startValue?: number;\n        endValue?: number;\n    }): {\n        valueWindow: [number, number];\n        percentWindow: [number, number];\n    };\n    reset(dataZoomModel: DataZoomModel): void;\n    filterData(dataZoomModel: DataZoomModel, api: ExtensionAPI): void;\n    private _updateMinMaxSpan;\n    private _setAxisModel;\n}\nexport default AxisProxy;\n"
  },
  {
    "path": "echarts/types/src/component/dataZoom/dataZoomAction.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/dataZoom/DataZoomModel.d.ts",
    "code": "import { HashMap } from 'zrender/esm/core/util';\nimport AxisProxy from './AxisProxy';\nimport ComponentModel from '../../model/Component';\nimport { LayoutOrient, ComponentOption, LabelOption } from '../../util/types';\nimport Model from '../../model/Model';\nimport GlobalModel from '../../model/Global';\nimport { AxisBaseModel } from '../../coord/AxisBaseModel';\nimport { DataZoomAxisDimension } from './helper';\nexport interface DataZoomOption extends ComponentOption {\n    orient?: LayoutOrient;\n    xAxisIndex?: number | number[];\n    xAxisId?: string | string[];\n    yAxisIndex?: number | number[];\n    yAxisId?: string | string[];\n    radiusAxisIndex?: number | number[];\n    radiusAxisId?: string | string[];\n    angleAxisIndex?: number | number[];\n    angleAxisId?: string | string[];\n    singleAxisIndex?: number | number[];\n    singleAxisId?: string | string[];\n    filterMode?: 'filter' | 'weakFilter' | 'empty' | 'none';\n    throttle?: number | null | undefined;\n    start?: number;\n    end?: number;\n    startValue?: number;\n    endValue?: number;\n    minSpan?: number;\n    maxSpan?: number;\n    minValueSpan?: number;\n    maxValueSpan?: number;\n    rangeMode?: ['value' | 'percent', 'value' | 'percent'];\n    realtime?: boolean;\n    textStyle?: LabelOption;\n}\ndeclare type RangeOption = Pick<DataZoomOption, 'start' | 'end' | 'startValue' | 'endValue'>;\nexport declare type DataZoomExtendedAxisBaseModel = AxisBaseModel & {\n    __dzAxisProxy: AxisProxy;\n};\ndeclare class DataZoomAxisInfo {\n    indexList: number[];\n    indexMap: boolean[];\n    add(axisCmptIdx: number): void;\n}\nexport declare type DataZoomTargetAxisInfoMap = HashMap<DataZoomAxisInfo, DataZoomAxisDimension>;\ndeclare class DataZoomModel<Opts extends DataZoomOption = DataZoomOption> extends ComponentModel<Opts> {\n    static type: string;\n    type: string;\n    static dependencies: string[];\n    static defaultOption: DataZoomOption;\n    private _autoThrottle;\n    private _orient;\n    private _targetAxisInfoMap;\n    private _noTarget;\n    private _rangePropMode;\n    settledOption: Opts;\n    init(option: Opts, parentModel: Model, ecModel: GlobalModel): void;\n    mergeOption(newOption: Opts): void;\n    private _doInit;\n    private _resetTarget;\n    private _fillSpecifiedTargetAxis;\n    private _fillAutoTargetAxisByOrient;\n    private _makeAutoOrientByTargetAxis;\n    private _setDefaultThrottle;\n    private _updateRangeUse;\n    noTarget(): boolean;\n    getFirstTargetAxisModel(): AxisBaseModel;\n    eachTargetAxis<Ctx>(callback: (this: Ctx, axisDim: DataZoomAxisDimension, axisIndex: number) => void, context?: Ctx): void;\n    getAxisProxy(axisDim: DataZoomAxisDimension, axisIndex: number): AxisProxy;\n    getAxisModel(axisDim: DataZoomAxisDimension, axisIndex: number): AxisBaseModel;\n    setRawRange(opt: RangeOption): void;\n    setCalculatedRange(opt: RangeOption): void;\n    getPercentRange(): number[];\n    getValueRange(axisDim: DataZoomAxisDimension, axisIndex: number): number[];\n    findRepresentativeAxisProxy(axisModel?: AxisBaseModel): AxisProxy;\n    getRangePropMode(): DataZoomModel['_rangePropMode'];\n    getOrient(): LayoutOrient;\n}\nexport default DataZoomModel;\n"
  },
  {
    "path": "echarts/types/src/component/dataZoom/dataZoomProcessor.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/dataZoom/DataZoomView.d.ts",
    "code": "import ComponentView from '../../view/Component';\nimport DataZoomModel from './DataZoomModel';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\ndeclare class DataZoomView extends ComponentView {\n    static type: string;\n    type: string;\n    dataZoomModel: DataZoomModel;\n    ecModel: GlobalModel;\n    api: ExtensionAPI;\n    render(dataZoomModel: DataZoomModel, ecModel: GlobalModel, api: ExtensionAPI, payload: any): void;\n}\nexport default DataZoomView;\n"
  },
  {
    "path": "echarts/types/src/component/dataZoom/helper.d.ts",
    "code": "import { Payload } from '../../util/types';\nimport GlobalModel from '../../model/Global';\nimport DataZoomModel from './DataZoomModel';\nimport { HashMap } from 'zrender/esm/core/util';\nimport SeriesModel from '../../model/Series';\nimport { CoordinateSystemHostModel } from '../../coord/CoordinateSystem';\nimport { AxisBaseModel } from '../../coord/AxisBaseModel';\nexport interface DataZoomPayloadBatchItem {\n    dataZoomId: string;\n    start?: number;\n    end?: number;\n    startValue?: number;\n    endValue?: number;\n}\nexport interface DataZoomReferCoordSysInfo {\n    model: CoordinateSystemHostModel;\n    axisModels: AxisBaseModel[];\n}\nexport declare const DATA_ZOOM_AXIS_DIMENSIONS: readonly [\"x\", \"y\", \"radius\", \"angle\", \"single\"];\nexport declare type DataZoomAxisDimension = 'x' | 'y' | 'radius' | 'angle' | 'single';\ndeclare type DataZoomAxisMainType = 'xAxis' | 'yAxis' | 'radiusAxis' | 'angleAxis' | 'singleAxis';\ndeclare type DataZoomAxisIndexPropName = 'xAxisIndex' | 'yAxisIndex' | 'radiusAxisIndex' | 'angleAxisIndex' | 'singleAxisIndex';\ndeclare type DataZoomAxisIdPropName = 'xAxisId' | 'yAxisId' | 'radiusAxisId' | 'angleAxisId' | 'singleAxisId';\nexport declare type DataZoomCoordSysMainType = 'polar' | 'grid' | 'singleAxis';\nexport declare function isCoordSupported(seriesModel: SeriesModel): boolean;\nexport declare function getAxisMainType(axisDim: DataZoomAxisDimension): DataZoomAxisMainType;\nexport declare function getAxisIndexPropName(axisDim: DataZoomAxisDimension): DataZoomAxisIndexPropName;\nexport declare function getAxisIdPropName(axisDim: DataZoomAxisDimension): DataZoomAxisIdPropName;\nexport declare function findEffectedDataZooms(ecModel: GlobalModel, payload: Payload): DataZoomModel[];\nexport declare function collectReferCoordSysModelInfo(dataZoomModel: DataZoomModel): {\n    infoList: DataZoomReferCoordSysInfo[];\n    infoMap: HashMap<DataZoomReferCoordSysInfo, string>;\n};\nexport {};\n"
  },
  {
    "path": "echarts/types/src/component/dataZoom/history.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nimport { Dictionary } from '../../util/types';\nimport { DataZoomPayloadBatchItem } from './helper';\nexport declare type DataZoomStoreSnapshot = Dictionary<DataZoomPayloadBatchItem>;\nexport declare function push(ecModel: GlobalModel, newSnapshot: DataZoomStoreSnapshot): void;\nexport declare function pop(ecModel: GlobalModel): Dictionary<DataZoomPayloadBatchItem>;\nexport declare function clear(ecModel: GlobalModel): void;\nexport declare function count(ecModel: GlobalModel): number;\n"
  },
  {
    "path": "echarts/types/src/component/dataZoom/InsideZoomModel.d.ts",
    "code": "import DataZoomModel, { DataZoomOption } from './DataZoomModel';\nexport interface InsideDataZoomOption extends DataZoomOption {\n    disabled?: boolean;\n    zoomLock?: boolean;\n    zoomOnMouseWheel?: boolean | 'shift' | 'ctrl' | 'alt';\n    moveOnMouseMove?: boolean | 'shift' | 'ctrl' | 'alt';\n    moveOnMouseWheel?: boolean | 'shift' | 'ctrl' | 'alt';\n    preventDefaultMouseMove?: boolean;\n    textStyle?: never;\n}\ndeclare class InsideZoomModel extends DataZoomModel<InsideDataZoomOption> {\n    static readonly type = \"dataZoom.inside\";\n    type: string;\n    static defaultOption: InsideDataZoomOption;\n}\nexport default InsideZoomModel;\n"
  },
  {
    "path": "echarts/types/src/component/dataZoom/InsideZoomView.d.ts",
    "code": "import DataZoomView from './DataZoomView';\nimport InsideZoomModel from './InsideZoomModel';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport RoamController, { RoamEventParams } from '../helper/RoamController';\nimport { DataZoomCoordSysMainType, DataZoomReferCoordSysInfo } from './helper';\ndeclare class InsideZoomView extends DataZoomView {\n    static type: string;\n    type: string;\n    range: number[];\n    render(dataZoomModel: InsideZoomModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    dispose(): void;\n    private _clear;\n}\ninterface DataZoomGetRangeHandler<T extends RoamEventParams['zoom'] | RoamEventParams['scrollMove'] | RoamEventParams['pan']> {\n    (coordSysInfo: DataZoomReferCoordSysInfo, coordSysMainType: DataZoomCoordSysMainType, controller: RoamController, e: T): [number, number];\n}\ndeclare const getRangeHandlers: {\n    pan: DataZoomGetRangeHandler<RoamEventParams['pan']>;\n    zoom: DataZoomGetRangeHandler<RoamEventParams['zoom']>;\n    scrollMove: DataZoomGetRangeHandler<RoamEventParams['scrollMove']>;\n} & ThisType<InsideZoomView>;\nexport declare type DataZoomGetRangeHandlers = typeof getRangeHandlers;\nexport default InsideZoomView;\n"
  },
  {
    "path": "echarts/types/src/component/dataZoom/roams.d.ts",
    "code": "import ExtensionAPI from '../../ExtensionAPI';\nimport InsideZoomModel from './InsideZoomModel';\nimport { DataZoomGetRangeHandlers } from './InsideZoomView';\nexport declare function setViewInfoToCoordSysRecord(api: ExtensionAPI, dataZoomModel: InsideZoomModel, getRange: DataZoomGetRangeHandlers): void;\nexport declare function disposeCoordSysRecordIfNeeded(api: ExtensionAPI, dataZoomModel: InsideZoomModel): void;\n"
  },
  {
    "path": "echarts/types/src/component/dataZoom/SelectZoomModel.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/dataZoom/SelectZoomView.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/dataZoom/SliderZoomModel.d.ts",
    "code": "import DataZoomModel, { DataZoomOption } from './DataZoomModel';\nimport { BoxLayoutOptionMixin, ZRColor, LineStyleOption, AreaStyleOption, ItemStyleOption, LabelOption } from '../../util/types';\nexport interface SliderDataZoomOption extends DataZoomOption, BoxLayoutOptionMixin {\n    show?: boolean;\n    backgroundColor?: ZRColor;\n    borderColor?: ZRColor;\n    borderRadius?: number | number[];\n    dataBackground?: {\n        lineStyle?: LineStyleOption;\n        areaStyle?: AreaStyleOption;\n    };\n    selectedDataBackground?: {\n        lineStyle?: LineStyleOption;\n        areaStyle?: AreaStyleOption;\n    };\n    fillerColor?: ZRColor;\n    handleIcon?: string;\n    handleSize?: string | number;\n    handleStyle?: ItemStyleOption;\n    moveHandleIcon?: string;\n    moveHandleStyle?: ItemStyleOption;\n    moveHandleSize?: number;\n    labelPrecision?: number | 'auto';\n    labelFormatter?: string | ((value: number, valueStr: string) => string);\n    showDetail?: boolean;\n    showDataShadow?: 'auto' | boolean;\n    zoomLock?: boolean;\n    textStyle?: LabelOption;\n    brushSelect?: boolean;\n    brushStyle?: ItemStyleOption;\n    emphasis?: {\n        handleStyle?: ItemStyleOption;\n        moveHandleStyle?: ItemStyleOption;\n    };\n}\ndeclare class SliderZoomModel extends DataZoomModel<SliderDataZoomOption> {\n    static readonly type = \"dataZoom.slider\";\n    type: string;\n    static readonly layoutMode = \"box\";\n    static defaultOption: SliderDataZoomOption;\n}\nexport default SliderZoomModel;\n"
  },
  {
    "path": "echarts/types/src/component/dataZoom/SliderZoomView.d.ts",
    "code": "import DataZoomView from './DataZoomView';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { Payload } from '../../util/types';\nimport SliderZoomModel from './SliderZoomModel';\ndeclare class SliderZoomView extends DataZoomView {\n    static type: string;\n    type: string;\n    dataZoomModel: SliderZoomModel;\n    private _displayables;\n    private _orient;\n    private _range;\n    private _handleEnds;\n    private _size;\n    private _handleWidth;\n    private _handleHeight;\n    private _location;\n    private _brushStart;\n    private _brushStartTime;\n    private _dragging;\n    private _brushing;\n    private _dataShadowInfo;\n    init(ecModel: GlobalModel, api: ExtensionAPI): void;\n    render(dataZoomModel: SliderZoomModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload & {\n        from: string;\n        type: string;\n    }): void;\n    dispose(): void;\n    private _clear;\n    private _buildView;\n    private _resetLocation;\n    private _positionGroup;\n    private _getViewExtent;\n    private _renderBackground;\n    private _renderDataShadow;\n    private _prepareDataShadowInfo;\n    private _renderHandle;\n    private _resetInterval;\n    private _updateInterval;\n    private _updateView;\n    private _updateDataInfo;\n    private _formatLabel;\n    private _showDataInfo;\n    private _onDragMove;\n    private _onDragEnd;\n    private _onClickPanel;\n    private _onBrushStart;\n    private _onBrushEnd;\n    private _onBrush;\n    private _updateBrushRect;\n    _dispatchZoomAction(realtime: boolean): void;\n    private _findCoordRect;\n}\nexport default SliderZoomView;\n"
  },
  {
    "path": "echarts/types/src/component/dataZoom/typeDefaulter.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/dataZoomInside.d.ts",
    "code": "import './dataZoom/typeDefaulter';\nimport './dataZoom/DataZoomModel';\nimport './dataZoom/DataZoomView';\nimport './dataZoom/InsideZoomModel';\nimport './dataZoom/InsideZoomView';\nimport './dataZoom/dataZoomProcessor';\nimport './dataZoom/dataZoomAction';\n"
  },
  {
    "path": "echarts/types/src/component/dataZoomSelect.d.ts",
    "code": "import './dataZoom/typeDefaulter';\nimport './dataZoom/DataZoomModel';\nimport './dataZoom/DataZoomView';\nimport './dataZoom/SelectZoomModel';\nimport './dataZoom/SelectZoomView';\nimport './dataZoom/dataZoomProcessor';\nimport './dataZoom/dataZoomAction';\n"
  },
  {
    "path": "echarts/types/src/component/dataZoomSlider.d.ts",
    "code": "import './dataZoom/typeDefaulter';\nimport './dataZoom/DataZoomModel';\nimport './dataZoom/DataZoomView';\nimport './dataZoom/SliderZoomModel';\nimport './dataZoom/SliderZoomView';\nimport './dataZoom/dataZoomProcessor';\nimport './dataZoom/dataZoomAction';\n"
  },
  {
    "path": "echarts/types/src/component/geo.d.ts",
    "code": "import '../coord/geo/geoCreator';\nimport './geo/GeoView';\nimport '../action/geoRoam';\nimport '../coord/geo/GeoModel';\n"
  },
  {
    "path": "echarts/types/src/component/geo/GeoView.d.ts",
    "code": "import ComponentView from '../../view/Component';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport GeoModel from '../../coord/geo/GeoModel';\nimport { Payload } from '../../util/types';\ndeclare class GeoView extends ComponentView {\n    static type: \"geo\";\n    readonly type: \"geo\";\n    private _mapDraw;\n    private _api;\n    private _model;\n    init(ecModel: GlobalModel, api: ExtensionAPI): void;\n    render(geoModel: GeoModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    private _handleRegionClick;\n    updateSelectStatus(): void;\n    dispose(): void;\n}\nexport default GeoView;\n"
  },
  {
    "path": "echarts/types/src/component/graphic.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/grid.d.ts",
    "code": "import './gridSimple';\nimport './axisPointer/CartesianAxisPointer';\nimport './axisPointer';\n"
  },
  {
    "path": "echarts/types/src/component/gridSimple.d.ts",
    "code": "import './axis';\nimport '../coord/cartesian/defaultAxisExtentFromData';\n"
  },
  {
    "path": "echarts/types/src/component/helper/BrushController.d.ts",
    "code": "import Eventful from 'zrender/esm/core/Eventful';\nimport * as graphic from '../../util/graphic';\nimport { Dictionary } from '../../util/types';\nimport { ZRenderType } from 'zrender/esm/zrender';\nimport { ElementEvent } from 'zrender/esm/Element';\nimport * as matrix from 'zrender/esm/core/matrix';\nimport { PathStyleProps } from 'zrender/esm/graphic/Path';\nexport declare type BrushType = 'polygon' | 'rect' | 'lineX' | 'lineY';\nexport declare type BrushTypeUncertain = BrushType | false | 'auto';\nexport declare type BrushMode = 'single' | 'multiple';\nexport declare type BrushDimensionMinMax = number[];\nexport declare type BrushAreaRange = BrushDimensionMinMax | BrushDimensionMinMax[];\nexport interface BrushCoverConfig {\n    brushType: BrushType;\n    id?: string;\n    range?: BrushAreaRange;\n    panelId?: string;\n    brushMode?: BrushMode;\n    brushStyle?: Pick<PathStyleProps, BrushStyleKey>;\n    transformable?: boolean;\n    removeOnClick?: boolean;\n    z?: number;\n}\nexport interface BrushCoverCreatorConfig extends Pick<BrushCoverConfig, 'brushMode' | 'transformable' | 'removeOnClick' | 'brushStyle' | 'z'> {\n    brushType: BrushTypeUncertain;\n}\ndeclare type BrushStyleKey = 'fill' | 'stroke' | 'lineWidth' | 'opacity' | 'shadowBlur' | 'shadowOffsetX' | 'shadowOffsetY' | 'shadowColor';\ndeclare const BRUSH_PANEL_GLOBAL: true;\nexport interface BrushPanelConfig {\n    panelId: string;\n    clipPath(localPoints: number[][], transform: matrix.MatrixArray): number[][];\n    isTargetByCursor(e: ElementEvent, localCursorPoint: number[], transform: matrix.MatrixArray): boolean;\n    defaultBrushType?: BrushType;\n    getLinearBrushOtherExtent?(xyIndex: number): number[];\n}\ndeclare type BrushPanelConfigOrGlobal = BrushPanelConfig | typeof BRUSH_PANEL_GLOBAL;\ninterface BrushCover extends graphic.Group {\n    __brushOption: BrushCoverConfig;\n}\nexport interface BrushControllerEvents {\n    brush: {\n        areas: {\n            brushType: BrushType;\n            panelId: string;\n            range: BrushAreaRange;\n        }[];\n        isEnd: boolean;\n        removeOnClick: boolean;\n    };\n}\ndeclare class BrushController extends Eventful<BrushControllerEvents> {\n    readonly group: graphic.Group;\n    _zr: ZRenderType;\n    _brushType: BrushTypeUncertain;\n    _brushOption: BrushCoverCreatorConfig;\n    _panels: Dictionary<BrushPanelConfig>;\n    _track: number[][];\n    _dragging: boolean;\n    _covers: BrushCover[];\n    _creatingCover: BrushCover;\n    _creatingPanel: BrushPanelConfigOrGlobal;\n    private _enableGlobalPan;\n    private _mounted;\n    _transform: matrix.MatrixArray;\n    private _uid;\n    private _handlers;\n    constructor(zr: ZRenderType);\n    enableBrush(brushOption: Partial<BrushCoverCreatorConfig> | false): BrushController;\n    private _doEnableBrush;\n    private _doDisableBrush;\n    setPanels(panelOpts?: BrushPanelConfig[]): BrushController;\n    mount(opt?: {\n        enableGlobalPan?: boolean;\n        x?: number;\n        y?: number;\n        rotation?: number;\n        scaleX?: number;\n        scaleY?: number;\n    }): BrushController;\n    updateCovers(coverConfigList: BrushCoverConfig[]): this;\n    unmount(): this;\n    dispose(): void;\n}\nexport default BrushController;\n"
  },
  {
    "path": "echarts/types/src/component/helper/brushHelper.d.ts",
    "code": "import { RectLike } from 'zrender/esm/core/BoundingRect';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { ElementEvent } from 'zrender/esm/Element';\nimport ComponentModel from '../../model/Component';\nexport declare function makeRectPanelClipPath(rect: RectLike): (localPoints: number[][]) => number[][];\nexport declare function makeLinearBrushOtherExtent(rect: RectLike, specifiedXYIndex?: 0 | 1): (xyIndex: 0 | 1) => number[];\nexport declare function makeRectIsTargetByCursor(rect: RectLike, api: ExtensionAPI, targetModel: ComponentModel): (e: ElementEvent, localCursorPoint: number[]) => boolean;\n"
  },
  {
    "path": "echarts/types/src/component/helper/BrushTargetManager.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport { BrushPanelConfig, BrushControllerEvents, BrushType, BrushAreaRange, BrushDimensionMinMax } from './BrushController';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport GridModel from '../../coord/cartesian/GridModel';\nimport GeoModel from '../../coord/geo/GeoModel';\nimport { CoordinateSystemMaster } from '../../coord/CoordinateSystem';\nimport Cartesian2D from '../../coord/cartesian/Cartesian2D';\nimport Geo from '../../coord/geo/Geo';\nimport GlobalModel from '../../model/Global';\nimport { BrushAreaParam, BrushAreaParamInternal } from '../brush/BrushModel';\nimport SeriesModel from '../../model/Series';\nimport { ModelFinderObject } from '../../util/model';\ndeclare type COORD_CONVERTS_INDEX = 0 | 1;\ndeclare type BrushableCoordinateSystem = Cartesian2D | Geo;\ndeclare type BrushTargetBuilderKey = 'grid' | 'geo';\ninterface BrushTargetInfo {\n    panelId: string;\n    coordSysModel: CoordinateSystemMaster['model'];\n    coordSys: BrushableCoordinateSystem;\n    coordSyses: BrushableCoordinateSystem[];\n    getPanelRect: GetPanelRect;\n}\nexport interface BrushTargetInfoCartesian2D extends BrushTargetInfo {\n    gridModel: GridModel;\n    coordSys: Cartesian2D;\n    coordSyses: Cartesian2D[];\n    xAxisDeclared: boolean;\n    yAxisDeclared: boolean;\n}\nexport interface BrushTargetInfoGeo extends BrushTargetInfo {\n    geoModel: GeoModel;\n    coordSysModel: GeoModel;\n    coordSys: Geo;\n    coordSyses: Geo[];\n}\ndeclare type GetPanelRect = () => graphic.BoundingRect;\ndeclare class BrushTargetManager {\n    private _targetInfoList;\n    constructor(finder: ModelFinderObject, ecModel: GlobalModel, opt?: {\n        include?: BrushTargetBuilderKey[];\n    });\n    setOutputRanges(areas: BrushControllerEvents['brush']['areas'], ecModel: GlobalModel): BrushAreaParam[];\n    matchOutputRanges<T extends (Parameters<BrushTargetManager['findTargetInfo']>[0] & {\n        brushType: BrushType;\n        range: BrushAreaRange;\n    })>(areas: T[], ecModel: GlobalModel, cb: (area: T, coordRange: ReturnType<ConvertCoord>['values'], coordSys: BrushableCoordinateSystem, ecModel: GlobalModel) => void): void;\n    setInputRanges(areas: BrushAreaParamInternal[], ecModel: GlobalModel): void;\n    makePanelOpts(api: ExtensionAPI, getDefaultBrushType?: (targetInfo: BrushTargetInfo) => BrushType): BrushPanelConfig[];\n    controlSeries(area: BrushAreaParamInternal, seriesModel: SeriesModel, ecModel: GlobalModel): boolean;\n    findTargetInfo(area: ModelFinderObject & {\n        panelId?: string;\n    }, ecModel: GlobalModel): BrushTargetInfo | true;\n}\ndeclare type ConvertCoord = (to: COORD_CONVERTS_INDEX, coordSys: BrushableCoordinateSystem, rangeOrCoordRange: BrushAreaRange) => {\n    values: BrushAreaRange;\n    xyMinMax: BrushDimensionMinMax[];\n};\nexport default BrushTargetManager;\n"
  },
  {
    "path": "echarts/types/src/component/helper/cursorHelper.d.ts",
    "code": "import { ElementEvent } from 'zrender/esm/Element';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { CoordinateSystem } from '../../coord/CoordinateSystem';\nexport declare function onIrrelevantElement(e: ElementEvent, api: ExtensionAPI, targetCoordSysModel: CoordinateSystem['model']): boolean;\n"
  },
  {
    "path": "echarts/types/src/component/helper/interactionMutex.d.ts",
    "code": "export declare function take(zr: any, resourceKey: any, userKey: any): void;\nexport declare function release(zr: any, resourceKey: any, userKey: any): void;\nexport declare function isTaken(zr: any, resourceKey: any): boolean;\n"
  },
  {
    "path": "echarts/types/src/component/helper/listComponent.d.ts",
    "code": "export declare function layout(group: any, componentModel: any, api: any): void;\nexport declare function makeBackground(rect: any, componentModel: any): any;\n"
  },
  {
    "path": "echarts/types/src/component/helper/MapDraw.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport GeoModel from '../../coord/geo/GeoModel';\nimport MapSeries from '../../chart/map/MapSeries';\nimport GlobalModel from '../../model/Global';\nimport { Payload } from '../../util/types';\nimport GeoView from '../geo/GeoView';\nimport MapView from '../../chart/map/MapView';\ndeclare class MapDraw {\n    private uid;\n    private _controller;\n    private _controllerHost;\n    readonly group: graphic.Group;\n    private _mouseDownFlag;\n    private _mapName;\n    private _initialized;\n    private _regionsGroup;\n    private _backgroundGroup;\n    constructor(api: ExtensionAPI);\n    draw(mapOrGeoModel: GeoModel | MapSeries, ecModel: GlobalModel, api: ExtensionAPI, fromView: MapView | GeoView, payload: Payload): void;\n    remove(): void;\n    private _updateBackground;\n    private _updateController;\n    private _updateMapSelectHandler;\n}\nexport default MapDraw;\n"
  },
  {
    "path": "echarts/types/src/component/helper/RoamController.d.ts",
    "code": "import Eventful from 'zrender/esm/core/Eventful';\nimport { ZRenderType } from 'zrender/esm/zrender';\nimport { ZRElementEvent, RoamOptionMixin } from '../../util/types';\nimport { Bind3 } from 'zrender/esm/core/util';\nimport Group from 'zrender/esm/graphic/Group';\nexport declare type RoamType = RoamOptionMixin['roam'];\ninterface RoamOption {\n    zoomOnMouseWheel?: boolean | 'ctrl' | 'shift' | 'alt';\n    moveOnMouseMove?: boolean | 'ctrl' | 'shift' | 'alt';\n    moveOnMouseWheel?: boolean | 'ctrl' | 'shift' | 'alt';\n    preventDefaultMouseMove?: boolean;\n}\ndeclare type RoamBehavior = 'zoomOnMouseWheel' | 'moveOnMouseMove' | 'moveOnMouseWheel';\nexport declare type RoamEventParams = {\n    'zoom': {\n        scale: number;\n        originX: number;\n        originY: number;\n        isAvailableBehavior: Bind3<typeof isAvailableBehavior, null, RoamBehavior, ZRElementEvent>;\n    };\n    'scrollMove': {\n        scrollDelta: number;\n        originX: number;\n        originY: number;\n        isAvailableBehavior: Bind3<typeof isAvailableBehavior, null, RoamBehavior, ZRElementEvent>;\n    };\n    'pan': {\n        dx: number;\n        dy: number;\n        oldX: number;\n        oldY: number;\n        newX: number;\n        newY: number;\n        isAvailableBehavior: Bind3<typeof isAvailableBehavior, null, RoamBehavior, ZRElementEvent>;\n    };\n};\nexport interface RoamControllerHost {\n    target: Group;\n    zoom: number;\n    zoomLimit: {\n        min?: number;\n        max?: number;\n    };\n}\ndeclare class RoamController extends Eventful<RoamEventParams> {\n    pointerChecker: (e: ZRElementEvent, x: number, y: number) => boolean;\n    private _zr;\n    private _opt;\n    private _dragging;\n    private _pinching;\n    private _x;\n    private _y;\n    readonly enable: (this: this, controlType?: RoamType, opt?: RoamOption) => void;\n    readonly disable: () => void;\n    constructor(zr: ZRenderType);\n    isDragging(): boolean;\n    isPinching(): boolean;\n    setPointerChecker(pointerChecker: RoamController['pointerChecker']): void;\n    dispose(): void;\n    private _mousedownHandler;\n    private _mousemoveHandler;\n    private _mouseupHandler;\n    private _mousewheelHandler;\n    private _pinchHandler;\n}\ndeclare function isAvailableBehavior(behaviorToCheck: RoamBehavior, e: ZRElementEvent, settings: Pick<RoamOption, RoamBehavior>): boolean;\nexport default RoamController;\n"
  },
  {
    "path": "echarts/types/src/component/helper/roamHelper.d.ts",
    "code": "import Element from 'zrender/esm/Element';\ninterface ControllerHost {\n    target: Element;\n    zoom?: number;\n    zoomLimit?: {\n        min?: number;\n        max?: number;\n    };\n}\nexport declare function updateViewOnPan(controllerHost: ControllerHost, dx: number, dy: number): void;\nexport declare function updateViewOnZoom(controllerHost: ControllerHost, zoomDelta: number, zoomX: number, zoomY: number): void;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/component/helper/sliderMove.d.ts",
    "code": "export default function (delta: number, handleEnds: number[], extent: number[], handleIndex: 'all' | 0 | 1, minSpan?: number, maxSpan?: number): number[];\n"
  },
  {
    "path": "echarts/types/src/component/legend.d.ts",
    "code": "import './legend/LegendModel';\nimport './legend/legendAction';\nimport './legend/LegendView';\n"
  },
  {
    "path": "echarts/types/src/component/legend/legendAction.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/legend/legendFilter.d.ts",
    "code": "import GlobalModel from '../../model/Global';\nexport default function (ecModel: GlobalModel): void;\n"
  },
  {
    "path": "echarts/types/src/component/legend/LegendModel.d.ts",
    "code": "import Model from '../../model/Model';\nimport ComponentModel from '../../model/Component';\nimport { ComponentOption, BoxLayoutOptionMixin, BorderOptionMixin, ColorString, ItemStyleOption, LabelOption, LayoutOrient, CommonTooltipOption } from '../../util/types';\nimport { Dictionary } from 'zrender/esm/core/types';\nimport GlobalModel from '../../model/Global';\ndeclare type SelectorType = 'all' | 'inverse';\nexport interface LegendSelectorButtonOption {\n    type?: SelectorType;\n    title?: string;\n}\ninterface DataItem {\n    name?: string;\n    icon?: string;\n    textStyle?: LabelOption;\n    tooltip?: unknown;\n}\nexport interface LegendTooltipFormatterParams {\n    componentType: 'legend';\n    legendIndex: number;\n    name: string;\n    $vars: ['name'];\n}\nexport interface LegendOption extends ComponentOption, BoxLayoutOptionMixin, BorderOptionMixin {\n    show?: boolean;\n    orient?: LayoutOrient;\n    align?: 'auto' | 'left' | 'right';\n    backgroundColor?: ColorString;\n    borderRadius?: number | number[];\n    padding?: number | number[];\n    itemGap?: number;\n    itemWidth?: number;\n    itemHeight?: number;\n    inactiveColor?: ColorString;\n    inactiveBorderColor?: ColorString;\n    itemStyle?: ItemStyleOption;\n    formatter?: string | ((name: string) => string);\n    textStyle?: LabelOption;\n    selectedMode?: boolean | 'single' | 'multiple';\n    selected?: Dictionary<boolean>;\n    selector?: (LegendSelectorButtonOption | SelectorType)[] | boolean;\n    selectorLabel?: LabelOption;\n    emphasis?: {\n        selectorLabel?: LabelOption;\n    };\n    selectorPosition?: 'auto' | 'start' | 'end';\n    selectorItemGap?: number;\n    selectorButtonGap?: number;\n    data?: (string | DataItem)[];\n    symbolKeepAspect?: boolean;\n    tooltip?: CommonTooltipOption<LegendTooltipFormatterParams>;\n}\ndeclare class LegendModel<Ops extends LegendOption = LegendOption> extends ComponentModel<Ops> {\n    static type: string;\n    type: string;\n    static readonly dependencies: string[];\n    readonly layoutMode: {\n        readonly type: \"box\";\n        readonly ignoreSize: true;\n    };\n    private _data;\n    private _availableNames;\n    init(option: Ops, parentModel: Model, ecModel: GlobalModel): void;\n    mergeOption(option: Ops, ecModel: GlobalModel): void;\n    _updateSelector(option: Ops): void;\n    optionUpdated(): void;\n    _updateData(ecModel: GlobalModel): void;\n    getData(): Model<DataItem>[];\n    select(name: string): void;\n    unSelect(name: string): void;\n    toggleSelected(name: string): void;\n    allSelect(): void;\n    inverseSelect(): void;\n    isSelected(name: string): boolean;\n    getOrient(): {\n        index: 0;\n        name: 'horizontal';\n    };\n    getOrient(): {\n        index: 1;\n        name: 'vertical';\n    };\n    static defaultOption: LegendOption;\n}\nexport default LegendModel;\n"
  },
  {
    "path": "echarts/types/src/component/legend/LegendView.d.ts",
    "code": "import * as graphic from '../../util/graphic';\nimport ComponentView from '../../view/Component';\nimport LegendModel, { LegendOption, LegendSelectorButtonOption } from './LegendModel';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { ZRRectLike } from '../../util/types';\ndeclare class LegendView extends ComponentView {\n    static type: string;\n    type: string;\n    newlineDisabled: boolean;\n    private _contentGroup;\n    private _backgroundEl;\n    private _selectorGroup;\n    private _isFirstRender;\n    init(): void;\n    getContentGroup(): graphic.Group;\n    getSelectorGroup(): graphic.Group;\n    render(legendModel: LegendModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    protected resetInner(): void;\n    protected renderInner(itemAlign: LegendOption['align'], legendModel: LegendModel, ecModel: GlobalModel, api: ExtensionAPI, selector: LegendSelectorButtonOption[], orient: LegendOption['orient'], selectorPosition: LegendOption['selectorPosition']): void;\n    private _createSelector;\n    private _createItem;\n    protected layoutInner(legendModel: LegendModel, itemAlign: LegendOption['align'], maxSize: {\n        width: number;\n        height: number;\n    }, isFirstRender: boolean, selector: LegendOption['selector'], selectorPosition: LegendOption['selectorPosition']): ZRRectLike;\n    remove(): void;\n}\nexport default LegendView;\n"
  },
  {
    "path": "echarts/types/src/component/legend/scrollableLegendAction.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/legend/ScrollableLegendModel.d.ts",
    "code": "import LegendModel, { LegendOption } from './LegendModel';\nimport { ZRColor, LabelOption } from '../../util/types';\nimport Model from '../../model/Model';\nimport GlobalModel from '../../model/Global';\nexport interface ScrollableLegendOption extends LegendOption {\n    scrollDataIndex?: number;\n    pageButtonItemGap?: number;\n    pageButtonGap?: number;\n    pageButtonPosition?: 'start' | 'end';\n    pageFormatter?: string | ((param: {\n        current: number;\n        total: number;\n    }) => string);\n    pageIcons?: {\n        horizontal?: string[];\n        vertical?: string[];\n    };\n    pageIconColor?: ZRColor;\n    pageIconInactiveColor?: ZRColor;\n    pageIconSize?: number;\n    pageTextStyle?: LabelOption;\n    animationDurationUpdate?: number;\n}\ndeclare class ScrollableLegendModel extends LegendModel<ScrollableLegendOption> {\n    static type: \"legend.scroll\";\n    type: \"legend.scroll\";\n    setScrollDataIndex(scrollDataIndex: number): void;\n    init(option: ScrollableLegendOption, parentModel: Model, ecModel: GlobalModel): void;\n    mergeOption(option: ScrollableLegendOption, ecModel: GlobalModel): void;\n    static defaultOption: ScrollableLegendOption;\n}\nexport default ScrollableLegendModel;\n"
  },
  {
    "path": "echarts/types/src/component/legend/ScrollableLegendView.d.ts",
    "code": "import LegendView from './LegendView';\nimport { LegendSelectorButtonOption } from './LegendModel';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport GlobalModel from '../../model/Global';\nimport ScrollableLegendModel, { ScrollableLegendOption } from './ScrollableLegendModel';\ninterface PageInfo {\n    contentPosition: number[];\n    pageCount: number;\n    pageIndex: number;\n    pagePrevDataIndex: number;\n    pageNextDataIndex: number;\n}\ndeclare class ScrollableLegendView extends LegendView {\n    static type: \"legend.scroll\";\n    type: \"legend.scroll\";\n    newlineDisabled: boolean;\n    private _containerGroup;\n    private _controllerGroup;\n    private _currentIndex;\n    private _showController;\n    init(): void;\n    resetInner(): void;\n    renderInner(itemAlign: ScrollableLegendOption['align'], legendModel: ScrollableLegendModel, ecModel: GlobalModel, api: ExtensionAPI, selector: LegendSelectorButtonOption[], orient: ScrollableLegendOption['orient'], selectorPosition: ScrollableLegendOption['selectorPosition']): void;\n    layoutInner(legendModel: ScrollableLegendModel, itemAlign: ScrollableLegendOption['align'], maxSize: {\n        width: number;\n        height: number;\n    }, isFirstRender: boolean, selector: LegendSelectorButtonOption[], selectorPosition: ScrollableLegendOption['selectorPosition']): import(\"zrender/esm/core/BoundingRect\").RectLike;\n    _layoutContentAndController(legendModel: ScrollableLegendModel, isFirstRender: boolean, maxSize: {\n        width: number;\n        height: number;\n    }, orientIdx: 0 | 1, wh: 'width' | 'height', hw: 'width' | 'height', yx: 'x' | 'y'): import(\"zrender/esm/core/BoundingRect\").RectLike;\n    _pageGo(to: 'pagePrevDataIndex' | 'pageNextDataIndex', legendModel: ScrollableLegendModel, api: ExtensionAPI): void;\n    _updatePageInfoView(legendModel: ScrollableLegendModel, pageInfo: PageInfo): void;\n    _getPageInfo(legendModel: ScrollableLegendModel): PageInfo;\n    _findTargetItemIndex(targetDataIndex: number): number;\n}\nexport default ScrollableLegendView;\n"
  },
  {
    "path": "echarts/types/src/component/legendScroll.d.ts",
    "code": "import './legend';\nimport './legend/ScrollableLegendModel';\nimport './legend/ScrollableLegendView';\nimport './legend/scrollableLegendAction';\n"
  },
  {
    "path": "echarts/types/src/component/markArea.d.ts",
    "code": "import './marker/MarkAreaModel';\nimport './marker/MarkAreaView';\n"
  },
  {
    "path": "echarts/types/src/component/marker/MarkAreaModel.d.ts",
    "code": "import MarkerModel, { MarkerOption, MarkerStatisticType, MarkerPositionOption } from './MarkerModel';\nimport { LabelOption, ItemStyleOption, StatesOptionMixin } from '../../util/types';\nimport GlobalModel from '../../model/Global';\ninterface MarkAreaStateOption {\n    itemStyle?: ItemStyleOption;\n    label?: LabelOption;\n}\ninterface MarkAreaDataItemOptionBase extends MarkAreaStateOption, StatesOptionMixin<MarkAreaStateOption> {\n    name?: string;\n}\nexport interface MarkArea1DDataItemOption extends MarkAreaDataItemOptionBase {\n    xAxis?: number;\n    yAxis?: number;\n    type?: MarkerStatisticType;\n    valueIndex?: number;\n    valueDim?: string;\n}\ninterface MarkArea2DDataItemDimOption extends MarkAreaDataItemOptionBase, MarkerPositionOption {\n}\nexport declare type MarkArea2DDataItemOption = [MarkArea2DDataItemDimOption, MarkArea2DDataItemDimOption];\nexport interface MarkAreaOption extends MarkerOption, MarkAreaStateOption, StatesOptionMixin<MarkAreaStateOption> {\n    precision?: number;\n    data?: (MarkArea1DDataItemOption | MarkArea2DDataItemOption)[];\n}\ndeclare class MarkAreaModel extends MarkerModel<MarkAreaOption> {\n    static type: string;\n    type: string;\n    createMarkerModelFromSeries(markerOpt: MarkAreaOption, masterMarkerModel: MarkAreaModel, ecModel: GlobalModel): MarkAreaModel;\n    static defaultOption: MarkAreaOption;\n}\nexport default MarkAreaModel;\n"
  },
  {
    "path": "echarts/types/src/component/marker/MarkAreaView.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/marker/markerHelper.d.ts",
    "code": "import SeriesModel from '../../model/Series';\nimport List from '../../data/List';\nimport { MarkerStatisticType, MarkerPositionOption } from './MarkerModel';\nimport Axis from '../../coord/Axis';\nimport { CoordinateSystem } from '../../coord/CoordinateSystem';\nimport { ScaleDataValue } from '../../util/types';\ninterface MarkerAxisInfo {\n    valueDataDim: string;\n    valueAxis: Axis;\n    baseAxis: Axis;\n    baseDataDim: string;\n}\nexport declare function dataTransform(seriesModel: SeriesModel, item: MarkerPositionOption): MarkerPositionOption;\nexport declare function getAxisInfo(item: MarkerPositionOption, data: List, coordSys: CoordinateSystem, seriesModel: SeriesModel): MarkerAxisInfo;\nexport declare function dataFilter(coordSys: CoordinateSystem & {\n    containData?(data: ScaleDataValue[]): boolean;\n}, item: MarkerPositionOption): boolean;\nexport declare function dimValueGetter(item: MarkerPositionOption, dimName: string, dataIndex: number, dimIndex: number): string | number;\nexport declare function numCalculate(data: List, valueDataDim: string, type: MarkerStatisticType): number;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/component/marker/MarkerModel.d.ts",
    "code": "import DataFormatMixin from '../../model/mixin/dataFormat';\nimport ComponentModel from '../../model/Component';\nimport SeriesModel from '../../model/Series';\nimport { ComponentOption, AnimationOptionMixin, CommonTooltipOption, ScaleDataValue, TooltipRenderMode } from '../../util/types';\nimport Model from '../../model/Model';\nimport GlobalModel from '../../model/Global';\nimport List from '../../data/List';\nexport declare type MarkerStatisticType = 'average' | 'min' | 'max' | 'median';\nexport interface MarkerPositionOption {\n    x?: number | string;\n    y?: number | string;\n    coord?: (ScaleDataValue | MarkerStatisticType)[];\n    xAxis?: ScaleDataValue;\n    yAxis?: ScaleDataValue;\n    radiusAxis?: ScaleDataValue;\n    angleAxis?: ScaleDataValue;\n    type?: MarkerStatisticType;\n    valueIndex?: number;\n    valueDim?: string;\n    value?: string | number;\n}\nexport interface MarkerOption extends ComponentOption, AnimationOptionMixin {\n    silent?: boolean;\n    data?: unknown[];\n    tooltip?: CommonTooltipOption<unknown> & {\n        trigger?: 'item' | 'axis' | boolean | 'none';\n    };\n}\ndeclare abstract class MarkerModel<Opts extends MarkerOption = MarkerOption> extends ComponentModel<Opts> {\n    static type: string;\n    type: string;\n    createdBySelf: boolean;\n    static readonly dependencies: string[];\n    __hostSeries: SeriesModel;\n    private _data;\n    init(option: Opts, parentModel: Model, ecModel: GlobalModel): void;\n    isAnimationEnabled(): boolean;\n    mergeOption(newOpt: Opts, ecModel: GlobalModel): void;\n    _mergeOption(newOpt: Opts, ecModel: GlobalModel, createdBySelf?: boolean, isInit?: boolean): void;\n    formatTooltip(dataIndex: number, multipleSeries: boolean, dataType: string, renderMode: TooltipRenderMode): string;\n    getData(): List<this>;\n    setData(data: List): void;\n    abstract createMarkerModelFromSeries(markerOpt: Opts, masterMarkerModel: MarkerModel, ecModel: GlobalModel): MarkerModel;\n    static getMarkerModelFromSeries(seriesModel: SeriesModel, componentType: 'markLine' | 'markPoint' | 'markArea'): MarkerModel<MarkerOption>;\n}\ninterface MarkerModel<Opts extends MarkerOption = MarkerOption> extends DataFormatMixin {\n}\nexport default MarkerModel;\n"
  },
  {
    "path": "echarts/types/src/component/marker/MarkerView.d.ts",
    "code": "import ComponentView from '../../view/Component';\nimport { HashMap } from 'zrender/esm/core/util';\nimport MarkerModel from './MarkerModel';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport SeriesModel from '../../model/Series';\nimport { Group } from 'zrender/esm/export';\ninterface MarkerDraw {\n    group: Group;\n}\ndeclare abstract class MarkerView extends ComponentView {\n    static type: string;\n    type: string;\n    markerGroupMap: HashMap<MarkerDraw>;\n    init(): void;\n    render(markerModel: MarkerModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    markKeep(drawGroup: MarkerDraw): void;\n    blurSeries(seriesModelList: SeriesModel[]): void;\n    abstract renderSeries(seriesModel: SeriesModel, markerModel: MarkerModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n}\nexport default MarkerView;\n"
  },
  {
    "path": "echarts/types/src/component/marker/MarkLineModel.d.ts",
    "code": "import MarkerModel, { MarkerOption, MarkerStatisticType, MarkerPositionOption } from './MarkerModel';\nimport GlobalModel from '../../model/Global';\nimport { LineStyleOption, LineLabelOption, SymbolOptionMixin, ItemStyleOption, StatesOptionMixin } from '../../util/types';\ninterface MarkLineStateOption {\n    lineStyle?: LineStyleOption;\n    itemStyle?: ItemStyleOption;\n    label?: LineLabelOption;\n}\ninterface MarkLineDataItemOptionBase extends MarkLineStateOption, StatesOptionMixin<MarkLineStateOption> {\n    name?: string;\n}\nexport interface MarkLine1DDataItemOption extends MarkLineDataItemOptionBase {\n    xAxis?: number;\n    yAxis?: number;\n    type?: MarkerStatisticType;\n    valueIndex?: number;\n    valueDim?: string;\n    symbol?: string[] | string;\n    symbolSize?: number[] | number;\n}\ninterface MarkLine2DDataItemDimOption extends MarkLineDataItemOptionBase, SymbolOptionMixin, MarkerPositionOption {\n}\nexport declare type MarkLine2DDataItemOption = [MarkLine2DDataItemDimOption, MarkLine2DDataItemDimOption];\nexport interface MarkLineOption extends MarkerOption, MarkLineStateOption, StatesOptionMixin<MarkLineStateOption> {\n    symbol?: string[] | string;\n    symbolSize?: number[] | number;\n    precision?: number;\n    data?: (MarkLine1DDataItemOption | MarkLine2DDataItemOption)[];\n}\ndeclare class MarkLineModel extends MarkerModel<MarkLineOption> {\n    static type: string;\n    type: string;\n    createMarkerModelFromSeries(markerOpt: MarkLineOption, masterMarkerModel: MarkLineModel, ecModel: GlobalModel): MarkLineModel;\n    static defaultOption: MarkLineOption;\n}\nexport default MarkLineModel;\n"
  },
  {
    "path": "echarts/types/src/component/marker/MarkLineView.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/marker/MarkPointModel.d.ts",
    "code": "import MarkerModel, { MarkerOption, MarkerPositionOption } from './MarkerModel';\nimport GlobalModel from '../../model/Global';\nimport { SymbolOptionMixin, ItemStyleOption, LabelOption, CallbackDataParams, StatesOptionMixin } from '../../util/types';\ninterface MarkPointStateOption {\n    itemStyle?: ItemStyleOption;\n    label?: LabelOption;\n}\nexport interface MarkPointDataItemOption extends MarkPointStateOption, StatesOptionMixin<MarkPointStateOption>, SymbolOptionMixin<CallbackDataParams>, MarkerPositionOption {\n    name: string;\n}\nexport interface MarkPointOption extends MarkerOption, SymbolOptionMixin<CallbackDataParams>, StatesOptionMixin<MarkPointStateOption>, MarkPointStateOption {\n    precision?: number;\n    data?: MarkPointDataItemOption[];\n}\ndeclare class MarkPointModel extends MarkerModel<MarkPointOption> {\n    static type: string;\n    type: string;\n    createMarkerModelFromSeries(markerOpt: MarkPointOption, masterMarkerModel: MarkPointModel, ecModel: GlobalModel): MarkPointModel;\n    static defaultOption: MarkPointOption;\n}\nexport default MarkPointModel;\n"
  },
  {
    "path": "echarts/types/src/component/marker/MarkPointView.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/markLine.d.ts",
    "code": "import './marker/MarkLineModel';\nimport './marker/MarkLineView';\n"
  },
  {
    "path": "echarts/types/src/component/markPoint.d.ts",
    "code": "import './marker/MarkPointModel';\nimport './marker/MarkPointView';\n"
  },
  {
    "path": "echarts/types/src/component/parallel.d.ts",
    "code": "import '../coord/parallel/parallelCreator';\nimport './parallelAxis';\nimport '../coord/parallel/ParallelModel';\n"
  },
  {
    "path": "echarts/types/src/component/parallelAxis.d.ts",
    "code": "import '../coord/parallel/parallelCreator';\nimport '../coord/parallel/AxisModel';\nimport '../coord/parallel/ParallelModel';\nimport './axis/parallelAxisAction';\nimport './axis/ParallelAxisView';\n"
  },
  {
    "path": "echarts/types/src/component/polar.d.ts",
    "code": "import '../coord/polar/PolarModel';\nimport '../coord/polar/AxisModel';\nimport '../coord/polar/polarCreator';\nimport './angleAxis';\nimport './radiusAxis';\nimport './axisPointer';\nimport './axisPointer/PolarAxisPointer';\n"
  },
  {
    "path": "echarts/types/src/component/radar.d.ts",
    "code": "import '../coord/radar/Radar';\nimport '../coord/radar/RadarModel';\nimport './radar/RadarView';\n"
  },
  {
    "path": "echarts/types/src/component/radar/RadarView.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/radiusAxis.d.ts",
    "code": "import '../coord/polar/polarCreator';\nimport './axis/RadiusAxisView';\n"
  },
  {
    "path": "echarts/types/src/component/singleAxis.d.ts",
    "code": "import '../coord/single/singleCreator';\nimport './axis/SingleAxisView';\nimport '../coord/single/AxisModel';\nimport './axisPointer';\nimport './axisPointer/SingleAxisPointer';\n"
  },
  {
    "path": "echarts/types/src/component/timeline.d.ts",
    "code": "import './timeline/typeDefaulter';\nimport './timeline/timelineAction';\nimport './timeline/SliderTimelineModel';\nimport './timeline/SliderTimelineView';\n"
  },
  {
    "path": "echarts/types/src/component/timeline/preprocessor.d.ts",
    "code": "export default function (option: any): void;\n"
  },
  {
    "path": "echarts/types/src/component/timeline/SliderTimelineModel.d.ts",
    "code": "import TimelineModel, { TimelineOption } from './TimelineModel';\nimport DataFormatMixin from '../../model/mixin/dataFormat';\nimport List from '../../data/List';\nexport interface SliderTimelineOption extends TimelineOption {\n}\ndeclare class SliderTimelineModel extends TimelineModel {\n    static type: string;\n    type: string;\n    static defaultOption: SliderTimelineOption;\n}\ninterface SliderTimelineModel extends DataFormatMixin {\n    getData(): List<SliderTimelineModel>;\n}\nexport default SliderTimelineModel;\n"
  },
  {
    "path": "echarts/types/src/component/timeline/SliderTimelineView.d.ts",
    "code": "import TimelineView from './TimelineView';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport SliderTimelineModel from './SliderTimelineModel';\ndeclare class SliderTimelineView extends TimelineView {\n    static type: string;\n    type: string;\n    api: ExtensionAPI;\n    model: SliderTimelineModel;\n    ecModel: GlobalModel;\n    private _axis;\n    private _viewRect;\n    private _timer;\n    private _currentPointer;\n    private _progressLine;\n    private _mainGroup;\n    private _labelGroup;\n    private _tickSymbols;\n    private _tickLabels;\n    init(ecModel: GlobalModel, api: ExtensionAPI): void;\n    render(timelineModel: SliderTimelineModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    remove(): void;\n    dispose(): void;\n    private _layout;\n    private _position;\n    private _createAxis;\n    private _createGroup;\n    private _renderAxisLine;\n    private _renderAxisTick;\n    private _renderAxisLabel;\n    private _renderControl;\n    private _renderCurrentPointer;\n    private _handlePlayClick;\n    private _handlePointerDrag;\n    private _handlePointerDragend;\n    private _pointerChangeTimeline;\n    private _doPlayStop;\n    private _toAxisCoord;\n    private _findNearestTick;\n    private _clearTimer;\n    private _changeTimeline;\n    private _updateTicksStatus;\n}\nexport default SliderTimelineView;\n"
  },
  {
    "path": "echarts/types/src/component/timeline/timelineAction.d.ts",
    "code": "import { Payload } from '../../util/types';\nexport interface TimelineChangePayload extends Payload {\n    type: 'timelineChange';\n    currentIndex: number;\n}\nexport interface TimelinePlayChangePayload extends Payload {\n    type: 'timelinePlayChange';\n    playState: boolean;\n}\n"
  },
  {
    "path": "echarts/types/src/component/timeline/TimelineAxis.d.ts",
    "code": "import Axis from '../../coord/Axis';\nimport Scale from '../../scale/Scale';\nimport TimelineModel from './TimelineModel';\nimport { LabelOption } from '../../util/types';\nimport Model from '../../model/Model';\ndeclare class TimelineAxis extends Axis {\n    type: 'category' | 'time' | 'value';\n    model: TimelineModel;\n    constructor(dim: string, scale: Scale, coordExtent: [number, number], axisType: 'category' | 'time' | 'value');\n    getLabelModel(): Model<LabelOption>;\n    isHorizontal(): boolean;\n}\nexport default TimelineAxis;\n"
  },
  {
    "path": "echarts/types/src/component/timeline/TimelineModel.d.ts",
    "code": "import ComponentModel from '../../model/Component';\nimport List from '../../data/List';\nimport { ComponentOption, BoxLayoutOptionMixin, LayoutOrient, SymbolOptionMixin, LineStyleOption, ItemStyleOption, LabelOption, OptionDataValue, ZRColor, ColorString, CommonTooltipOption, CallbackDataParams, ZREasing } from '../../util/types';\nimport Model from '../../model/Model';\nimport GlobalModel, { GlobalModelSetOptionOpts } from '../../model/Global';\nexport interface TimelineControlStyle extends ItemStyleOption {\n    show?: boolean;\n    showPlayBtn?: boolean;\n    showPrevBtn?: boolean;\n    showNextBtn?: boolean;\n    itemSize?: number;\n    itemGap?: number;\n    position?: 'left' | 'right' | 'top' | 'bottom';\n    playIcon?: string;\n    stopIcon?: string;\n    prevIcon?: string;\n    nextIcon?: string;\n    playBtnSize?: number | string;\n    stopBtnSize?: number | string;\n    nextBtnSize?: number | string;\n    prevBtnSize?: number | string;\n}\nexport interface TimelineCheckpointStyle extends ItemStyleOption, SymbolOptionMixin {\n    animation?: boolean;\n    animationDuration?: number;\n    animationEasing?: ZREasing;\n}\ninterface TimelineLineStyleOption extends LineStyleOption {\n    show?: boolean;\n}\ninterface TimelineLabelOption extends Omit<LabelOption, 'position'> {\n    show?: boolean;\n    position?: 'auto' | 'left' | 'right' | 'top' | 'bottom' | number;\n    interval?: 'auto' | number;\n}\nexport interface TimelineDataItemOption extends SymbolOptionMixin {\n    value?: OptionDataValue;\n    itemStyle?: ItemStyleOption;\n    label?: TimelineLabelOption;\n    checkpointStyle?: TimelineCheckpointStyle;\n    emphasis?: {\n        itemStyle?: ItemStyleOption;\n        label?: TimelineLabelOption;\n        checkpointStyle?: TimelineCheckpointStyle;\n    };\n    progress?: {\n        lineStyle?: TimelineLineStyleOption;\n        itemStyle?: ItemStyleOption;\n        label?: TimelineLabelOption;\n    };\n    tooltip?: boolean;\n}\nexport interface TimelineOption extends ComponentOption, BoxLayoutOptionMixin, SymbolOptionMixin {\n    backgroundColor?: ZRColor;\n    borderColor?: ColorString;\n    borderWidth?: number;\n    tooltip?: CommonTooltipOption<CallbackDataParams> & {\n        trigger?: 'item';\n    };\n    show?: boolean;\n    axisType?: 'category' | 'time' | 'value';\n    currentIndex?: number;\n    autoPlay?: boolean;\n    rewind?: boolean;\n    loop?: boolean;\n    playInterval?: number;\n    realtime?: boolean;\n    controlPosition?: 'left' | 'right' | 'top' | 'bottom';\n    padding?: number | number[];\n    orient?: LayoutOrient;\n    inverse?: boolean;\n    replaceMerge?: GlobalModelSetOptionOpts['replaceMerge'];\n    lineStyle?: TimelineLineStyleOption;\n    itemStyle?: ItemStyleOption;\n    checkpointStyle?: TimelineCheckpointStyle;\n    controlStyle?: TimelineControlStyle;\n    label?: TimelineLabelOption;\n    emphasis?: {\n        lineStyle?: TimelineLineStyleOption;\n        itemStyle?: ItemStyleOption;\n        checkpointStyle?: TimelineCheckpointStyle;\n        controlStyle?: TimelineControlStyle;\n        label?: TimelineLabelOption;\n    };\n    progress?: {\n        lineStyle?: TimelineLineStyleOption;\n        itemStyle?: ItemStyleOption;\n        label?: TimelineLabelOption;\n    };\n    data?: (OptionDataValue | TimelineDataItemOption)[];\n}\ndeclare class TimelineModel extends ComponentModel<TimelineOption> {\n    static type: string;\n    type: string;\n    layoutMode: string;\n    private _data;\n    private _names;\n    init(option: TimelineOption, parentModel: Model, ecModel: GlobalModel): void;\n    mergeOption(option: TimelineOption): void;\n    setCurrentIndex(currentIndex: number): void;\n    getCurrentIndex(): number;\n    isIndexMax(): boolean;\n    setPlayState(state: boolean): void;\n    getPlayState(): boolean;\n    _initData(): void;\n    getData(): List<TimelineModel, import(\"../../data/List\").DefaultDataVisual>;\n    getCategories(): string[];\n    static defaultOption: TimelineOption;\n}\nexport default TimelineModel;\n"
  },
  {
    "path": "echarts/types/src/component/timeline/TimelineView.d.ts",
    "code": "import ComponentView from '../../view/Component';\ndeclare class TimelineView extends ComponentView {\n    static type: string;\n    type: string;\n}\nexport default TimelineView;\n"
  },
  {
    "path": "echarts/types/src/component/timeline/typeDefaulter.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/title.d.ts",
    "code": "import { ComponentOption, BoxLayoutOptionMixin, ZRTextAlign, ZRTextVerticalAlign, ZRColor, BorderOptionMixin, LabelOption } from '../util/types';\nexport interface TitleOption extends ComponentOption, BoxLayoutOptionMixin, BorderOptionMixin {\n    show?: boolean;\n    type?: 'title';\n    text?: string;\n    link?: string;\n    target?: 'self' | 'blank';\n    subtext?: string;\n    sublink?: string;\n    subtarget?: 'self' | 'blank';\n    textAlign?: ZRTextAlign;\n    textVerticalAlign?: ZRTextVerticalAlign;\n    textBaseline?: ZRTextVerticalAlign;\n    backgroundColor?: ZRColor;\n    padding?: number | number[];\n    itemGap?: number;\n    textStyle?: LabelOption;\n    subtextStyle?: LabelOption;\n    triggerEvent?: boolean;\n    borderRadius?: number | number[];\n}\n"
  },
  {
    "path": "echarts/types/src/component/toolbox.d.ts",
    "code": "import './toolbox/ToolboxModel';\nimport './toolbox/ToolboxView';\nimport './toolbox/feature/SaveAsImage';\nimport './toolbox/feature/MagicType';\nimport './toolbox/feature/DataView';\nimport './toolbox/feature/DataZoom';\nimport './toolbox/feature/Restore';\n"
  },
  {
    "path": "echarts/types/src/component/toolbox/feature/Brush.d.ts",
    "code": "import { ToolboxFeatureModel, ToolboxFeatureOption, ToolboxFeature } from '../featureManager';\nimport GlobalModel from '../../../model/Global';\nimport ExtensionAPI from '../../../ExtensionAPI';\ndeclare const ICON_TYPES: readonly [\"rect\", \"polygon\", \"lineX\", \"lineY\", \"keep\", \"clear\"];\ndeclare type IconType = typeof ICON_TYPES[number];\nexport interface ToolboxBrushFeatureOption extends ToolboxFeatureOption {\n    type?: IconType[];\n    icon?: {\n        [key in IconType]?: string;\n    };\n    title?: {\n        [key in IconType]?: string;\n    };\n}\ndeclare class BrushFeature extends ToolboxFeature<ToolboxBrushFeatureOption> {\n    private _brushType;\n    private _brushMode;\n    render(featureModel: ToolboxFeatureModel<ToolboxBrushFeatureOption>, ecModel: GlobalModel, api: ExtensionAPI): void;\n    updateView(featureModel: ToolboxFeatureModel<ToolboxBrushFeatureOption>, ecModel: GlobalModel, api: ExtensionAPI): void;\n    getIcons(): {\n        polygon?: string;\n        rect?: string;\n        clear?: string;\n        lineX?: string;\n        lineY?: string;\n        keep?: string;\n    };\n    onclick(ecModel: GlobalModel, api: ExtensionAPI, type: IconType): void;\n    static getDefaultOption(ecModel: GlobalModel): ToolboxBrushFeatureOption;\n}\nexport default BrushFeature;\n"
  },
  {
    "path": "echarts/types/src/component/toolbox/feature/DataView.d.ts",
    "code": "import GlobalModel from '../../../model/Global';\nimport { ToolboxFeature, ToolboxFeatureOption } from '../featureManager';\nimport { ColorString, ECUnitOption } from '../../../util/types';\nimport ExtensionAPI from '../../../ExtensionAPI';\ninterface ToolboxDataViewFeatureOption extends ToolboxFeatureOption {\n    readOnly?: boolean;\n    optionToContent?: (option: ECUnitOption) => string | HTMLElement;\n    contentToOption?: (viewMain: HTMLDivElement, oldOption: ECUnitOption) => ECUnitOption;\n    icon?: string;\n    title?: string;\n    lang?: string[];\n    backgroundColor?: ColorString;\n    textColor?: ColorString;\n    textareaColor?: ColorString;\n    textareaBorderColor?: ColorString;\n    buttonColor?: ColorString;\n    buttonTextColor?: ColorString;\n}\ndeclare class DataView extends ToolboxFeature<ToolboxDataViewFeatureOption> {\n    private _dom;\n    onclick(ecModel: GlobalModel, api: ExtensionAPI): void;\n    remove(ecModel: GlobalModel, api: ExtensionAPI): void;\n    dispose(ecModel: GlobalModel, api: ExtensionAPI): void;\n    static getDefaultOption(ecModel: GlobalModel): ToolboxDataViewFeatureOption;\n}\nexport default DataView;\n"
  },
  {
    "path": "echarts/types/src/component/toolbox/feature/DataZoom.d.ts",
    "code": "import BrushController from '../../helper/BrushController';\nimport * as history from '../../dataZoom/history';\nimport '../../dataZoomSelect';\nimport { ToolboxFeature, ToolboxFeatureModel, ToolboxFeatureOption } from '../featureManager';\nimport GlobalModel from '../../../model/Global';\nimport ExtensionAPI from '../../../ExtensionAPI';\nimport { Payload } from '../../../util/types';\nimport { ModelFinderIndexQuery, ModelFinderIdQuery } from '../../../util/model';\ndeclare const ICON_TYPES: readonly [\"zoom\", \"back\"];\ndeclare type IconType = typeof ICON_TYPES[number];\ninterface ToolboxDataZoomFeatureOption extends ToolboxFeatureOption {\n    type?: IconType[];\n    icon?: {\n        [key in IconType]?: string;\n    };\n    title?: {\n        [key in IconType]?: string;\n    };\n    filterMode?: 'filter' | 'weakFilter' | 'empty' | 'none';\n    xAxisIndex?: ModelFinderIndexQuery;\n    yAxisIndex?: ModelFinderIndexQuery;\n    xAxisId?: ModelFinderIdQuery;\n    yAxisId?: ModelFinderIdQuery;\n}\ndeclare type ToolboxDataZoomFeatureModel = ToolboxFeatureModel<ToolboxDataZoomFeatureOption>;\ndeclare class DataZoomFeature extends ToolboxFeature<ToolboxDataZoomFeatureOption> {\n    brushController: BrushController;\n    isZoomActive: boolean;\n    render(featureModel: ToolboxDataZoomFeatureModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    onclick(ecModel: GlobalModel, api: ExtensionAPI, type: IconType): void;\n    remove(ecModel: GlobalModel, api: ExtensionAPI): void;\n    dispose(ecModel: GlobalModel, api: ExtensionAPI): void;\n    private _onBrush;\n    _dispatchZoomAction(snapshot: history.DataZoomStoreSnapshot): void;\n    static getDefaultOption(ecModel: GlobalModel): ToolboxDataZoomFeatureOption;\n}\nexport default DataZoomFeature;\n"
  },
  {
    "path": "echarts/types/src/component/toolbox/feature/MagicType.d.ts",
    "code": "import { ToolboxFeature, ToolboxFeatureOption } from '../featureManager';\nimport { SeriesOption } from '../../../util/types';\nimport GlobalModel from '../../../model/Global';\nimport ExtensionAPI from '../../../ExtensionAPI';\ndeclare const ICON_TYPES: readonly [\"line\", \"bar\", \"stack\"];\ndeclare type IconType = typeof ICON_TYPES[number];\nexport interface ToolboxMagicTypeFeatureOption extends ToolboxFeatureOption {\n    type?: IconType[];\n    icon?: {\n        [key in IconType]?: string;\n    };\n    title?: {\n        [key in IconType]?: string;\n    };\n    option?: {\n        [key in IconType]?: SeriesOption;\n    };\n    seriesIndex?: {\n        line?: number;\n        bar?: number;\n    };\n}\ndeclare class MagicType extends ToolboxFeature<ToolboxMagicTypeFeatureOption> {\n    getIcons(): {\n        line?: string;\n        stack?: string;\n        bar?: string;\n    };\n    static getDefaultOption(ecModel: GlobalModel): ToolboxMagicTypeFeatureOption;\n    onclick(ecModel: GlobalModel, api: ExtensionAPI, type: IconType): void;\n}\nexport default MagicType;\n"
  },
  {
    "path": "echarts/types/src/component/toolbox/feature/Restore.d.ts",
    "code": "import { ToolboxFeatureOption } from '../featureManager';\nexport interface ToolboxRestoreFeatureOption extends ToolboxFeatureOption {\n    icon?: string;\n    title?: string;\n}\n"
  },
  {
    "path": "echarts/types/src/component/toolbox/feature/SaveAsImage.d.ts",
    "code": "import { ToolboxFeature, ToolboxFeatureOption } from '../featureManager';\nimport { ZRColor } from '../../../util/types';\nimport GlobalModel from '../../../model/Global';\nimport ExtensionAPI from '../../../ExtensionAPI';\nexport interface ToolboxSaveAsImageFeatureOption extends ToolboxFeatureOption {\n    icon?: string;\n    title?: string;\n    type?: 'png' | 'jpg';\n    backgroundColor?: ZRColor;\n    connectedBackgroundColor?: ZRColor;\n    name?: string;\n    excludeComponents?: string[];\n    pixelRatio?: number;\n    lang?: string[];\n}\ndeclare class SaveAsImage extends ToolboxFeature<ToolboxSaveAsImageFeatureOption> {\n    onclick(ecModel: GlobalModel, api: ExtensionAPI): void;\n    static getDefaultOption(ecModel: GlobalModel): ToolboxSaveAsImageFeatureOption;\n}\nexport default SaveAsImage;\n"
  },
  {
    "path": "echarts/types/src/component/toolbox/featureManager.d.ts",
    "code": "import { Dictionary, DisplayState, ZRElementEvent, ItemStyleOption, LabelOption } from '../../util/types';\nimport Model from '../../model/Model';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport Displayable from 'zrender/esm/graphic/Displayable';\ndeclare type IconStyle = ItemStyleOption & {\n    textFill?: LabelOption['color'];\n    textBackgroundColor?: LabelOption['backgroundColor'];\n    textPosition?: LabelOption['position'];\n    textAlign?: LabelOption['align'];\n    textBorderRadius?: LabelOption['borderRadius'];\n    textPadding?: LabelOption['padding'];\n};\nexport interface ToolboxFeatureOption {\n    show?: boolean;\n    title?: string | Dictionary<string>;\n    icon?: string | Dictionary<string>;\n    iconStyle?: IconStyle;\n    emphasis?: {\n        iconStyle?: IconStyle;\n    };\n    iconStatus?: Dictionary<DisplayState>;\n    onclick?: (ecModel: GlobalModel, api: ExtensionAPI, type: string, event: ZRElementEvent) => void;\n}\nexport interface ToolboxFeatureModel<Opts extends ToolboxFeatureOption = ToolboxFeatureOption> extends Model<Opts> {\n    iconPaths: Dictionary<Displayable>;\n    setIconStatus(iconName: string, status: DisplayState): void;\n}\ninterface ToolboxFeature<Opts extends ToolboxFeatureOption = ToolboxFeatureOption> {\n    getIcons?(): Dictionary<string>;\n    onclick(ecModel: GlobalModel, api: ExtensionAPI, type: string, event: ZRElementEvent): void;\n    dispose?(ecModel: GlobalModel, api: ExtensionAPI): void;\n    remove?(ecModel: GlobalModel, api: ExtensionAPI): void;\n    render(featureModel: ToolboxFeatureModel, model: GlobalModel, api: ExtensionAPI, payload: unknown): void;\n    updateView?(featureModel: ToolboxFeatureModel, model: GlobalModel, api: ExtensionAPI, payload: unknown): void;\n}\ndeclare abstract class ToolboxFeature<Opts extends ToolboxFeatureOption = ToolboxFeatureOption> {\n    uid: string;\n    model: ToolboxFeatureModel<Opts>;\n    ecModel: GlobalModel;\n    api: ExtensionAPI;\n    unusable?: boolean;\n}\nexport { ToolboxFeature };\nexport interface UserDefinedToolboxFeature {\n    uid: string;\n    model: ToolboxFeatureModel;\n    ecModel: GlobalModel;\n    api: ExtensionAPI;\n    featureName?: string;\n    onclick(ecModel: GlobalModel, api: ExtensionAPI, type: string, event: ZRElementEvent): void;\n}\ndeclare type ToolboxFeatureCtor = {\n    new (): ToolboxFeature;\n    defaultOption?: ToolboxFeatureOption;\n    getDefaultOption?: (ecModel: GlobalModel) => ToolboxFeatureOption;\n};\nexport declare function registerFeature(name: string, ctor: ToolboxFeatureCtor): void;\nexport declare function getFeature(name: string): ToolboxFeatureCtor;\n"
  },
  {
    "path": "echarts/types/src/component/toolbox/ToolboxModel.d.ts",
    "code": "import * as featureManager from './featureManager';\nimport ComponentModel from '../../model/Component';\nimport { ComponentOption, BoxLayoutOptionMixin, LayoutOrient, ZRColor, BorderOptionMixin, ItemStyleOption, LabelOption, CommonTooltipOption, Dictionary } from '../../util/types';\nexport interface ToolboxTooltipFormatterParams {\n    componentType: 'toolbox';\n    name: string;\n    title: string;\n    $vars: ['name', 'title'];\n}\nexport interface ToolboxOption extends ComponentOption, BoxLayoutOptionMixin, BorderOptionMixin {\n    show?: boolean;\n    orient?: LayoutOrient;\n    backgroundColor?: ZRColor;\n    borderRadius?: number | number[];\n    padding?: number | number[];\n    itemSize?: number;\n    itemGap?: number;\n    showTitle?: boolean;\n    iconStyle?: ItemStyleOption;\n    emphasis?: {\n        iconStyle?: ItemStyleOption;\n    };\n    textStyle?: LabelOption;\n    tooltip?: CommonTooltipOption<ToolboxTooltipFormatterParams>;\n    feature?: Dictionary<featureManager.ToolboxFeatureOption>;\n}\ndeclare class ToolboxModel extends ComponentModel<ToolboxOption> {\n    static type: \"toolbox\";\n    type: \"toolbox\";\n    static layoutMode: {\n        readonly type: \"box\";\n        readonly ignoreSize: true;\n    };\n    optionUpdated(): void;\n    static defaultOption: ToolboxOption;\n}\nexport default ToolboxModel;\n"
  },
  {
    "path": "echarts/types/src/component/toolbox/ToolboxView.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/tooltip.d.ts",
    "code": "import './axisPointer';\nimport './tooltip/TooltipModel';\nimport './tooltip/TooltipView';\n"
  },
  {
    "path": "echarts/types/src/component/tooltip/TooltipHTMLContent.d.ts",
    "code": "import ExtensionAPI from '../../ExtensionAPI';\nimport { TooltipOption } from './TooltipModel';\nimport Model from '../../model/Model';\nimport { Dictionary } from 'zrender/esm/core/types';\nimport { ColorString, ZRColor } from '../../util/types';\ninterface TooltipContentOption {\n    appendToBody: boolean;\n}\ndeclare class TooltipHTMLContent {\n    el: HTMLDivElement;\n    private _container;\n    private _show;\n    private _styleCoord;\n    private _appendToBody;\n    private _enterable;\n    private _zr;\n    private _hideTimeout;\n    private _hideDelay;\n    private _inContent;\n    private _firstShow;\n    constructor(container: HTMLElement, api: ExtensionAPI, opt: TooltipContentOption);\n    update(): void;\n    show(tooltipModel: Model<TooltipOption>, nearPointColor: ZRColor): void;\n    setContent(content: string, markers: Dictionary<ColorString>, tooltipModel: Model<TooltipOption>, borderColor?: ZRColor, arrowPosition?: TooltipOption['position']): void;\n    setEnterable(enterable: boolean): void;\n    getSize(): number[];\n    moveTo(zrX: number, zrY: number): void;\n    hide(): void;\n    hideLater(time?: number): void;\n    isShow(): boolean;\n    dispose(): void;\n    getOuterSize(): {\n        width: number;\n        height: number;\n    };\n}\nexport default TooltipHTMLContent;\n"
  },
  {
    "path": "echarts/types/src/component/tooltip/TooltipModel.d.ts",
    "code": "import ComponentModel from '../../model/Component';\nimport { ComponentOption, LabelOption, LineStyleOption, CommonTooltipOption, TooltipRenderMode, CallbackDataParams, TooltipOrderMode } from '../../util/types';\nimport { AxisPointerOption } from '../axisPointer/AxisPointerModel';\ndeclare type TopLevelFormatterParams = CallbackDataParams | CallbackDataParams[];\nexport interface TooltipOption extends CommonTooltipOption<TopLevelFormatterParams>, ComponentOption {\n    axisPointer?: AxisPointerOption & {\n        axis?: 'auto' | 'x' | 'y' | 'angle' | 'radius';\n        crossStyle?: LineStyleOption & {\n            textStyle?: LabelOption;\n        };\n    };\n    showContent?: boolean;\n    trigger?: 'item' | 'axis' | 'none';\n    displayMode?: 'single' | 'multipleByCoordSys';\n    renderMode?: 'auto' | TooltipRenderMode;\n    appendToBody?: boolean;\n    order?: TooltipOrderMode;\n}\ndeclare class TooltipModel extends ComponentModel<TooltipOption> {\n    static type: \"tooltip\";\n    type: \"tooltip\";\n    static dependencies: string[];\n    static defaultOption: TooltipOption;\n}\nexport default TooltipModel;\n"
  },
  {
    "path": "echarts/types/src/component/tooltip/TooltipRichContent.d.ts",
    "code": "import ExtensionAPI from '../../ExtensionAPI';\nimport { TooltipOption } from './TooltipModel';\nimport { Dictionary } from 'zrender/esm/core/types';\nimport { ColorString, ZRColor } from '../../util/types';\nimport Model from '../../model/Model';\nimport ZRText from 'zrender/esm/graphic/Text';\ndeclare class TooltipRichContent {\n    private _zr;\n    private _show;\n    private _hideTimeout;\n    private _enterable;\n    private _inContent;\n    private _hideDelay;\n    el: ZRText;\n    constructor(api: ExtensionAPI);\n    update(): void;\n    show(): void;\n    setContent(content: string, markerRich: Dictionary<ColorString>, tooltipModel: Model<TooltipOption>, borderColor: ZRColor, arrowPosition: TooltipOption['position']): void;\n    setEnterable(enterable?: boolean): void;\n    getSize(): number[];\n    moveTo(x: number, y: number): void;\n    hide(): void;\n    hideLater(time?: number): void;\n    isShow(): boolean;\n    getOuterSize(): {\n        width: number;\n        height: number;\n    };\n    dispose(): void;\n}\nexport default TooltipRichContent;\n"
  },
  {
    "path": "echarts/types/src/component/tooltip/TooltipView.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/transform.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/transform/filterTransform.d.ts",
    "code": "import { DataTransformOption, ExternalDataTransform } from '../../data/helper/transform';\nimport { ConditionalExpressionOption } from '../../util/conditionalExpression';\nexport interface FilterTransformOption extends DataTransformOption {\n    type: 'filter';\n    config: ConditionalExpressionOption;\n}\nexport declare const filterTransform: ExternalDataTransform<FilterTransformOption>;\n"
  },
  {
    "path": "echarts/types/src/component/transform/sortTransform.d.ts",
    "code": "import { DataTransformOption, ExternalDataTransform } from '../../data/helper/transform';\nimport { DimensionLoose } from '../../util/types';\nexport interface SortTransformOption extends DataTransformOption {\n    type: 'sort';\n    config: OrderExpression | OrderExpression[];\n}\ndeclare type OrderExpression = {\n    dimension: DimensionLoose;\n    order: SortOrder;\n    parse?: 'time';\n};\ndeclare type SortOrder = 'asc' | 'desc';\nexport declare const sortTransform: ExternalDataTransform<SortTransformOption>;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/component/visualMap.d.ts",
    "code": "import './visualMapContinuous';\nimport './visualMapPiecewise';\n"
  },
  {
    "path": "echarts/types/src/component/visualMap/ContinuousModel.d.ts",
    "code": "import VisualMapModel, { VisualMapOption } from './VisualMapModel';\nimport { ItemStyleOption } from '../../util/types';\ndeclare type VisualState = VisualMapModel['stateList'][number];\nexport interface ContinousVisualMapOption extends VisualMapOption {\n    align?: 'auto' | 'left' | 'right' | 'top' | 'bottom';\n    calculable?: boolean;\n    range?: number[];\n    hoverLink?: boolean;\n    hoverLinkDataSize?: number;\n    hoverLinkOnHandle?: boolean;\n    handleIcon?: string;\n    handleSize?: string | number;\n    handleStyle?: ItemStyleOption;\n    indicatorIcon?: string;\n    indicatorSize?: string | number;\n    indicatorStyle?: ItemStyleOption;\n    emphasis?: {\n        handleStyle?: ItemStyleOption;\n    };\n}\ndeclare class ContinuousModel extends VisualMapModel<ContinousVisualMapOption> {\n    static type: \"visualMap.continuous\";\n    type: \"visualMap.continuous\";\n    optionUpdated(newOption: ContinousVisualMapOption, isInit: boolean): void;\n    resetItemSize(): void;\n    _resetRange(): void;\n    completeVisualOption(): void;\n    setSelected(selected: number[]): void;\n    getSelected(): [number, number];\n    getValueState(value: number): VisualState;\n    findTargetDataIndices(range: number[]): {\n        seriesId: string;\n        dataIndex: number[];\n    }[];\n    getVisualMeta(getColorVisual: (value: number, valueState: VisualState) => string): {\n        stops: {\n            value: number;\n            color: string;\n        }[];\n        outerColors: string[];\n    };\n    static defaultOption: ContinousVisualMapOption;\n}\nexport default ContinuousModel;\n"
  },
  {
    "path": "echarts/types/src/component/visualMap/ContinuousView.d.ts",
    "code": "import VisualMapView from './VisualMapView';\nimport ContinuousModel from './ContinuousModel';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\ndeclare class ContinuousView extends VisualMapView {\n    static type: string;\n    type: string;\n    visualMapModel: ContinuousModel;\n    private _shapes;\n    private _dataInterval;\n    private _handleEnds;\n    private _orient;\n    private _useHandle;\n    private _hoverLinkDataIndices;\n    private _dragging;\n    private _hovering;\n    private _firstShowIndicator;\n    private _api;\n    doRender(visualMapModel: ContinuousModel, ecModel: GlobalModel, api: ExtensionAPI, payload: {\n        type: string;\n        from: string;\n    }): void;\n    private _buildView;\n    private _renderEndsText;\n    private _renderBar;\n    private _createHandle;\n    private _createIndicator;\n    private _dragHandle;\n    private _resetInterval;\n    private _updateInterval;\n    private _updateView;\n    private _createBarVisual;\n    private _makeColorGradient;\n    private _createBarPoints;\n    private _createBarGroup;\n    private _updateHandle;\n    private _showIndicator;\n    private _enableHoverLinkToSeries;\n    private _enableHoverLinkFromSeries;\n    private _doHoverLinkToSeries;\n    private _hoverLinkFromSeriesMouseOver;\n    private _hideIndicator;\n    private _clearHoverLinkToSeries;\n    private _clearHoverLinkFromSeries;\n    private _applyTransform;\n    private _dispatchHighDown;\n    dispose(): void;\n    remove(): void;\n}\nexport default ContinuousView;\n"
  },
  {
    "path": "echarts/types/src/component/visualMap/helper.d.ts",
    "code": "import VisualMapModel from './VisualMapModel';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { Payload } from '../../util/types';\ndeclare const paramsSet: readonly [readonly [\"left\", \"right\", \"width\"], readonly [\"top\", \"bottom\", \"height\"]];\nexport declare type ItemHorizontalAlign = typeof paramsSet[0][number];\nexport declare type ItemVerticalAlign = typeof paramsSet[1][number];\nexport declare type ItemAlign = ItemVerticalAlign | ItemHorizontalAlign;\nexport declare function getItemAlign(visualMapModel: VisualMapModel, api: ExtensionAPI, itemSize: number[]): ItemAlign;\nexport declare function makeHighDownBatch(batch: Payload['batch'], visualMapModel: VisualMapModel): Payload['batch'];\nexport {};\n"
  },
  {
    "path": "echarts/types/src/component/visualMap/PiecewiseModel.d.ts",
    "code": "import VisualMapModel, { VisualMapOption, VisualMeta } from './VisualMapModel';\nimport { VisualMappingOption } from '../../visual/VisualMapping';\nimport { VisualOptionPiecewise } from '../../util/types';\nimport { Dictionary } from 'zrender/esm/core/types';\ninterface VisualPiece extends VisualOptionPiecewise {\n    min?: number;\n    max?: number;\n    lt?: number;\n    gt?: number;\n    lte?: number;\n    gte?: number;\n    value?: number;\n    label?: string;\n}\ndeclare type VisualState = VisualMapModel['stateList'][number];\ndeclare type InnerVisualPiece = VisualMappingOption['pieceList'][number];\nexport interface PiecewiseVisualMapOption extends VisualMapOption {\n    align?: 'auto' | 'left' | 'right';\n    minOpen?: boolean;\n    maxOpen?: boolean;\n    itemWidth?: number;\n    itemHeight?: number;\n    itemSymbol?: string;\n    pieces?: VisualPiece[];\n    categories?: string[];\n    splitNumber?: number;\n    selected?: Dictionary<boolean>;\n    selectedMode?: 'multiple' | 'single';\n    showLabel?: boolean;\n    itemGap?: number;\n    hoverLink?: boolean;\n}\ndeclare class PiecewiseModel extends VisualMapModel<PiecewiseVisualMapOption> {\n    static type: \"visualMap.piecewise\";\n    type: \"visualMap.piecewise\";\n    private _pieceList;\n    private _mode;\n    optionUpdated(newOption: PiecewiseVisualMapOption, isInit?: boolean): void;\n    completeVisualOption(): void;\n    private _resetSelected;\n    getSelectedMapKey(piece: InnerVisualPiece): string;\n    getPieceList(): InnerVisualPiece[];\n    private _determineMode;\n    setSelected(selected: this['option']['selected']): void;\n    getValueState(value: number): VisualState;\n    findTargetDataIndices(pieceIndex: number): {\n        seriesId: string;\n        dataIndex: number[];\n    }[];\n    getRepresentValue(piece: InnerVisualPiece): string | number;\n    getVisualMeta(getColorVisual: (value: number, valueState: VisualState) => string): VisualMeta;\n    static defaultOption: PiecewiseVisualMapOption;\n}\nexport default PiecewiseModel;\n"
  },
  {
    "path": "echarts/types/src/component/visualMap/PiecewiseView.d.ts",
    "code": "import VisualMapView from './VisualMapView';\nimport PiecewiseModel from './PiecewiseModel';\ndeclare class PiecewiseVisualMapView extends VisualMapView {\n    static type: \"visualMap.piecewise\";\n    type: \"visualMap.piecewise\";\n    visualMapModel: PiecewiseModel;\n    protected doRender(): void;\n    private _enableHoverLink;\n    private _getItemAlign;\n    private _renderEndsText;\n    private _getViewData;\n    private _createItemSymbol;\n    private _onItemClick;\n}\nexport default PiecewiseVisualMapView;\n"
  },
  {
    "path": "echarts/types/src/component/visualMap/preprocessor.d.ts",
    "code": "export default function (option: any): void;\n"
  },
  {
    "path": "echarts/types/src/component/visualMap/typeDefaulter.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/visualMap/visualEncoding.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/visualMap/visualMapAction.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/component/visualMap/VisualMapModel.d.ts",
    "code": "import VisualMapping, { VisualMappingOption } from '../../visual/VisualMapping';\nimport { ComponentOption, BoxLayoutOptionMixin, LabelOption, ColorString, ZRColor, BorderOptionMixin, OptionDataValue, BuiltinVisualProperty } from '../../util/types';\nimport ComponentModel from '../../model/Component';\nimport Model from '../../model/Model';\nimport GlobalModel from '../../model/Global';\nimport SeriesModel from '../../model/Series';\nimport List from '../../data/List';\ndeclare type VisualOptionBase = {\n    [key in BuiltinVisualProperty]?: any;\n};\ndeclare type LabelFormatter = (min: OptionDataValue, max?: OptionDataValue) => string;\ndeclare type VisualState = VisualMapModel['stateList'][number];\nexport interface VisualMapOption<T extends VisualOptionBase = VisualOptionBase> extends ComponentOption, BoxLayoutOptionMixin, BorderOptionMixin {\n    show?: boolean;\n    align?: string;\n    realtime?: boolean;\n    seriesIndex?: 'all' | number[] | number;\n    min?: number;\n    max?: number;\n    dimension?: number;\n    inRange?: T;\n    outOfRange?: T;\n    controller?: {\n        inRange?: T;\n        outOfRange?: T;\n    };\n    target?: {\n        inRange?: T;\n        outOfRange?: T;\n    };\n    itemWidth?: number;\n    itemHeight?: number;\n    inverse?: boolean;\n    orient?: 'horizontal' | 'vertical';\n    backgroundColor?: ZRColor;\n    contentColor?: ZRColor;\n    inactiveColor?: ZRColor;\n    padding?: number[] | number;\n    textGap?: number;\n    precision?: number;\n    color?: ColorString[];\n    formatter?: string | LabelFormatter;\n    text?: string[];\n    textStyle?: LabelOption;\n    categories?: unknown;\n}\nexport interface VisualMeta {\n    stops: {\n        value: number;\n        color: ColorString;\n    }[];\n    outerColors: ColorString[];\n    dimension?: number;\n}\ndeclare class VisualMapModel<Opts extends VisualMapOption = VisualMapOption> extends ComponentModel<Opts> {\n    static type: string;\n    type: string;\n    static readonly dependencies: string[];\n    readonly stateList: readonly [\"inRange\", \"outOfRange\"];\n    readonly replacableOptionKeys: readonly [\"inRange\", \"outOfRange\", \"target\", \"controller\", \"color\"];\n    readonly layoutMode: {\n        readonly type: \"box\";\n        readonly ignoreSize: true;\n    };\n    dataBound: number[];\n    protected _dataExtent: [number, number];\n    targetVisuals: {\n        [x: string]: {\n            symbol?: VisualMapping<{}>;\n            opacity?: VisualMapping<{}>;\n            symbolSize?: VisualMapping<{}>;\n            liftZ?: VisualMapping<{}>;\n            color?: VisualMapping<{}>;\n            colorAlpha?: VisualMapping<{}>;\n            colorLightness?: VisualMapping<{}>;\n            colorSaturation?: VisualMapping<{}>;\n            colorHue?: VisualMapping<{}>;\n        } & {\n            __alphaForOpacity?: VisualMapping<{}>;\n        };\n    };\n    controllerVisuals: {\n        [x: string]: {\n            symbol?: VisualMapping<{}>;\n            opacity?: VisualMapping<{}>;\n            symbolSize?: VisualMapping<{}>;\n            liftZ?: VisualMapping<{}>;\n            color?: VisualMapping<{}>;\n            colorAlpha?: VisualMapping<{}>;\n            colorLightness?: VisualMapping<{}>;\n            colorSaturation?: VisualMapping<{}>;\n            colorHue?: VisualMapping<{}>;\n        } & {\n            __alphaForOpacity?: VisualMapping<{}>;\n        };\n    };\n    textStyleModel: Model<LabelOption>;\n    itemSize: number[];\n    init(option: Opts, parentModel: Model, ecModel: GlobalModel): void;\n    optionUpdated(newOption: Opts, isInit?: boolean): void;\n    resetVisual(supplementVisualOption: (this: this, mappingOption: VisualMappingOption, state: string) => void): void;\n    getTargetSeriesIndices(): number[];\n    eachTargetSeries<Ctx>(callback: (this: Ctx, series: SeriesModel) => void, context?: Ctx): void;\n    isTargetSeries(seriesModel: SeriesModel): boolean;\n    formatValueText(value: number | string | number[], isCategory?: boolean, edgeSymbols?: string[]): string;\n    resetExtent(): void;\n    getDataDimension(list: List): string;\n    getExtent(): [number, number];\n    completeVisualOption(): void;\n    resetItemSize(): void;\n    isCategory(): boolean;\n    setSelected(selected?: any): void;\n    getSelected(): any;\n    getValueState(value: any): VisualMapModel['stateList'][number];\n    getVisualMeta(getColorVisual: (value: number, valueState: VisualState) => string): VisualMeta;\n    static defaultOption: VisualMapOption;\n}\nexport default VisualMapModel;\n"
  },
  {
    "path": "echarts/types/src/component/visualMap/VisualMapView.d.ts",
    "code": "import { Group } from '../../util/graphic';\nimport ComponentView from '../../view/Component';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport VisualMapModel from './VisualMapModel';\ndeclare type VisualState = VisualMapModel['stateList'][number];\ndeclare class VisualMapView extends ComponentView {\n    static type: string;\n    type: string;\n    autoPositionValues: {\n        readonly left: 1;\n        readonly right: 1;\n        readonly top: 1;\n        readonly bottom: 1;\n    };\n    ecModel: GlobalModel;\n    api: ExtensionAPI;\n    visualMapModel: VisualMapModel;\n    init(ecModel: GlobalModel, api: ExtensionAPI): void;\n    render(visualMapModel: VisualMapModel, ecModel: GlobalModel, api: ExtensionAPI, payload: unknown): void;\n    renderBackground(group: Group): void;\n    protected getControllerVisual(targetValue: number, visualCluster: 'color' | 'opacity' | 'symbol' | 'symbolSize', opts?: {\n        forceState?: VisualState;\n        convertOpacityToAlpha?: boolean;\n    }): string | number;\n    protected positionGroup(group: Group): void;\n    protected doRender(visualMapModel: VisualMapModel, ecModel: GlobalModel, api: ExtensionAPI, payload: unknown): void;\n}\nexport default VisualMapView;\n"
  },
  {
    "path": "echarts/types/src/component/visualMapContinuous.d.ts",
    "code": "import './visualMap/typeDefaulter';\nimport './visualMap/visualEncoding';\nimport './visualMap/ContinuousModel';\nimport './visualMap/ContinuousView';\nimport './visualMap/visualMapAction';\n"
  },
  {
    "path": "echarts/types/src/component/visualMapPiecewise.d.ts",
    "code": "import './visualMap/typeDefaulter';\nimport './visualMap/visualEncoding';\nimport './visualMap/PiecewiseModel';\nimport './visualMap/PiecewiseView';\nimport './visualMap/visualMapAction';\n"
  },
  {
    "path": "echarts/types/src/coord/Axis.d.ts",
    "code": "import { createAxisLabels, calculateCategoryInterval } from './axisTickLabelBuilder';\nimport Scale from '../scale/Scale';\nimport { DimensionName, ScaleDataValue } from '../util/types';\nimport Model from '../model/Model';\nimport { AxisBaseOption, OptionAxisType } from './axisCommonTypes';\nimport { AxisBaseModel } from './AxisBaseModel';\ninterface TickCoord {\n    coord: number;\n    tickValue?: number;\n}\ndeclare class Axis {\n    type: OptionAxisType;\n    readonly dim: DimensionName;\n    scale: Scale;\n    private _extent;\n    model: AxisBaseModel;\n    onBand: AxisBaseOption['boundaryGap'];\n    inverse: AxisBaseOption['inverse'];\n    constructor(dim: DimensionName, scale: Scale, extent: [number, number]);\n    contain(coord: number): boolean;\n    containData(data: ScaleDataValue): boolean;\n    getExtent(): [number, number];\n    getPixelPrecision(dataExtent?: [number, number]): number;\n    setExtent(start: number, end: number): void;\n    dataToCoord(data: ScaleDataValue, clamp?: boolean): number;\n    coordToData(coord: number, clamp?: boolean): number;\n    pointToData(point: number[], clamp?: boolean): number;\n    getTicksCoords(opt?: {\n        tickModel?: Model;\n        clamp?: boolean;\n    }): TickCoord[];\n    getMinorTicksCoords(): TickCoord[][];\n    getViewLabels(): ReturnType<typeof createAxisLabels>['labels'];\n    getLabelModel(): Model<AxisBaseOption['axisLabel']>;\n    getTickModel(): Model;\n    getBandWidth(): number;\n    getRotate: () => number;\n    calculateCategoryInterval(): ReturnType<typeof calculateCategoryInterval>;\n}\nexport default Axis;\n"
  },
  {
    "path": "echarts/types/src/coord/AxisBaseModel.d.ts",
    "code": "import { AxisBaseOption } from './axisCommonTypes';\nimport ComponentModel from '../model/Component';\nimport { AxisModelCommonMixin } from './axisModelCommonMixin';\nimport { AxisModelExtendedInCreator } from './axisModelCreator';\nimport Axis from './Axis';\nexport interface AxisBaseModel<T extends AxisBaseOption = AxisBaseOption> extends ComponentModel<T>, AxisModelCommonMixin<T>, AxisModelExtendedInCreator<T> {\n    axis: Axis;\n}\n"
  },
  {
    "path": "echarts/types/src/coord/axisCommonTypes.d.ts",
    "code": "import { TextCommonOption, LineStyleOption, OrdinalRawValue, ZRColor, AreaStyleOption, ComponentOption, ColorString, AnimationOptionMixin, Dictionary, ScaleDataValue } from '../util/types';\nexport declare const AXIS_TYPES: {\n    readonly value: 1;\n    readonly category: 1;\n    readonly time: 1;\n    readonly log: 1;\n};\nexport declare type OptionAxisType = keyof typeof AXIS_TYPES;\nexport interface AxisBaseOption extends ComponentOption, AnimationOptionMixin {\n    type?: OptionAxisType;\n    show?: boolean;\n    inverse?: boolean;\n    name?: string;\n    nameLocation?: 'start' | 'middle' | 'end';\n    nameRotate?: number;\n    nameTruncate?: {\n        maxWidth?: number;\n        ellipsis?: string;\n        placeholder?: string;\n    };\n    nameTextStyle?: AxisNameTextStyleOption;\n    nameGap?: number;\n    silent?: boolean;\n    triggerEvent?: boolean;\n    tooltip?: {\n        show?: boolean;\n    };\n    axisPointer?: any;\n    axisLine?: AxisLineOption;\n    axisTick?: AxisTickOption;\n    axisLabel?: AxisLabelOption;\n    minorTick?: MinorTickOption;\n    splitLine?: SplitLineOption;\n    minorSplitLine?: MinorSplitLineOption;\n    splitArea?: SplitAreaOption;\n    boundaryGap?: boolean | [number | string, number | string];\n    min?: ScaleDataValue | 'dataMin' | ((extent: {\n        min: number;\n        max: number;\n    }) => ScaleDataValue);\n    max?: ScaleDataValue | 'dataMax' | ((extent: {\n        min: number;\n        max: number;\n    }) => ScaleDataValue);\n    scale?: boolean;\n    deduplication?: boolean;\n    data?: (OrdinalRawValue | {\n        value: OrdinalRawValue;\n        textStyle?: TextCommonOption;\n    })[];\n    splitNumber?: number;\n    interval?: number;\n    minInterval?: number;\n    maxInterval?: number;\n    logBase?: number;\n}\ninterface AxisNameTextStyleOption extends TextCommonOption {\n    rich?: Dictionary<TextCommonOption>;\n}\ninterface AxisLineOption {\n    show?: boolean | 'auto';\n    onZero?: boolean;\n    onZeroAxisIndex?: number;\n    symbol?: string | [string, string];\n    symbolSize?: number[];\n    symbolOffset?: number[];\n    lineStyle?: LineStyleOption;\n}\ninterface AxisTickOption {\n    show?: boolean | 'auto';\n    inside?: boolean;\n    length?: number;\n    lineStyle?: LineStyleOption;\n    alignWithLabel?: boolean;\n    interval?: 'auto' | number | ((index: number, value: string) => boolean);\n}\nexport declare type AxisLabelFormatterOption = string | ((value: OrdinalRawValue | number, index: number) => string);\ndeclare type TimeAxisLabelUnitFormatter = AxisLabelFormatterOption | string[];\nexport declare type TimeAxisLabelFormatterOption = string | ((value: number, index: number, extra: {\n    level: number;\n}) => string) | {\n    year?: TimeAxisLabelUnitFormatter;\n    month?: TimeAxisLabelUnitFormatter;\n    week?: TimeAxisLabelUnitFormatter;\n    day?: TimeAxisLabelUnitFormatter;\n    hour?: TimeAxisLabelUnitFormatter;\n    minute?: TimeAxisLabelUnitFormatter;\n    second?: TimeAxisLabelUnitFormatter;\n    millisecond?: TimeAxisLabelUnitFormatter;\n    inherit?: boolean;\n};\ninterface AxisLabelOption extends Omit<TextCommonOption, 'color'> {\n    show?: boolean;\n    inside?: boolean;\n    rotate?: number;\n    showMinLabel?: boolean;\n    showMaxLabel?: boolean;\n    margin?: number;\n    formatter?: AxisLabelFormatterOption | TimeAxisLabelFormatterOption;\n    interval?: 'auto' | number | ((index: number, value: string) => boolean);\n    color?: ColorString | ((value?: string | number, index?: number) => ColorString);\n}\ninterface MinorTickOption {\n    show?: boolean;\n    splitNumber?: number;\n    length?: number;\n    lineStyle?: LineStyleOption;\n}\ninterface SplitLineOption {\n    show?: boolean;\n    interval?: 'auto' | number | ((index: number, value: string) => boolean);\n    lineStyle?: LineStyleOption<ZRColor | ZRColor[]>;\n}\ninterface MinorSplitLineOption {\n    show?: boolean;\n    lineStyle?: LineStyleOption;\n}\ninterface SplitAreaOption {\n    show?: boolean;\n    interval?: 'auto' | number | ((index: number, value: string) => boolean);\n    areaStyle?: AreaStyleOption<ZRColor[]>;\n}\nexport {};\n"
  },
  {
    "path": "echarts/types/src/coord/axisDefault.d.ts",
    "code": "import { AxisBaseOption } from './axisCommonTypes';\ndeclare const _default: {\n    category: AxisBaseOption;\n    value: AxisBaseOption;\n    time: AxisBaseOption;\n    log: AxisBaseOption;\n};\nexport default _default;\n"
  },
  {
    "path": "echarts/types/src/coord/axisHelper.d.ts",
    "code": "import Scale from '../scale/Scale';\nimport BoundingRect from 'zrender/esm/core/BoundingRect';\nimport Model from '../model/Model';\nimport { AxisBaseModel } from './AxisBaseModel';\nimport Axis from './Axis';\nimport { AxisBaseOption } from './axisCommonTypes';\nimport List from '../data/List';\nimport { DimensionName, ScaleTick } from '../util/types';\nexport declare function getScaleExtent(scale: Scale, model: AxisBaseModel): {\n    extent: number[];\n    fixMin: boolean;\n    fixMax: boolean;\n};\nexport declare function niceScaleExtent(scale: Scale, model: AxisBaseModel): void;\nexport declare function createScaleByModel(model: AxisBaseModel, axisType?: string): Scale;\nexport declare function ifAxisCrossZero(axis: Axis): boolean;\nexport declare function makeLabelFormatter(axis: Axis): (tick: ScaleTick, idx?: number) => string;\nexport declare function getAxisRawValue(axis: Axis, tick: ScaleTick): number | string;\nexport declare function estimateLabelUnionRect(axis: Axis): BoundingRect;\nexport declare function getOptionCategoryInterval(model: Model<AxisBaseOption['axisLabel']>): number | \"auto\" | ((index: number, value: string) => boolean);\nexport declare function shouldShowAllLabels(axis: Axis): boolean;\nexport declare function getDataDimensionsOnAxis(data: List, axisDim: string): DimensionName[];\nexport declare function unionAxisExtentFromData(dataExtent: number[], data: List, axisDim: string): void;\n"
  },
  {
    "path": "echarts/types/src/coord/axisModelCommonMixin.d.ts",
    "code": "import Model from '../model/Model';\nimport Axis from './Axis';\nimport { AxisBaseOption } from './axisCommonTypes';\nimport { CoordinateSystemHostModel } from './CoordinateSystem';\ninterface AxisModelCommonMixin<Opt extends AxisBaseOption> extends Pick<Model<Opt>, 'option'> {\n    axis: Axis;\n}\ndeclare class AxisModelCommonMixin<Opt extends AxisBaseOption> {\n    getNeedCrossZero(): boolean;\n    getCoordSysModel(): CoordinateSystemHostModel;\n}\nexport { AxisModelCommonMixin };\n"
  },
  {
    "path": "echarts/types/src/coord/axisModelCreator.d.ts",
    "code": "import ComponentModel from '../model/Component';\nimport OrdinalMeta from '../data/OrdinalMeta';\nimport { DimensionName, OrdinalRawValue } from '../util/types';\nimport { AxisBaseOption } from './axisCommonTypes';\ndeclare type Constructor<T> = new (...args: any[]) => T;\nexport interface AxisModelExtendedInCreator<Opt extends AxisBaseOption> {\n    getCategories(rawData?: boolean): OrdinalRawValue[] | Opt['data'];\n    getOrdinalMeta(): OrdinalMeta;\n}\nexport default function <AxisOptionT extends AxisBaseOption, AxisModelCtor extends Constructor<ComponentModel<AxisOptionT>>>(axisName: DimensionName, BaseAxisModelClass: AxisModelCtor, extraDefaultOption?: AxisOptionT): void;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/coord/axisTickLabelBuilder.d.ts",
    "code": "import Axis from './Axis';\nimport { AxisBaseModel } from './AxisBaseModel';\nexport declare function createAxisLabels(axis: Axis): {\n    labels: {\n        formattedLabel: string;\n        rawLabel: string;\n        tickValue: number;\n    }[];\n    labelCategoryInterval?: number;\n};\nexport declare function createAxisTicks(axis: Axis, tickModel: AxisBaseModel): {\n    ticks: number[];\n    tickCategoryInterval?: number;\n};\nexport declare function calculateCategoryInterval(axis: Axis): number;\n"
  },
  {
    "path": "echarts/types/src/coord/calendar/Calendar.d.ts",
    "code": "import { BoundingRect } from 'zrender/esm/export';\nimport CalendarModel from './CalendarModel';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { ScaleDataValue, OptionDataValueDate } from '../../util/types';\nimport { ParsedModelFinder } from '../../util/model';\nimport { CoordinateSystem, CoordinateSystemMaster } from '../CoordinateSystem';\nimport { RectLike } from 'zrender/esm/core/BoundingRect';\nexport interface CalendarParsedDateRangeInfo {\n    range: [string, string];\n    start: CalendarParsedDateInfo;\n    end: CalendarParsedDateInfo;\n    allDay: number;\n    weeks: number;\n    nthWeek: number;\n    fweek: number;\n    lweek: number;\n}\nexport interface CalendarParsedDateInfo {\n    y: string;\n    m: string;\n    d: string;\n    day: number;\n    time: number;\n    formatedDate: string;\n    date: Date;\n}\nexport interface CalendarCellRect {\n    contentShape: RectLike;\n    center: number[];\n    tl: number[];\n    tr: number[];\n    br: number[];\n    bl: number[];\n}\ndeclare class Calendar implements CoordinateSystem, CoordinateSystemMaster {\n    static readonly dimensions: string[];\n    static getDimensionsInfo(): (string | {\n        name: string;\n        type: \"time\";\n    })[];\n    readonly type = \"calendar\";\n    readonly dimensions: string[];\n    private _model;\n    private _rect;\n    private _sw;\n    private _sh;\n    private _orient;\n    private _firstDayOfWeek;\n    private _rangeInfo;\n    private _lineWidth;\n    constructor(calendarModel: CalendarModel, ecModel: GlobalModel, api: ExtensionAPI);\n    getDimensionsInfo: typeof Calendar.getDimensionsInfo;\n    getRangeInfo(): CalendarParsedDateRangeInfo;\n    getModel(): CalendarModel;\n    getRect(): BoundingRect;\n    getCellWidth(): number;\n    getCellHeight(): number;\n    getOrient(): \"horizontal\" | \"vertical\";\n    getFirstDayOfWeek(): number;\n    getDateInfo(date: OptionDataValueDate): CalendarParsedDateInfo;\n    getNextNDay(date: OptionDataValueDate, n: number): CalendarParsedDateInfo;\n    update(ecModel: GlobalModel, api: ExtensionAPI): void;\n    dataToPoint(data: OptionDataValueDate | OptionDataValueDate[], clamp?: boolean): number[];\n    pointToData(point: number[]): number;\n    dataToRect(data: OptionDataValueDate | OptionDataValueDate[], clamp?: boolean): CalendarCellRect;\n    pointToDate(point: number[]): CalendarParsedDateInfo;\n    convertToPixel(ecModel: GlobalModel, finder: ParsedModelFinder, value: ScaleDataValue | ScaleDataValue[]): number[];\n    convertFromPixel(ecModel: GlobalModel, finder: ParsedModelFinder, pixel: number[]): number;\n    containPoint(point: number[]): boolean;\n    private _initRangeOption;\n    _getRangeInfo(range: OptionDataValueDate[]): CalendarParsedDateRangeInfo;\n    private _getDateByWeeksAndDay;\n    static create(ecModel: GlobalModel, api: ExtensionAPI): Calendar[];\n}\nexport default Calendar;\n"
  },
  {
    "path": "echarts/types/src/coord/calendar/CalendarModel.d.ts",
    "code": "import ComponentModel from '../../model/Component';\nimport Calendar from './Calendar';\nimport { ComponentOption, BoxLayoutOptionMixin, LayoutOrient, LineStyleOption, ItemStyleOption, LabelOption, OptionDataValueDate } from '../../util/types';\nimport GlobalModel from '../../model/Global';\nimport Model from '../../model/Model';\nexport interface CalendarMonthLabelFormatterCallbackParams {\n    nameMap: string;\n    yyyy: string;\n    yy: string;\n    MM: string;\n    M: number;\n}\nexport interface CalendarYearLabelFormatterCallbackParams {\n    nameMap: string;\n    start: string;\n    end: string;\n}\nexport interface CalendarOption extends ComponentOption, BoxLayoutOptionMixin {\n    cellSize?: number | 'auto' | (number | 'auto')[];\n    orient?: LayoutOrient;\n    splitLine?: {\n        show?: boolean;\n        lineStyle?: LineStyleOption;\n    };\n    itemStyle?: ItemStyleOption;\n    range?: OptionDataValueDate | (OptionDataValueDate)[];\n    dayLabel?: Omit<LabelOption, 'position'> & {\n        firstDay?: number;\n        margin?: number | string;\n        position?: 'start' | 'end';\n        nameMap?: 'en' | 'cn' | string[];\n    };\n    monthLabel?: Omit<LabelOption, 'position'> & {\n        margin?: number;\n        position?: 'start' | 'end';\n        nameMap?: 'en' | 'cn' | string[];\n        formatter?: string | ((params: CalendarMonthLabelFormatterCallbackParams) => string);\n    };\n    yearLabel?: Omit<LabelOption, 'position'> & {\n        margin?: number;\n        position?: 'top' | 'bottom' | 'left' | 'right';\n        formatter?: string | ((params: CalendarYearLabelFormatterCallbackParams) => string);\n    };\n}\ndeclare class CalendarModel extends ComponentModel<CalendarOption> {\n    static type: string;\n    type: string;\n    coordinateSystem: Calendar;\n    init(option: CalendarOption, parentModel: Model, ecModel: GlobalModel): void;\n    mergeOption(option: CalendarOption): void;\n    getCellSize(): LineAndPositionSetting[];\n    static defaultOption: CalendarOption;\n}\nexport default CalendarModel;\n"
  },
  {
    "path": "echarts/types/src/coord/calendar/prepareCustom.d.ts",
    "code": "import Calendar from './Calendar';\nexport default function (coordSys: Calendar): {\n    coordSys: {\n        type: string;\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n        cellWidth: number;\n        cellHeight: number;\n        rangeInfo: {\n            start: import(\"./Calendar\").CalendarParsedDateInfo;\n            end: import(\"./Calendar\").CalendarParsedDateInfo;\n            weeks: number;\n            dayCount: number;\n        };\n    };\n    api: {\n        coord: (data: string | number | Date, clamp?: boolean) => number[];\n    };\n};\n"
  },
  {
    "path": "echarts/types/src/coord/cartesian/Axis2D.d.ts",
    "code": "import Axis from '../Axis';\nimport { DimensionName, OrdinalSortInfo } from '../../util/types';\nimport Scale from '../../scale/Scale';\nimport CartesianAxisModel, { CartesianAxisPosition } from './AxisModel';\nimport Grid from './Grid';\nimport { OptionAxisType } from '../axisCommonTypes';\ninterface Axis2D {\n    toLocalCoord(coord: number): number;\n    toGlobalCoord(coord: number): number;\n}\ndeclare class Axis2D extends Axis {\n    readonly position: CartesianAxisPosition;\n    index: number;\n    model: CartesianAxisModel;\n    grid: Grid;\n    constructor(dim: DimensionName, scale: Scale, coordExtent: [number, number], axisType?: OptionAxisType, position?: CartesianAxisPosition);\n    getAxesOnZeroOf: () => Axis2D[];\n    isHorizontal(): boolean;\n    getGlobalExtent(asc?: boolean): [number, number];\n    pointToData(point: number[], clamp?: boolean): number;\n    setCategorySortInfo(info: OrdinalSortInfo[]): boolean;\n}\nexport default Axis2D;\n"
  },
  {
    "path": "echarts/types/src/coord/cartesian/AxisModel.d.ts",
    "code": "import ComponentModel from '../../model/Component';\nimport { AxisModelExtendedInCreator } from '../axisModelCreator';\nimport { AxisModelCommonMixin } from '../axisModelCommonMixin';\nimport Axis2D from './Axis2D';\nimport { AxisBaseOption } from '../axisCommonTypes';\nimport GridModel from './GridModel';\nimport { AxisBaseModel } from '../AxisBaseModel';\nimport { OrdinalSortInfo } from '../../util/types';\nexport declare type CartesianAxisPosition = 'top' | 'bottom' | 'left' | 'right';\nexport interface CartesianAxisOption extends AxisBaseOption {\n    gridIndex?: number;\n    gridId?: string;\n    position?: CartesianAxisPosition;\n    offset?: number;\n    categorySortInfo?: OrdinalSortInfo[];\n}\ndeclare class CartesianAxisModel extends ComponentModel<CartesianAxisOption> implements AxisBaseModel<CartesianAxisOption> {\n    static type: string;\n    axis: Axis2D;\n    getCoordSysModel(): GridModel;\n}\ninterface CartesianAxisModel extends AxisModelCommonMixin<CartesianAxisOption>, AxisModelExtendedInCreator<CartesianAxisOption> {\n}\nexport default CartesianAxisModel;\n"
  },
  {
    "path": "echarts/types/src/coord/cartesian/Cartesian.d.ts",
    "code": "import { DimensionName } from '../../util/types';\nimport Axis from '../Axis';\ndeclare class Cartesian<AxisT extends Axis> {\n    readonly type: string;\n    readonly name: string;\n    private _dimList;\n    private _axes;\n    constructor(name: string);\n    getAxis(dim: DimensionName): AxisT;\n    getAxes(): AxisT[];\n    getAxesByScale(scaleType: string): AxisT[];\n    addAxis(axis: AxisT): void;\n}\nexport default Cartesian;\n"
  },
  {
    "path": "echarts/types/src/coord/cartesian/Cartesian2D.d.ts",
    "code": "import BoundingRect from 'zrender/esm/core/BoundingRect';\nimport Cartesian from './Cartesian';\nimport { ScaleDataValue } from '../../util/types';\nimport Axis2D from './Axis2D';\nimport { CoordinateSystem } from '../CoordinateSystem';\nimport GridModel from './GridModel';\nimport Grid from './Grid';\nexport declare const cartesian2DDimensions: string[];\ndeclare class Cartesian2D extends Cartesian<Axis2D> implements CoordinateSystem {\n    readonly type = \"cartesian2d\";\n    readonly dimensions: string[];\n    model: GridModel;\n    master: Grid;\n    getBaseAxis(): Axis2D;\n    containPoint(point: number[]): boolean;\n    containData(data: ScaleDataValue[]): boolean;\n    dataToPoint(data: ScaleDataValue[], reserved?: unknown, out?: number[]): number[];\n    clampData(data: ScaleDataValue[], out?: number[]): number[];\n    pointToData(point: number[], out?: number[]): number[];\n    getOtherAxis(axis: Axis2D): Axis2D;\n    getArea(): Cartesian2DArea;\n}\ninterface Cartesian2DArea extends BoundingRect {\n}\nexport default Cartesian2D;\n"
  },
  {
    "path": "echarts/types/src/coord/cartesian/cartesianAxisHelper.d.ts",
    "code": "import GridModel from './GridModel';\nimport CartesianAxisModel from './AxisModel';\nimport SeriesModel from '../../model/Series';\ninterface CartesianAxisLayout {\n    position: [number, number];\n    rotation: number;\n    labelOffset: number;\n    labelDirection: -1 | 1;\n    tickDirection: -1 | 1;\n    nameDirection: -1 | 1;\n    labelRotate: number;\n    z2: number;\n}\nexport declare function layout(gridModel: GridModel, axisModel: CartesianAxisModel, opt?: {\n    labelInside?: boolean;\n}): CartesianAxisLayout;\nexport declare function isCartesian2DSeries(seriesModel: SeriesModel): boolean;\nexport declare function findAxisModels(seriesModel: SeriesModel): {\n    xAxisModel: CartesianAxisModel;\n    yAxisModel: CartesianAxisModel;\n};\nexport {};\n"
  },
  {
    "path": "echarts/types/src/coord/cartesian/defaultAxisExtentFromData.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/coord/cartesian/Grid.d.ts",
    "code": "import { LayoutRect } from '../../util/layout';\nimport Cartesian2D from './Cartesian2D';\nimport Axis2D from './Axis2D';\nimport { ParsedModelFinder } from '../../util/model';\nimport GridModel from './GridModel';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { CoordinateSystemMaster } from '../CoordinateSystem';\nimport { ScaleDataValue } from '../../util/types';\ndeclare type Cartesian2DDimensionName = 'x' | 'y';\ndeclare type FinderAxisIndex = {\n    xAxisIndex?: number;\n    yAxisIndex?: number;\n};\ndeclare class Grid implements CoordinateSystemMaster {\n    readonly type: string;\n    private _coordsMap;\n    private _coordsList;\n    private _axesMap;\n    private _axesList;\n    private _rect;\n    readonly model: GridModel;\n    readonly axisPointerEnabled = true;\n    name: string;\n    static dimensions: string[];\n    readonly dimensions: string[];\n    constructor(gridModel: GridModel, ecModel: GlobalModel, api: ExtensionAPI);\n    getRect(): LayoutRect;\n    update(ecModel: GlobalModel, api: ExtensionAPI): void;\n    resize(gridModel: GridModel, api: ExtensionAPI, ignoreContainLabel?: boolean): void;\n    getAxis(dim: Cartesian2DDimensionName, axisIndex?: number): Axis2D;\n    getAxes(): Axis2D[];\n    getCartesian(finder: FinderAxisIndex): Cartesian2D;\n    getCartesian(xAxisIndex?: number, yAxisIndex?: number): Cartesian2D;\n    getCartesians(): Cartesian2D[];\n    convertToPixel(ecModel: GlobalModel, finder: ParsedModelFinder, value: ScaleDataValue | ScaleDataValue[]): number | number[];\n    convertFromPixel(ecModel: GlobalModel, finder: ParsedModelFinder, value: number | number[]): number | number[];\n    private _findConvertTarget;\n    containPoint(point: number[]): boolean;\n    private _initCartesian;\n    private _updateScale;\n    getTooltipAxes(dim: Cartesian2DDimensionName | 'auto'): {\n        baseAxes: Axis2D[];\n        otherAxes: Axis2D[];\n    };\n    static create(ecModel: GlobalModel, api: ExtensionAPI): Grid[];\n}\nexport default Grid;\n"
  },
  {
    "path": "echarts/types/src/coord/cartesian/GridModel.d.ts",
    "code": "import './AxisModel';\nimport ComponentModel from '../../model/Component';\nimport { ComponentOption, BoxLayoutOptionMixin, ZRColor, ShadowOptionMixin } from '../../util/types';\nimport Grid from './Grid';\nimport { CoordinateSystemHostModel } from '../CoordinateSystem';\nexport interface GridOption extends ComponentOption, BoxLayoutOptionMixin, ShadowOptionMixin {\n    show?: boolean;\n    containLabel?: boolean;\n    backgroundColor?: ZRColor;\n    borderWidth?: number;\n    borderColor?: ZRColor;\n    tooltip?: any;\n}\ndeclare class GridModel extends ComponentModel<GridOption> implements CoordinateSystemHostModel {\n    static type: string;\n    static dependencies: string[];\n    static layoutMode: \"box\";\n    coordinateSystem: Grid;\n    static defaultOption: GridOption;\n}\nexport default GridModel;\n"
  },
  {
    "path": "echarts/types/src/coord/cartesian/prepareCustom.d.ts",
    "code": "import Cartesian2D from './Cartesian2D';\nexport default function (coordSys: Cartesian2D): {\n    coordSys: {\n        type: string;\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n    };\n    api: {\n        coord: (data: number[]) => number[];\n        size: (dataSize: number[], dataItem: number[]) => number[];\n    };\n};\n"
  },
  {
    "path": "echarts/types/src/coord/CoordinateSystem.d.ts",
    "code": "import GlobalModel from '../model/Global';\nimport { ParsedModelFinder } from '../util/model';\nimport ExtensionAPI from '../ExtensionAPI';\nimport { DimensionDefinitionLoose, ScaleDataValue, DimensionName } from '../util/types';\nimport Axis from './Axis';\nimport { BoundingRect } from '../util/graphic';\nimport { MatrixArray } from 'zrender/esm/core/matrix';\nimport ComponentModel from '../model/Component';\nimport { RectLike } from 'zrender/esm/core/BoundingRect';\nimport { PrepareCustomInfo } from '../chart/custom';\nexport interface CoordinateSystemCreator {\n    create: (ecModel: GlobalModel, api: ExtensionAPI) => CoordinateSystemMaster[];\n    dimensions?: DimensionName[];\n    getDimensionsInfo?: () => DimensionDefinitionLoose[];\n}\nexport interface CoordinateSystemMaster {\n    dimensions: DimensionName[];\n    model?: ComponentModel;\n    update?: (ecModel: GlobalModel, api: ExtensionAPI) => void;\n    convertToPixel?(ecModel: GlobalModel, finder: ParsedModelFinder, value: ScaleDataValue | ScaleDataValue[]): number | number[];\n    convertFromPixel?(ecModel: GlobalModel, finder: ParsedModelFinder, pixelValue: number | number[]): ScaleDataValue | ScaleDataValue[];\n    containPoint(point: number[]): boolean;\n    getAxes?: () => Axis[];\n    axisPointerEnabled?: boolean;\n    getTooltipAxes?: (dim: DimensionName | 'auto') => {\n        baseAxes: Axis[];\n        otherAxes: Axis[];\n    };\n    getRect?: () => RectLike;\n}\nexport interface CoordinateSystem {\n    type: string;\n    master?: CoordinateSystemMaster;\n    dimensions: DimensionName[];\n    model?: ComponentModel;\n    dataToPoint(data: ScaleDataValue | ScaleDataValue[], reserved?: any, out?: number[]): number[];\n    pointToData?(point: number[], reserved?: any, out?: number[]): number | number[];\n    containPoint(point: number[]): boolean;\n    getAxis?: (dim?: DimensionName) => Axis;\n    getBaseAxis?: () => Axis;\n    getOtherAxis?: (baseAxis: Axis) => Axis;\n    clampData?: (data: ScaleDataValue[], out?: number[]) => number[];\n    getRoamTransform?: () => MatrixArray;\n    getArea?: () => CoordinateSystemClipArea;\n    getBoundingRect?: () => BoundingRect;\n    getAxesByScale?: (scaleType: string) => Axis[];\n    prepareCustoms?: PrepareCustomInfo;\n}\nexport interface CoordinateSystemHostModel extends ComponentModel {\n    coordinateSystem?: CoordinateSystemMaster;\n}\nexport interface CoordinateSystemClipArea {\n    contain(x: number, y: number): boolean;\n}\nexport declare function isCoordinateSystemType<T extends CoordinateSystem, S = T['type']>(coordSys: CoordinateSystem, type: S): coordSys is T;\n"
  },
  {
    "path": "echarts/types/src/coord/geo/fix/diaoyuIsland.d.ts",
    "code": "import Region from '../Region';\nexport default function (mapType: string, region: Region): void;\n"
  },
  {
    "path": "echarts/types/src/coord/geo/fix/geoCoord.d.ts",
    "code": "import Region from '../Region';\nexport default function (mapType: string, region: Region): void;\n"
  },
  {
    "path": "echarts/types/src/coord/geo/fix/nanhai.d.ts",
    "code": "import Region from '../Region';\nexport default function (mapType: string, regions: Region[]): void;\n"
  },
  {
    "path": "echarts/types/src/coord/geo/fix/textCoord.d.ts",
    "code": "import Region from '../Region';\nexport default function (mapType: string, region: Region): void;\n"
  },
  {
    "path": "echarts/types/src/coord/geo/Geo.d.ts",
    "code": "import BoundingRect from 'zrender/esm/core/BoundingRect';\nimport View from '../View';\nimport Region from './Region';\nimport { NameMap } from './geoTypes';\nimport GlobalModel from '../../model/Global';\nimport { ParsedModelFinder } from '../../util/model';\nimport GeoModel from './GeoModel';\nimport { resizeGeoType } from './geoCreator';\ndeclare class Geo extends View {\n    dimensions: string[];\n    type: string;\n    readonly map: string;\n    private _nameCoordMap;\n    private _regionsMap;\n    private _invertLongitute;\n    readonly regions: Region[];\n    aspectScale: number;\n    model: GeoModel;\n    resize: resizeGeoType;\n    constructor(name: string, map: string, nameMap?: NameMap, invertLongitute?: boolean);\n    containCoord(coord: number[]): boolean;\n    transformTo(x: number, y: number, width: number, height: number): void;\n    getRegion(name: string): Region;\n    getRegionByCoord(coord: number[]): Region;\n    addGeoCoord(name: string, geoCoord: number[]): void;\n    getGeoCoord(name: string): number[];\n    getBoundingRect(): BoundingRect;\n    dataToPoint(data: number[], noRoam?: boolean, out?: number[]): number[];\n    convertToPixel(ecModel: GlobalModel, finder: ParsedModelFinder, value: number[]): number[];\n    convertFromPixel(ecModel: GlobalModel, finder: ParsedModelFinder, pixel: number[]): number[];\n}\nexport default Geo;\n"
  },
  {
    "path": "echarts/types/src/coord/geo/geoCreator.d.ts",
    "code": "import Geo from './Geo';\nimport { GeoOption, RegoinOption } from './GeoModel';\nimport { MapSeriesOption } from '../../chart/map/MapSeries';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { CoordinateSystemCreator } from '../CoordinateSystem';\nimport { NameMap } from './geoTypes';\nimport GlobalModel from '../../model/Global';\nimport ComponentModel from '../../model/Component';\nexport declare type resizeGeoType = typeof resizeGeo;\ndeclare function resizeGeo(this: Geo, geoModel: ComponentModel<GeoOption | MapSeriesOption>, api: ExtensionAPI): void;\ndeclare class GeoCreator implements CoordinateSystemCreator {\n    dimensions: string[];\n    create(ecModel: GlobalModel, api: ExtensionAPI): Geo[];\n    getFilledRegions(originRegionArr: RegoinOption[], mapName: string, nameMap?: NameMap): RegoinOption[];\n}\ndeclare const geoCreator: GeoCreator;\nexport default geoCreator;\n"
  },
  {
    "path": "echarts/types/src/coord/geo/geoJSONLoader.d.ts",
    "code": "import { GeoJSONMapRecord } from './mapDataStorage';\nimport { BoundingRect } from 'zrender/esm/export';\nimport Region from './Region';\ndeclare const _default: {\n    load(mapName: string, mapRecord: GeoJSONMapRecord, nameProperty: string): {\n        regions: Region[];\n        boundingRect: BoundingRect;\n    };\n};\nexport default _default;\n"
  },
  {
    "path": "echarts/types/src/coord/geo/GeoModel.d.ts",
    "code": "import ComponentModel from '../../model/Component';\nimport Model from '../../model/Model';\nimport Geo from './Geo';\nimport { ComponentOption, BoxLayoutOptionMixin, ItemStyleOption, ZRColor, LabelOption, DisplayState, RoamOptionMixin, AnimationOptionMixin, StatesOptionMixin, Dictionary } from '../../util/types';\nimport { NameMap } from './geoTypes';\nimport GlobalModel from '../../model/Global';\nexport interface GeoItemStyleOption extends ItemStyleOption {\n    areaColor?: ZRColor;\n}\ninterface GeoLabelOption extends LabelOption {\n    formatter?: string | ((params: GeoLabelFormatterDataParams) => string);\n}\nexport interface GeoStateOption {\n    itemStyle?: GeoItemStyleOption;\n    label?: GeoLabelOption;\n}\ninterface GeoLabelFormatterDataParams {\n    name: string;\n    status: DisplayState;\n}\nexport interface RegoinOption extends GeoStateOption, StatesOptionMixin<GeoStateOption> {\n    name?: string;\n    selected?: boolean;\n}\nexport interface GeoCommonOptionMixin extends RoamOptionMixin {\n    map: string;\n    aspectScale?: number;\n    layoutCenter?: number[];\n    layoutSize?: number;\n    boundingCoords?: number[][];\n    nameMap?: NameMap;\n}\nexport interface GeoOption extends ComponentOption, BoxLayoutOptionMixin, AnimationOptionMixin, GeoCommonOptionMixin, StatesOptionMixin<GeoStateOption>, GeoStateOption {\n    show?: boolean;\n    silent?: boolean;\n    regions: RegoinOption[];\n    stateAnimation?: AnimationOptionMixin;\n    selectedMode?: 'single' | 'multiple' | boolean;\n    selectedMap?: Dictionary<boolean>;\n}\ndeclare class GeoModel extends ComponentModel<GeoOption> {\n    static type: string;\n    readonly type: string;\n    coordinateSystem: Geo;\n    static layoutMode: \"box\";\n    private _optionModelMap;\n    static defaultOption: GeoOption;\n    init(option: GeoOption, parentModel: Model, ecModel: GlobalModel): void;\n    optionUpdated(): void;\n    getRegionModel(name: string): Model<RegoinOption>;\n    getFormattedLabel(name: string, status?: DisplayState): string;\n    setZoom(zoom: number): void;\n    setCenter(center: number[]): void;\n    select(name?: string): void;\n    unSelect(name?: string): void;\n    toggleSelected(name?: string): void;\n    isSelected(name?: string): boolean;\n    private _initSelectedMapFromData;\n}\nexport default GeoModel;\n"
  },
  {
    "path": "echarts/types/src/coord/geo/geoSourceManager.d.ts",
    "code": "import { HashMap } from 'zrender/esm/core/util';\nimport BoundingRect from 'zrender/esm/core/BoundingRect';\nimport { NameMap } from './geoTypes';\nimport Region from './Region';\nimport Group from 'zrender/esm/graphic/Group';\ndeclare const _default: {\n    load: (mapName: string, nameMap: NameMap, nameProperty?: string) => {\n        regions: Region[];\n        regionsMap: HashMap<Region, string | number>;\n        nameCoordMap: HashMap<number[], string | number>;\n        boundingRect: BoundingRect;\n    };\n    makeGraphic: (mapName: string, hostKey: string) => Group[];\n    removeGraphic: (mapName: string, hostKey: string) => void;\n};\nexport default _default;\n"
  },
  {
    "path": "echarts/types/src/coord/geo/geoSVGLoader.d.ts",
    "code": "import Group from 'zrender/esm/graphic/Group';\nimport BoundingRect from 'zrender/esm/core/BoundingRect';\nimport { SVGMapRecord } from './mapDataStorage';\ndeclare const _default: {\n    load(mapName: string, mapRecord: SVGMapRecord): {\n        root: Group;\n        boundingRect: BoundingRect;\n    };\n    makeGraphic(mapName: string, mapRecord: SVGMapRecord, hostKey: string): Group;\n    removeGraphic(mapName: string, mapRecord: SVGMapRecord, hostKey: string): void;\n};\nexport default _default;\n"
  },
  {
    "path": "echarts/types/src/coord/geo/geoTypes.d.ts",
    "code": "export interface NameMap {\n    [regionName: string]: string;\n}\nexport interface GeoSpecialAreas {\n    [areaName: string]: {\n        left: number;\n        top: number;\n        width?: number;\n        height?: number;\n    };\n}\nexport interface GeoJSON extends GeoJSONFeatureCollection<GeoJSONGeometry> {\n}\nexport interface GeoJSONCompressed extends GeoJSONFeatureCollection<GeoJSONGeometryCompressed> {\n    UTF8Encoding?: boolean;\n    UTF8Scale?: number;\n}\ninterface GeoJSONFeatureCollection<G> {\n    type: 'FeatureCollection';\n    features: GeoJSONFeature<G>[];\n}\ninterface GeoJSONFeature<G = GeoJSONGeometry> {\n    type: 'Feature';\n    id?: string | number;\n    properties: {\n        name?: string;\n        cp?: number[];\n        [key: string]: any;\n    };\n    geometry: G;\n}\ndeclare type GeoJSONGeometry = GeoJSONGeometryPoint | GeoJSONGeometryMultiPoint | GeoJSONGeometryLineString | GeoJSONGeometryMultiLineString | GeoJSONGeometryPolygon | GeoJSONGeometryMultiPolygon;\ndeclare type GeoJSONGeometryCompressed = GeoJSONGeometryPoint | GeoJSONGeometryMultiPoint | GeoJSONGeometryLineString | GeoJSONGeometryMultiLineString | GeoJSONGeometryPolygonCompressed | GeoJSONGeometryMultiPolygonCompressed;\ninterface GeoJSONGeometryPoint {\n    type: 'Point';\n    coordinates: number[];\n}\ninterface GeoJSONGeometryMultiPoint {\n    type: 'MultiPoint';\n    coordinates: number[][];\n}\ninterface GeoJSONGeometryLineString {\n    type: 'LineString';\n    coordinates: number[][];\n}\ninterface GeoJSONGeometryMultiLineString {\n    type: 'MultiLineString';\n    coordinates: number[][][];\n}\nexport interface GeoJSONGeometryPolygon {\n    type: 'Polygon';\n    coordinates: number[][][];\n}\ninterface GeoJSONGeometryPolygonCompressed {\n    type: 'Polygon';\n    coordinates: string[];\n    encodeOffsets: number[][];\n}\nexport interface GeoJSONGeometryMultiPolygon {\n    type: 'MultiPolygon';\n    coordinates: number[][][][];\n}\ninterface GeoJSONGeometryMultiPolygonCompressed {\n    type: 'MultiPolygon';\n    coordinates: string[][];\n    encodeOffsets: number[][][];\n}\nexport {};\n"
  },
  {
    "path": "echarts/types/src/coord/geo/mapDataStorage.d.ts",
    "code": "import { parseXML } from 'zrender/esm/tool/parseSVG';\nimport { GeoSpecialAreas, GeoJSON, GeoJSONCompressed } from './geoTypes';\ndeclare type SVGMapSource = 'string' | Document | SVGElement;\ndeclare type GeoJSONMapSource = 'string' | GeoJSON | GeoJSONCompressed;\ndeclare type MapInputObject = {\n    geoJSON?: GeoJSONMapSource;\n    geoJson?: GeoJSONMapSource;\n    svg?: SVGMapSource;\n    specialAreas?: GeoSpecialAreas;\n};\nexport declare type MapRecord = GeoJSONMapRecord | SVGMapRecord;\nexport interface GeoJSONMapRecord {\n    type: 'geoJSON';\n    source: GeoJSONMapSource;\n    specialAreas: GeoSpecialAreas;\n    geoJSON: GeoJSON | GeoJSONCompressed;\n}\nexport interface SVGMapRecord {\n    type: 'svg';\n    source: SVGMapSource;\n    specialAreas: GeoSpecialAreas;\n    svgXML: ReturnType<typeof parseXML>;\n}\ndeclare const _default: {\n    registerMap: (mapName: string, rawDef: \"string\" | GeoJSON | GeoJSONCompressed | MapInputObject | MapRecord[], rawSpecialAreas?: GeoSpecialAreas) => MapRecord[];\n    retrieveMap: (mapName: string) => MapRecord[];\n};\nexport default _default;\n"
  },
  {
    "path": "echarts/types/src/coord/geo/parseGeoJson.d.ts",
    "code": "import Region from './Region';\nimport { GeoJSONCompressed, GeoJSON } from './geoTypes';\nexport default function (geoJson: GeoJSON | GeoJSONCompressed, nameProperty: string): Region[];\n"
  },
  {
    "path": "echarts/types/src/coord/geo/prepareCustom.d.ts",
    "code": "import Geo from './Geo';\nexport default function (coordSys: Geo): {\n    coordSys: {\n        type: string;\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n        zoom: number;\n    };\n    api: {\n        coord: (data: number[]) => number[];\n        size: (dataSize: number[], dataItem: number[]) => number[];\n    };\n};\n"
  },
  {
    "path": "echarts/types/src/coord/geo/Region.d.ts",
    "code": "import BoundingRect from 'zrender/esm/core/BoundingRect';\nimport { GeoJSON } from './geoTypes';\ndeclare class Region {\n    readonly geometries: {\n        type: 'polygon';\n        exterior: number[][];\n        interiors?: number[][][];\n    }[];\n    readonly name: string;\n    center: number[];\n    properties: GeoJSON['features'][0]['properties'];\n    private _rect;\n    constructor(name: string, geometries: Region['geometries'], cp: GeoJSON['features'][0]['properties']['cp']);\n    getBoundingRect(): BoundingRect;\n    contain(coord: number[]): boolean;\n    transformTo(x: number, y: number, width: number, height: number): void;\n    cloneShallow(name: string): Region;\n}\nexport default Region;\n"
  },
  {
    "path": "echarts/types/src/coord/parallel/AxisModel.d.ts",
    "code": "import ComponentModel from '../../model/Component';\nimport { AxisModelExtendedInCreator } from '../axisModelCreator';\nimport { AxisModelCommonMixin } from '../axisModelCommonMixin';\nimport ParallelAxis from './ParallelAxis';\nimport { ZRColor, ParsedValue } from '../../util/types';\nimport { AxisBaseOption } from '../axisCommonTypes';\nimport Parallel from './Parallel';\nimport { PathStyleProps } from 'zrender/esm/graphic/Path';\nexport declare type ParallelActiveState = 'normal' | 'active' | 'inactive';\nexport declare type ParallelAxisInterval = number[];\ndeclare type ParallelAreaSelectStyleKey = 'fill' | 'lineWidth' | 'stroke' | 'opacity';\nexport declare type ParallelAreaSelectStyleProps = Pick<PathStyleProps, ParallelAreaSelectStyleKey> & {\n    width: number;\n};\nexport interface ParallelAxisOption extends AxisBaseOption {\n    dim?: number[];\n    parallelIndex?: number;\n    areaSelectStyle?: {\n        width?: number;\n        borderWidth?: number;\n        borderColor?: ZRColor;\n        color?: ZRColor;\n        opacity?: number;\n    };\n    realtime?: boolean;\n}\ndeclare class ParallelAxisModel extends ComponentModel<ParallelAxisOption> {\n    static type: 'baseParallelAxis';\n    readonly type: \"baseParallelAxis\";\n    axis: ParallelAxis;\n    coordinateSystem: Parallel;\n    activeIntervals: ParallelAxisInterval[];\n    getAreaSelectStyle(): ParallelAreaSelectStyleProps;\n    setActiveIntervals(intervals: ParallelAxisInterval[]): void;\n    getActiveState(value?: ParsedValue): ParallelActiveState;\n}\ninterface ParallelAxisModel extends AxisModelCommonMixin<ParallelAxisOption>, AxisModelExtendedInCreator<ParallelAxisOption> {\n}\nexport default ParallelAxisModel;\n"
  },
  {
    "path": "echarts/types/src/coord/parallel/Parallel.d.ts",
    "code": "import * as matrix from 'zrender/esm/core/matrix';\nimport ParallelAxis from './ParallelAxis';\nimport * as graphic from '../../util/graphic';\nimport ParallelModel from './ParallelModel';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { DimensionName, ScaleDataValue } from '../../util/types';\nimport { CoordinateSystem, CoordinateSystemMaster } from '../CoordinateSystem';\nimport { ParallelActiveState } from './AxisModel';\nimport List from '../../data/List';\nexport interface ParallelAxisLayoutInfo {\n    position: number[];\n    rotation: number;\n    transform: matrix.MatrixArray;\n    axisNameAvailableWidth: number;\n    axisLabelShow: boolean;\n    nameTruncateMaxWidth: number;\n    tickDirection: -1 | 1;\n    labelDirection: -1 | 1;\n}\ndeclare type SlidedAxisExpandBehavior = 'none' | 'slide' | 'jump';\ndeclare class Parallel implements CoordinateSystemMaster, CoordinateSystem {\n    readonly type = \"parallel\";\n    private _axesMap;\n    private _axesLayout;\n    readonly dimensions: ParallelModel['dimensions'];\n    private _rect;\n    private _model;\n    name: string;\n    model: ParallelModel;\n    constructor(parallelModel: ParallelModel, ecModel: GlobalModel, api: ExtensionAPI);\n    private _init;\n    update(ecModel: GlobalModel, api: ExtensionAPI): void;\n    containPoint(point: number[]): boolean;\n    getModel(): ParallelModel;\n    private _updateAxesFromSeries;\n    resize(parallelModel: ParallelModel, api: ExtensionAPI): void;\n    getRect(): graphic.BoundingRect;\n    private _makeLayoutInfo;\n    private _layoutAxes;\n    getAxis(dim: DimensionName): ParallelAxis;\n    dataToPoint(value: ScaleDataValue, dim: DimensionName): number[];\n    eachActiveState(data: List, callback: (activeState: ParallelActiveState, dataIndex: number) => void, start?: number, end?: number): void;\n    hasAxisBrushed(): boolean;\n    axisCoordToPoint(coord: number, dim: DimensionName): number[];\n    getAxisLayout(dim: DimensionName): ParallelAxisLayoutInfo;\n    getSlidedAxisExpandWindow(point: number[]): {\n        axisExpandWindow: number[];\n        behavior: SlidedAxisExpandBehavior;\n    };\n}\nexport default Parallel;\n"
  },
  {
    "path": "echarts/types/src/coord/parallel/ParallelAxis.d.ts",
    "code": "import Axis from '../Axis';\nimport Scale from '../../scale/Scale';\nimport { DimensionName } from '../../util/types';\nimport { OptionAxisType } from '../axisCommonTypes';\nimport AxisModel from './AxisModel';\nimport Parallel from './Parallel';\ndeclare class ParallelAxis extends Axis {\n    readonly axisIndex: number;\n    model: AxisModel;\n    coordinateSystem: Parallel;\n    constructor(dim: DimensionName, scale: Scale, coordExtent: [number, number], axisType: OptionAxisType, axisIndex: number);\n    isHorizontal(): boolean;\n}\nexport default ParallelAxis;\n"
  },
  {
    "path": "echarts/types/src/coord/parallel/parallelCreator.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/coord/parallel/ParallelModel.d.ts",
    "code": "import ComponentModel from '../../model/Component';\nimport Parallel from './Parallel';\nimport { DimensionName, ComponentOption, BoxLayoutOptionMixin } from '../../util/types';\nimport ParallelAxisModel, { ParallelAxisOption } from './AxisModel';\nimport GlobalModel from '../../model/Global';\nimport SeriesModel from '../../model/Series';\nexport declare type ParallelLayoutDirection = 'horizontal' | 'vertical';\nexport interface ParallelCoordinateSystemOption extends ComponentOption, BoxLayoutOptionMixin {\n    layout?: ParallelLayoutDirection;\n    axisExpandable?: boolean;\n    axisExpandCenter?: number;\n    axisExpandCount?: number;\n    axisExpandWidth?: number;\n    axisExpandTriggerOn?: 'click' | 'mousemove';\n    axisExpandRate?: number;\n    axisExpandDebounce?: number;\n    axisExpandSlideTriggerArea?: [number, number, number];\n    axisExpandWindow?: number[];\n    parallelAxisDefault?: ParallelAxisOption;\n}\ndeclare class ParallelModel extends ComponentModel<ParallelCoordinateSystemOption> {\n    static type: string;\n    readonly type: string;\n    static dependencies: string[];\n    coordinateSystem: Parallel;\n    dimensions: DimensionName[];\n    parallelAxisIndex: number[];\n    static layoutMode: \"box\";\n    static defaultOption: ParallelCoordinateSystemOption;\n    init(): void;\n    mergeOption(newOption: ParallelCoordinateSystemOption): void;\n    contains(model: SeriesModel | ParallelAxisModel, ecModel: GlobalModel): boolean;\n    setAxisExpand(opt: {\n        axisExpandable?: boolean;\n        axisExpandCenter?: number;\n        axisExpandCount?: number;\n        axisExpandWidth?: number;\n        axisExpandWindow?: number[];\n    }): void;\n    private _initDimensions;\n}\nexport default ParallelModel;\n"
  },
  {
    "path": "echarts/types/src/coord/parallel/parallelPreprocessor.d.ts",
    "code": "import { ECUnitOption } from '../../util/types';\nexport default function (option: ECUnitOption): void;\n"
  },
  {
    "path": "echarts/types/src/coord/polar/AngleAxis.d.ts",
    "code": "import Axis from '../Axis';\nimport Scale from '../../scale/Scale';\nimport Polar from './Polar';\nimport { AngleAxisModel } from './AxisModel';\ninterface AngleAxis {\n    dataToAngle: Axis['dataToCoord'];\n    angleToData: Axis['coordToData'];\n}\ndeclare class AngleAxis extends Axis {\n    polar: Polar;\n    model: AngleAxisModel;\n    constructor(scale?: Scale, angleExtent?: [number, number]);\n    pointToData(point: number[], clamp?: boolean): number;\n    calculateCategoryInterval(): number;\n}\nexport default AngleAxis;\n"
  },
  {
    "path": "echarts/types/src/coord/polar/AxisModel.d.ts",
    "code": "import ComponentModel from '../../model/Component';\nimport { AxisModelExtendedInCreator } from '../axisModelCreator';\nimport { AxisModelCommonMixin } from '../axisModelCommonMixin';\nimport { AxisBaseOption } from '../axisCommonTypes';\nimport AngleAxis from './AngleAxis';\nimport RadiusAxis from './RadiusAxis';\nimport { AxisBaseModel } from '../AxisBaseModel';\nexport interface AngleAxisOption extends AxisBaseOption {\n    polarIndex?: number;\n    polarId?: string;\n    startAngle?: number;\n    clockwise?: boolean;\n    splitNumber?: number;\n    axisLabel?: Omit<AxisBaseOption['axisLabel'], 'rotate'> & {\n        rotate?: AxisBaseOption['axisLabel']['rotate'] | false;\n    };\n}\nexport interface RadiusAxisOption extends AxisBaseOption {\n    polarIndex?: number;\n    polarId?: string;\n}\ndeclare type PolarAxisOption = AngleAxisOption | RadiusAxisOption;\ndeclare class PolarAxisModel<T extends PolarAxisOption = PolarAxisOption> extends ComponentModel<T> implements AxisBaseModel<T> {\n    static type: string;\n    axis: AngleAxis | RadiusAxis;\n    getCoordSysModel(): ComponentModel;\n}\ninterface PolarAxisModel<T extends PolarAxisOption = PolarAxisOption> extends AxisModelCommonMixin<T>, AxisModelExtendedInCreator<T> {\n}\nexport { PolarAxisModel };\nexport declare class AngleAxisModel extends PolarAxisModel<AngleAxisOption> {\n    static type: string;\n    type: string;\n    axis: AngleAxis;\n}\nexport declare class RadiusAxisModel extends PolarAxisModel<RadiusAxisOption> {\n    static type: string;\n    type: string;\n    axis: RadiusAxis;\n}\n"
  },
  {
    "path": "echarts/types/src/coord/polar/Polar.d.ts",
    "code": "import RadiusAxis from './RadiusAxis';\nimport AngleAxis from './AngleAxis';\nimport PolarModel from './PolarModel';\nimport { CoordinateSystem, CoordinateSystemMaster, CoordinateSystemClipArea } from '../CoordinateSystem';\nimport GlobalModel from '../../model/Global';\nimport { ParsedModelFinder } from '../../util/model';\nimport { ScaleDataValue } from '../../util/types';\nimport ExtensionAPI from '../../ExtensionAPI';\ninterface Polar {\n    update(ecModel: GlobalModel, api: ExtensionAPI): void;\n}\ndeclare class Polar implements CoordinateSystem, CoordinateSystemMaster {\n    readonly name: string;\n    readonly dimensions: string[];\n    readonly type = \"polar\";\n    cx: number;\n    cy: number;\n    private _radiusAxis;\n    private _angleAxis;\n    axisPointerEnabled: boolean;\n    model: PolarModel;\n    constructor(name: string);\n    containPoint(point: number[]): boolean;\n    containData(data: number[]): boolean;\n    getAxis(dim: 'radius' | 'angle'): RadiusAxis | AngleAxis;\n    getAxes(): (RadiusAxis | AngleAxis)[];\n    getAxesByScale(scaleType: 'ordinal' | 'interval' | 'time' | 'log'): (RadiusAxis | AngleAxis)[];\n    getAngleAxis(): AngleAxis;\n    getRadiusAxis(): RadiusAxis;\n    getOtherAxis(axis: AngleAxis | RadiusAxis): AngleAxis | RadiusAxis;\n    getBaseAxis(): RadiusAxis | AngleAxis;\n    getTooltipAxes(dim: 'radius' | 'angle' | 'auto'): {\n        baseAxes: (RadiusAxis | AngleAxis)[];\n        otherAxes: (RadiusAxis | AngleAxis)[];\n    };\n    dataToPoint(data: ScaleDataValue[], clamp?: boolean): number[];\n    pointToData(point: number[], clamp?: boolean): number[];\n    pointToCoord(point: number[]): number[];\n    coordToPoint(coord: number[]): number[];\n    getArea(): PolarArea;\n    convertToPixel(ecModel: GlobalModel, finder: ParsedModelFinder, value: ScaleDataValue[]): number[];\n    convertFromPixel(ecModel: GlobalModel, finder: ParsedModelFinder, pixel: number[]): number[];\n}\ninterface PolarArea extends CoordinateSystemClipArea {\n    cx: number;\n    cy: number;\n    r0: number;\n    r: number;\n    startAngle: number;\n    endAngle: number;\n    clockwise: boolean;\n}\nexport default Polar;\n"
  },
  {
    "path": "echarts/types/src/coord/polar/polarCreator.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/coord/polar/PolarModel.d.ts",
    "code": "import { ComponentOption, CircleLayoutOptionMixin } from '../../util/types';\nimport ComponentModel from '../../model/Component';\nimport Polar from './Polar';\nimport { AngleAxisModel, RadiusAxisModel } from './AxisModel';\nexport interface PolarOption extends ComponentOption, CircleLayoutOptionMixin {\n}\ndeclare class PolarModel extends ComponentModel<PolarOption> {\n    static type: \"polar\";\n    type: \"polar\";\n    static dependencies: string[];\n    coordinateSystem: Polar;\n    findAxisModel(axisType: 'angleAxis'): AngleAxisModel;\n    findAxisModel(axisType: 'radiusAxis'): RadiusAxisModel;\n    static defaultOption: PolarOption;\n}\nexport default PolarModel;\n"
  },
  {
    "path": "echarts/types/src/coord/polar/prepareCustom.d.ts",
    "code": "import Polar from './Polar';\nexport default function (coordSys: Polar): {\n    coordSys: {\n        type: string;\n        cx: number;\n        cy: number;\n        r: number;\n        r0: number;\n    };\n    api: {\n        coord: (data: number[]) => number[];\n        size: (dataSize: number[], dataItem: number[]) => number[];\n    };\n};\n"
  },
  {
    "path": "echarts/types/src/coord/polar/RadiusAxis.d.ts",
    "code": "import Axis from '../Axis';\nimport Scale from '../../scale/Scale';\nimport Polar from './Polar';\nimport { RadiusAxisModel } from './AxisModel';\ninterface RadiusAxis {\n    dataToRadius: Axis['dataToCoord'];\n    radiusToData: Axis['coordToData'];\n}\ndeclare class RadiusAxis extends Axis {\n    polar: Polar;\n    model: RadiusAxisModel;\n    constructor(scale?: Scale, radiusExtent?: [number, number]);\n    pointToData(point: number[], clamp?: boolean): number;\n}\nexport default RadiusAxis;\n"
  },
  {
    "path": "echarts/types/src/coord/radar/IndicatorAxis.d.ts",
    "code": "import Axis from '../Axis';\nimport Scale from '../../scale/Scale';\nimport { OptionAxisType } from '../axisCommonTypes';\nimport { AxisBaseModel } from '../AxisBaseModel';\nimport { InnerIndicatorAxisOption } from './RadarModel';\ndeclare class IndicatorAxis extends Axis {\n    type: OptionAxisType;\n    angle: number;\n    name: string;\n    model: AxisBaseModel<InnerIndicatorAxisOption>;\n    value?: number | string;\n    constructor(dim: string, scale: Scale, radiusExtent?: [number, number]);\n}\nexport default IndicatorAxis;\n"
  },
  {
    "path": "echarts/types/src/coord/radar/Radar.d.ts",
    "code": "import IndicatorAxis from './IndicatorAxis';\nimport { CoordinateSystemMaster, CoordinateSystem } from '../CoordinateSystem';\nimport RadarModel from './RadarModel';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport { ScaleDataValue } from '../../util/types';\nimport { ParsedModelFinder } from '../../util/model';\ndeclare class Radar implements CoordinateSystem, CoordinateSystemMaster {\n    readonly type: 'radar';\n    readonly dimensions: string[];\n    cx: number;\n    cy: number;\n    r: number;\n    r0: number;\n    startAngle: number;\n    private _model;\n    private _indicatorAxes;\n    constructor(radarModel: RadarModel, ecModel: GlobalModel, api: ExtensionAPI);\n    getIndicatorAxes(): IndicatorAxis[];\n    dataToPoint(value: ScaleDataValue, indicatorIndex: number): number[];\n    coordToPoint(coord: number, indicatorIndex: number): number[];\n    pointToData(pt: number[]): number[];\n    resize(radarModel: RadarModel, api: ExtensionAPI): void;\n    update(ecModel: GlobalModel, api: ExtensionAPI): void;\n    convertToPixel(ecModel: GlobalModel, finder: ParsedModelFinder, value: ScaleDataValue[]): never;\n    convertFromPixel(ecModel: GlobalModel, finder: ParsedModelFinder, pixel: number[]): never;\n    containPoint(point: number[]): boolean;\n    static dimensions: string[];\n    static create(ecModel: GlobalModel, api: ExtensionAPI): Radar[];\n}\nexport default Radar;\n"
  },
  {
    "path": "echarts/types/src/coord/radar/RadarModel.d.ts",
    "code": "import ComponentModel from '../../model/Component';\nimport { ComponentOption, CircleLayoutOptionMixin, LabelOption, ColorString } from '../../util/types';\nimport { AxisBaseOption } from '../axisCommonTypes';\nimport { AxisBaseModel } from '../AxisBaseModel';\nimport Radar from './Radar';\nimport { CoordinateSystemHostModel } from '../../coord/CoordinateSystem';\nexport interface RadarIndicatorOption {\n    text?: string;\n    min?: number;\n    max?: number;\n    color?: ColorString;\n    axisType?: 'value' | 'log';\n}\nexport interface RadarOption extends ComponentOption, CircleLayoutOptionMixin {\n    startAngle?: number;\n    shape?: 'polygon' | 'circle';\n    axisLine?: AxisBaseOption['axisLine'];\n    axisTick?: AxisBaseOption['axisTick'];\n    axisLabel?: AxisBaseOption['axisLabel'];\n    splitLine?: AxisBaseOption['splitLine'];\n    splitArea?: AxisBaseOption['splitArea'];\n    axisName?: {\n        show?: boolean;\n        formatter?: string | ((name?: string, indicatorOpt?: InnerIndicatorAxisOption) => string);\n    } & LabelOption;\n    axisNameGap?: number;\n    triggerEvent?: boolean;\n    scale?: boolean;\n    splitNumber?: number;\n    boundaryGap?: AxisBaseOption['boundaryGap'];\n    indicator?: RadarIndicatorOption[];\n}\nexport interface InnerIndicatorAxisOption extends AxisBaseOption {\n}\ndeclare class RadarModel extends ComponentModel<RadarOption> implements CoordinateSystemHostModel {\n    static readonly type = \"radar\";\n    readonly type = \"radar\";\n    coordinateSystem: Radar;\n    private _indicatorModels;\n    optionUpdated(): void;\n    getIndicatorModels(): AxisBaseModel<InnerIndicatorAxisOption>[];\n    static defaultOption: RadarOption;\n}\nexport default RadarModel;\n"
  },
  {
    "path": "echarts/types/src/coord/scaleRawExtentInfo.d.ts",
    "code": "import Scale from '../scale/Scale';\nimport { AxisBaseModel } from './AxisBaseModel';\nimport { ScaleDataValue } from '../util/types';\nexport interface ScaleRawExtentResult {\n    readonly min: number;\n    readonly max: number;\n    readonly minFixed: boolean;\n    readonly maxFixed: boolean;\n    readonly isBlank: boolean;\n}\nexport declare class ScaleRawExtentInfo {\n    private _needCrossZero;\n    private _isOrdinal;\n    private _axisDataLen;\n    private _boundaryGapInner;\n    private _modelMinRaw;\n    private _modelMaxRaw;\n    private _modelMinNum;\n    private _modelMaxNum;\n    private _dataMin;\n    private _dataMax;\n    private _determinedMin;\n    private _determinedMax;\n    readonly frozen: boolean;\n    constructor(scale: Scale, model: AxisBaseModel, originalExtent: number[]);\n    private _prepareParams;\n    calculate(): ScaleRawExtentResult;\n    modifyDataMinMax(minMaxName: 'min' | 'max', val: number): void;\n    setDeterminedMinMax(minMaxName: 'min' | 'max', val: number): void;\n    freeze(): void;\n}\nexport declare function ensureScaleRawExtentInfo(scale: Scale, model: AxisBaseModel, originalExtent: number[]): ScaleRawExtentInfo;\nexport declare function parseAxisModelMinMax(scale: Scale, minMax: ScaleDataValue): number;\n"
  },
  {
    "path": "echarts/types/src/coord/single/AxisModel.d.ts",
    "code": "import ComponentModel from '../../model/Component';\nimport { AxisModelExtendedInCreator } from '../axisModelCreator';\nimport { AxisModelCommonMixin } from '../axisModelCommonMixin';\nimport Single from './Single';\nimport SingleAxis from './SingleAxis';\nimport { AxisBaseOption } from '../axisCommonTypes';\nimport { BoxLayoutOptionMixin, LayoutOrient } from '../../util/types';\nimport { AxisBaseModel } from '../AxisBaseModel';\nexport declare type SingleAxisPosition = 'top' | 'bottom' | 'left' | 'right';\nexport interface SingleAxisOption extends AxisBaseOption, BoxLayoutOptionMixin {\n    position?: SingleAxisPosition;\n    orient: LayoutOrient;\n}\ndeclare class SingleAxisModel extends ComponentModel<SingleAxisOption> implements AxisBaseModel<SingleAxisOption> {\n    static type: string;\n    type: string;\n    static readonly layoutMode = \"box\";\n    axis: SingleAxis;\n    coordinateSystem: Single;\n    getCoordSysModel(): this;\n    static defaultOption: SingleAxisOption;\n}\ninterface SingleAxisModel extends AxisModelCommonMixin<SingleAxisOption>, AxisModelExtendedInCreator<SingleAxisOption> {\n}\nexport default SingleAxisModel;\n"
  },
  {
    "path": "echarts/types/src/coord/single/prepareCustom.d.ts",
    "code": "import Single from './Single';\nexport default function (coordSys: Single): {\n    coordSys: {\n        type: string;\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n    };\n    api: {\n        coord: (val: number) => number[];\n        size: (dataSize: number | number[], dataItem: number | number[]) => number;\n    };\n};\n"
  },
  {
    "path": "echarts/types/src/coord/single/Single.d.ts",
    "code": "import SingleAxis from './SingleAxis';\nimport { CoordinateSystem, CoordinateSystemMaster } from '../CoordinateSystem';\nimport GlobalModel from '../../model/Global';\nimport ExtensionAPI from '../../ExtensionAPI';\nimport BoundingRect from 'zrender/esm/core/BoundingRect';\nimport SingleAxisModel from './AxisModel';\nimport { ParsedModelFinder } from '../../util/model';\nimport { ScaleDataValue } from '../../util/types';\ndeclare class Single implements CoordinateSystem, CoordinateSystemMaster {\n    readonly type = \"single\";\n    readonly dimension = \"single\";\n    readonly dimensions: string[];\n    name: string;\n    axisPointerEnabled: boolean;\n    model: SingleAxisModel;\n    private _axis;\n    private _rect;\n    constructor(axisModel: SingleAxisModel, ecModel: GlobalModel, api: ExtensionAPI);\n    _init(axisModel: SingleAxisModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    update(ecModel: GlobalModel, api: ExtensionAPI): void;\n    resize(axisModel: SingleAxisModel, api: ExtensionAPI): void;\n    getRect(): BoundingRect;\n    private _adjustAxis;\n    private _updateAxisTransform;\n    getAxis(): SingleAxis;\n    getBaseAxis(): SingleAxis;\n    getAxes(): SingleAxis[];\n    getTooltipAxes(): {\n        baseAxes: SingleAxis[];\n        otherAxes: SingleAxis[];\n    };\n    containPoint(point: number[]): boolean;\n    pointToData(point: number[]): number[];\n    dataToPoint(val: ScaleDataValue | ScaleDataValue[]): number[];\n    convertToPixel(ecModel: GlobalModel, finder: ParsedModelFinder, value: ScaleDataValue[]): number[];\n    convertFromPixel(ecModel: GlobalModel, finder: ParsedModelFinder, pixel: number[]): number[];\n}\nexport default Single;\n"
  },
  {
    "path": "echarts/types/src/coord/single/SingleAxis.d.ts",
    "code": "import Axis from '../Axis';\nimport Scale from '../../scale/Scale';\nimport { OptionAxisType } from '../axisCommonTypes';\nimport SingleAxisModel, { SingleAxisPosition } from './AxisModel';\nimport { LayoutOrient } from '../../util/types';\nimport Single from './Single';\ninterface SingleAxis {\n    toLocalCoord(coord: number): number;\n    toGlobalCoord(coord: number): number;\n}\ndeclare class SingleAxis extends Axis {\n    position: SingleAxisPosition;\n    orient: LayoutOrient;\n    reverse: boolean;\n    coordinateSystem: Single;\n    model: SingleAxisModel;\n    constructor(dim: string, scale: Scale, coordExtent: [number, number], axisType?: OptionAxisType, position?: SingleAxisPosition);\n    isHorizontal(): boolean;\n    pointToData(point: number[], clamp?: boolean): number;\n}\nexport default SingleAxis;\n"
  },
  {
    "path": "echarts/types/src/coord/single/singleAxisHelper.d.ts",
    "code": "import SingleAxisModel from './AxisModel';\ninterface LayoutResult {\n    position: [number, number];\n    rotation: number;\n    labelRotation: number;\n    labelDirection: number;\n    tickDirection: number;\n    nameDirection: number;\n    z2: number;\n}\nexport declare function layout(axisModel: SingleAxisModel, opt?: {\n    labelInside?: boolean;\n    rotate?: number;\n}): LayoutResult;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/coord/single/singleCreator.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "echarts/types/src/coord/View.d.ts",
    "code": "import * as matrix from 'zrender/esm/core/matrix';\nimport BoundingRect from 'zrender/esm/core/BoundingRect';\nimport Transformable from 'zrender/esm/core/Transformable';\nimport { CoordinateSystemMaster, CoordinateSystem } from './CoordinateSystem';\nimport GlobalModel from '../model/Global';\nimport { ParsedModelFinder } from '../util/model';\ndeclare class View extends Transformable implements CoordinateSystemMaster, CoordinateSystem {\n    readonly type: string;\n    static dimensions: string[];\n    readonly dimensions: string[];\n    readonly name: string;\n    zoomLimit: {\n        max?: number;\n        min?: number;\n    };\n    private _roamTransformable;\n    protected _rawTransformable: Transformable;\n    private _center;\n    private _zoom;\n    protected _rect: BoundingRect;\n    private _viewRect;\n    private _rawTransform;\n    constructor(name?: string);\n    setBoundingRect(x: number, y: number, width: number, height: number): BoundingRect;\n    getBoundingRect(): BoundingRect;\n    setViewRect(x: number, y: number, width: number, height: number): void;\n    transformTo(x: number, y: number, width: number, height: number): void;\n    setCenter(centerCoord?: number[]): void;\n    setZoom(zoom: number): void;\n    getDefaultCenter(): number[];\n    getCenter(): number[];\n    getZoom(): number;\n    getRoamTransform(): matrix.MatrixArray;\n    private _updateCenterAndZoom;\n    protected _updateTransform(): void;\n    getTransformInfo(): {\n        roamTransform: number[];\n        rawScaleX: number;\n        rawScaleY: number;\n        rawX: number;\n        rawY: number;\n    };\n    getViewRect(): BoundingRect;\n    getViewRectAfterRoam(): BoundingRect;\n    dataToPoint(data: number[], noRoam?: boolean, out?: number[]): number[];\n    pointToData(point: number[]): number[];\n    convertToPixel(ecModel: GlobalModel, finder: ParsedModelFinder, value: number[]): number[];\n    convertFromPixel(ecModel: GlobalModel, finder: ParsedModelFinder, pixel: number[]): number[];\n    containPoint(point: number[]): boolean;\n}\nexport default View;\n"
  },
  {
    "path": "echarts/types/src/CoordinateSystem.d.ts",
    "code": "import GlobalModel from './model/Global';\nimport ExtensionAPI from './ExtensionAPI';\nimport { CoordinateSystemCreator, CoordinateSystemMaster } from './coord/CoordinateSystem';\ndeclare class CoordinateSystemManager {\n    private _coordinateSystems;\n    create(ecModel: GlobalModel, api: ExtensionAPI): void;\n    update(ecModel: GlobalModel, api: ExtensionAPI): void;\n    getCoordinateSystems(): CoordinateSystemMaster[];\n    static register: (type: string, creator: CoordinateSystemCreator) => void;\n    static get: (type: string) => CoordinateSystemCreator;\n}\nexport default CoordinateSystemManager;\n"
  },
  {
    "path": "echarts/types/src/data/DataDiffer.d.ts",
    "code": "import { ArrayLike } from 'zrender/esm/core/types';\nexport declare type DiffKeyGetter = (this: DataDiffer, value: unknown, index: number) => string;\nexport declare type DiffCallbackAdd = (newIndex: number) => void;\nexport declare type DiffCallbackUpdate = (newIndex: number, oldIndex: number) => void;\nexport declare type DiffCallbackRemove = (oldIndex: number) => void;\ndeclare class DataDiffer<Ctx = unknown> {\n    private _old;\n    private _new;\n    private _oldKeyGetter;\n    private _newKeyGetter;\n    private _add;\n    private _update;\n    private _remove;\n    readonly context: Ctx;\n    constructor(oldArr: ArrayLike<unknown>, newArr: ArrayLike<unknown>, oldKeyGetter?: DiffKeyGetter, newKeyGetter?: DiffKeyGetter, context?: Ctx);\n    add(func: DiffCallbackAdd): DataDiffer;\n    update(func: DiffCallbackUpdate): DataDiffer;\n    remove(func: DiffCallbackRemove): DataDiffer;\n    execute(): void;\n    private _initIndexMap;\n}\nexport default DataDiffer;\n"
  },
  {
    "path": "echarts/types/src/data/DataDimensionInfo.d.ts",
    "code": "import OrdinalMeta from './OrdinalMeta';\nimport { DataVisualDimensions, DimensionType } from '../util/types';\ndeclare class DataDimensionInfo {\n    type?: DimensionType;\n    name: string;\n    displayName?: string;\n    tooltip?: boolean;\n    coordDim?: string;\n    coordDimIndex?: number;\n    index?: number;\n    otherDims?: DataVisualDimensions;\n    isExtraCoord?: boolean;\n    isCalculationCoord?: boolean;\n    defaultTooltip?: boolean;\n    ordinalMeta?: OrdinalMeta;\n    createInvertedIndices?: boolean;\n    constructor(opt?: object | DataDimensionInfo);\n}\nexport default DataDimensionInfo;\n"
  },
  {
    "path": "echarts/types/src/data/Graph.d.ts",
    "code": "import { Dictionary } from 'zrender/esm/core/types';\nimport List from './List';\nimport Model from '../model/Model';\nimport Element from 'zrender/esm/Element';\ndeclare class Graph {\n    type: 'graph';\n    readonly nodes: GraphNode[];\n    readonly edges: GraphEdge[];\n    data: List;\n    edgeData: List;\n    private _directed;\n    private _nodesMap;\n    private _edgesMap;\n    constructor(directed?: boolean);\n    isDirected(): boolean;\n    addNode(id: string | number, dataIndex?: number): GraphNode;\n    getNodeByIndex(dataIndex: number): GraphNode;\n    getNodeById(id: string): GraphNode;\n    addEdge(n1: GraphNode | number | string, n2: GraphNode | number | string, dataIndex?: number): GraphEdge;\n    getEdgeByIndex(dataIndex: number): GraphEdge;\n    getEdge(n1: string | GraphNode, n2: string | GraphNode): GraphEdge;\n    eachNode<Ctx>(cb: (this: Ctx, node: GraphNode, idx: number) => void, context?: Ctx): void;\n    eachEdge<Ctx>(cb: (this: Ctx, edge: GraphEdge, idx: number) => void, context?: Ctx): void;\n    breadthFirstTraverse<Ctx>(cb: (this: Ctx, node: GraphNode, fromNode: GraphNode) => boolean | void, startNode: GraphNode | string, direction: 'none' | 'in' | 'out', context?: Ctx): void;\n    update(): void;\n    clone(): Graph;\n}\ndeclare class GraphNode {\n    id: string;\n    inEdges: GraphEdge[];\n    outEdges: GraphEdge[];\n    edges: GraphEdge[];\n    hostGraph: Graph;\n    dataIndex: number;\n    __visited: boolean;\n    constructor(id?: string, dataIndex?: number);\n    degree(): number;\n    inDegree(): number;\n    outDegree(): number;\n    getModel<T = unknown>(): Model<T>;\n    getModel<T = unknown, S extends keyof T = keyof T>(path: S): Model<T[S]>;\n    getAdjacentDataIndices(): {\n        node: number[];\n        edge: number[];\n    };\n}\ndeclare class GraphEdge {\n    node1: GraphNode;\n    node2: GraphNode;\n    dataIndex: number;\n    hostGraph: Graph;\n    constructor(n1: GraphNode, n2: GraphNode, dataIndex?: number);\n    getModel<T = unknown>(): Model<T>;\n    getModel<T = unknown, S extends keyof T = keyof T>(path: S): Model<T[S]>;\n    getAdjacentDataIndices(): {\n        node: number[];\n        edge: number[];\n    };\n}\ndeclare type GetDataName<Host> = Host extends GraphEdge ? 'edgeData' : 'data';\ndeclare function createGraphDataProxyMixin<Host extends GraphEdge | GraphNode>(hostName: 'hostGraph', dataName: GetDataName<Host>): {\n    getValue(this: Host, dimension?: string | number): string | number;\n    setVisual(this: Host, key: string | Dictionary<any>, value?: any): void;\n    getVisual(this: Host, key: string): any;\n    setLayout(this: Host, layout: any, merge?: boolean): void;\n    getLayout(this: Host): any;\n    getGraphicEl(this: Host): Element<import(\"zrender/esm/Element\").ElementProps>;\n    getRawIndex(this: Host): number;\n};\ninterface GraphEdge extends ReturnType<typeof createGraphDataProxyMixin> {\n}\ninterface GraphNode extends ReturnType<typeof createGraphDataProxyMixin> {\n}\nexport default Graph;\nexport { GraphNode, GraphEdge };\n"
  },
  {
    "path": "echarts/types/src/data/helper/completeDimensions.d.ts",
    "code": "import { HashMap } from 'zrender/esm/core/util';\nimport Source from '../Source';\nimport { DimensionDefinitionLoose, OptionSourceData, EncodeDefaulter, OptionEncodeValue, OptionEncode, DimensionName } from '../../util/types';\nimport DataDimensionInfo from '../DataDimensionInfo';\nimport List from '../List';\nimport { CoordDimensionDefinitionLoose } from './createDimensions';\ndeclare function completeDimensions(sysDims: CoordDimensionDefinitionLoose[], source: Source | List | OptionSourceData, opt: {\n    dimsDef?: DimensionDefinitionLoose[];\n    encodeDef?: HashMap<OptionEncodeValue, DimensionName> | OptionEncode;\n    dimCount?: number;\n    encodeDefaulter?: EncodeDefaulter;\n    generateCoord?: string;\n    generateCoordCount?: number;\n}): DataDimensionInfo[];\nexport default completeDimensions;\n"
  },
  {
    "path": "echarts/types/src/data/helper/createDimensions.d.ts",
    "code": "import { DimensionDefinitionLoose, OptionEncode, OptionEncodeValue, EncodeDefaulter, OptionSourceData, DimensionName, DimensionDefinition, DataVisualDimensions, DimensionIndex } from '../../util/types';\nimport Source from '../Source';\nimport List from '../List';\nimport DataDimensionInfo from '../DataDimensionInfo';\nimport { HashMap } from 'zrender/esm/core/util';\nimport OrdinalMeta from '../OrdinalMeta';\nexport interface CoordDimensionDefinition extends DimensionDefinition {\n    dimsDef?: (DimensionName | {\n        name: DimensionName;\n        defaultTooltip?: boolean;\n    })[];\n    otherDims?: DataVisualDimensions;\n    ordinalMeta?: OrdinalMeta;\n    coordDim?: DimensionName;\n    coordDimIndex?: DimensionIndex;\n}\nexport declare type CoordDimensionDefinitionLoose = CoordDimensionDefinition['name'] | CoordDimensionDefinition;\nexport declare type CreateDimensionsParams = {\n    coordDimensions?: CoordDimensionDefinitionLoose[];\n    dimensionsDefine?: DimensionDefinitionLoose[];\n    encodeDefine?: HashMap<OptionEncodeValue, DimensionName> | OptionEncode;\n    dimensionsCount?: number;\n    encodeDefaulter?: EncodeDefaulter;\n    generateCoord?: string;\n    generateCoordCount?: number;\n};\nexport default function (source: Source | List | OptionSourceData, opt?: CreateDimensionsParams): DataDimensionInfo[];\n"
  },
  {
    "path": "echarts/types/src/data/helper/dataProvider.d.ts",
    "code": "import Source from '../Source';\nimport { ArrayLike } from 'zrender/esm/core/types';\nimport { DimensionName, DimensionIndex, OptionSourceData, DimensionIndexLoose, OptionDataItem, OptionDataValue, DimensionDefinition, SourceFormat, SeriesLayoutBy } from '../../util/types';\nimport List from '../List';\nexport interface DataProvider {\n    pure: boolean;\n    persistent: boolean;\n    getSource(): Source;\n    count(): number;\n    getItem(idx: number, out?: OptionDataItem): OptionDataItem;\n    appendData(newData: ArrayLike<OptionDataItem>): void;\n    clean(): void;\n}\nexport declare class DefaultDataProvider implements DataProvider {\n    private _source;\n    private _data;\n    private _offset;\n    private _dimSize;\n    pure: boolean;\n    persistent: boolean;\n    static protoInitialize: void;\n    constructor(sourceParam: Source | OptionSourceData, dimSize?: number);\n    getSource(): Source;\n    count(): number;\n    getItem(idx: number, out?: ArrayLike<number>): OptionDataItem;\n    appendData(newData: OptionSourceData): void;\n    clean(): void;\n    private static internalField;\n}\ndeclare type RawSourceItemGetter = (rawData: OptionSourceData, startIndex: number, dimsDef: DimensionDefinition[], idx: number) => OptionDataItem;\nexport declare function getRawSourceItemGetter(sourceFormat: SourceFormat, seriesLayoutBy: SeriesLayoutBy): RawSourceItemGetter;\ndeclare type RawSourceDataCounter = (rawData: OptionSourceData, startIndex: number, dimsDef: DimensionDefinition[]) => number;\nexport declare function getRawSourceDataCounter(sourceFormat: SourceFormat, seriesLayoutBy: SeriesLayoutBy): RawSourceDataCounter;\ndeclare type RawSourceValueGetter = (dataItem: OptionDataItem, dimIndex: DimensionIndex, dimName: DimensionName) => OptionDataValue | OptionDataItem;\nexport declare function getRawSourceValueGetter(sourceFormat: SourceFormat): RawSourceValueGetter;\nexport declare function retrieveRawValue(data: List, dataIndex: number, dim?: DimensionName | DimensionIndexLoose): any;\nexport declare function retrieveRawAttr(data: List, dataIndex: number, attr: string): any;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/data/helper/dataStackHelper.d.ts",
    "code": "import DataDimensionInfo from '../DataDimensionInfo';\nimport SeriesModel from '../../model/Series';\nimport List from '../List';\nimport { SeriesOption, SeriesStackOptionMixin, DimensionName } from '../../util/types';\ninterface DataStackResult {\n    stackedDimension: string;\n    stackedByDimension: string;\n    isStackedByIndex: boolean;\n    stackedOverDimension: string;\n    stackResultDimension: string;\n}\nexport declare function enableDataStack(seriesModel: SeriesModel<SeriesOption & SeriesStackOptionMixin>, dimensionInfoList: (DataDimensionInfo | string)[], opt?: {\n    stackedCoordDimension?: string;\n    byIndex?: boolean;\n}): DataStackResult;\nexport declare function isDimensionStacked(data: List, stackedDim: string): boolean;\nexport declare function getStackedDimension(data: List, targetDim: string): DimensionName;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/data/helper/dimensionHelper.d.ts",
    "code": "import List, { ListDimensionType } from '../List';\nimport { DimensionName, DimensionUserOuput } from '../../util/types';\nexport declare type DimensionSummaryEncode = {\n    defaultedLabel: DimensionName[];\n    defaultedTooltip: DimensionName[];\n    [coordOrVisualDimName: string]: DimensionName[];\n};\nexport declare type DimensionSummary = {\n    encode: DimensionSummaryEncode;\n    userOutput: DimensionUserOuput;\n    dataDimsOnCoord: DimensionName[];\n    encodeFirstDimNotExtra: {\n        [coordDim: string]: DimensionName;\n    };\n};\nexport declare function summarizeDimensions(data: List): DimensionSummary;\nexport declare function getDimensionTypeByAxis(axisType: string): ListDimensionType;\n"
  },
  {
    "path": "echarts/types/src/data/helper/linkList.d.ts",
    "code": "import List from '../List';\nimport { SeriesDataType } from '../../util/types';\ndeclare type Datas = {\n    [key in SeriesDataType]?: List;\n};\ndeclare type StructReferDataAttr = 'data' | 'edgeData';\ndeclare type StructAttr = 'tree' | 'graph';\ndeclare type LinkListOpt = {\n    mainData: List;\n    struct: {\n        update: () => void;\n    } & {\n        [key in StructReferDataAttr]?: List;\n    };\n    structAttr: StructAttr;\n    datas?: Datas;\n    datasAttr?: {\n        [key in SeriesDataType]?: StructReferDataAttr;\n    };\n};\ndeclare function linkList(opt: LinkListOpt): void;\nexport default linkList;\n"
  },
  {
    "path": "echarts/types/src/data/helper/parseDataValue.d.ts",
    "code": "import { ParsedValue, DimensionType } from '../../util/types';\nimport OrdinalMeta from '../OrdinalMeta';\nexport declare function parseDataValue(value: any, opt: {\n    type?: DimensionType;\n    ordinalMeta?: OrdinalMeta;\n}): ParsedValue;\n"
  },
  {
    "path": "echarts/types/src/data/helper/sourceHelper.d.ts",
    "code": "import Source, { SourceMetaRawOption } from '../Source';\nimport { SourceFormat, OptionSourceData, SeriesLayoutBy, OptionSourceHeader, DimensionName, DimensionDefinition, DimensionDefinitionLoose, OptionEncode, DimensionIndex, SeriesEncodableModel } from '../../util/types';\nimport { DatasetModel, DatasetOption } from '../../component/dataset';\nimport SeriesModel from '../../model/Series';\nimport GlobalModel from '../../model/Global';\nimport { CoordDimensionDefinition } from './createDimensions';\nexport declare const BE_ORDINAL: {\n    Must: number;\n    Might: number;\n    Not: number;\n};\ndeclare type BeOrdinalValue = (typeof BE_ORDINAL)[keyof typeof BE_ORDINAL];\ndeclare type SeriesEncodeInternal = {\n    [key in keyof OptionEncode]: DimensionIndex[];\n};\nexport declare function detectSourceFormat(data: DatasetOption['source']): SourceFormat;\nexport declare function resetSourceDefaulter(ecModel: GlobalModel): void;\nexport declare function createSource(sourceData: OptionSourceData, thisMetaRawOption: SourceMetaRawOption, sourceFormat: SourceFormat, encodeDefine: OptionEncode): Source;\nexport declare function inheritSourceMetaRawOption(opt: {\n    parent: SourceMetaRawOption;\n    thisNew: SourceMetaRawOption;\n}): SourceMetaRawOption;\nexport declare function cloneSourceShallow(source: Source): Source;\nexport declare function determineSourceDimensions(data: OptionSourceData, sourceFormat: SourceFormat, seriesLayoutBy: SeriesLayoutBy, sourceHeader: OptionSourceHeader, dimensionsDefine: DimensionDefinitionLoose[]): {\n    dimensionsDefine: DimensionDefinition[];\n    startIndex: number;\n    dimensionsDetectCount: number;\n};\nexport declare function makeSeriesEncodeForAxisCoordSys(coordDimensions: (DimensionName | CoordDimensionDefinition)[], seriesModel: SeriesModel, source: Source): SeriesEncodeInternal;\nexport declare function makeSeriesEncodeForNameBased(seriesModel: SeriesModel, source: Source, dimCount: number): SeriesEncodeInternal;\nexport declare function querySeriesUpstreamDatasetModel(seriesModel: SeriesEncodableModel): DatasetModel;\nexport declare function queryDatasetUpstreamDatasetModels(datasetModel: DatasetModel): DatasetModel[];\nexport declare function guessOrdinal(source: Source, dimIndex: DimensionIndex): BeOrdinalValue;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/data/helper/sourceManager.d.ts",
    "code": "import { DatasetModel } from '../../component/dataset';\nimport SeriesModel from '../../model/Series';\nimport Source from '../Source';\nexport declare class SourceManager {\n    private _sourceHost;\n    private _sourceList;\n    private _upstreamSignList;\n    private _versionSignBase;\n    constructor(sourceHost: DatasetModel | SeriesModel);\n    dirty(): void;\n    private _setLocalSource;\n    private _getVersionSign;\n    prepareSource(): void;\n    private _createSource;\n    private _applyTransform;\n    private _isDirty;\n    getSource(sourceIndex?: number): Source;\n    private _getUpstreamSourceManagers;\n    private _createSourceMetaRawOption;\n}\nexport declare function disableTransformOptionMerge(datasetModel: DatasetModel): void;\n"
  },
  {
    "path": "echarts/types/src/data/helper/transform.d.ts",
    "code": "import { OptionSourceData, DimensionDefinitionLoose, OptionSourceHeader, SourceFormat, DimensionDefinition, OptionDataItem, DimensionIndex, OptionDataValue, DimensionLoose, ParsedValue } from '../../util/types';\nimport Source from '../Source';\nexport declare type PipedDataTransformOption = DataTransformOption[];\nexport declare type DataTransformType = string;\nexport declare type DataTransformConfig = unknown;\nexport interface DataTransformOption {\n    type: DataTransformType;\n    config: DataTransformConfig;\n    print?: boolean;\n}\nexport interface DataTransformResult {\n    source: Source;\n}\nexport interface DataTransform {\n    (sourceList: Source[], config: DataTransformConfig): {};\n}\nexport interface ExternalDataTransform<TO extends DataTransformOption = DataTransformOption> {\n    type: string;\n    transform?: (param: ExternalDataTransformParam<TO>) => ExternalDataTransformResultItem | ExternalDataTransformResultItem[];\n}\ninterface ExternalDataTransformParam<TO extends DataTransformOption = DataTransformOption> {\n    source: ExternalSource;\n    sourceList: ExternalSource[];\n    config: TO['config'];\n}\nexport interface ExternalDataTransformResultItem {\n    data: OptionSourceData;\n    dimensions?: DimensionDefinitionLoose[];\n    sourceHeader?: OptionSourceHeader;\n}\ninterface ExternalDimensionDefinition extends DimensionDefinition {\n    index: DimensionIndex;\n}\ndeclare class ExternalSource {\n    data: OptionSourceData;\n    sourceFormat: SourceFormat;\n    sourceHeaderCount: number;\n    getDimensionInfo(dim: DimensionLoose): ExternalDimensionDefinition;\n    getDimensionInfoAll(): ExternalDimensionDefinition[];\n    getRawDataItem(dataIndex: number): OptionDataItem;\n    getRawHeaderItem(dataIndex: number): OptionDataItem;\n    count(): number;\n    retrieveItemValue(rawItem: OptionDataItem, dimIndex: DimensionIndex): OptionDataValue;\n    convertDataValue(rawVal: unknown, dimInfo: ExternalDimensionDefinition): ParsedValue;\n}\nexport declare function registerExternalTransform(externalTransform: ExternalDataTransform): void;\nexport declare function applyDataTransform(rawTransOption: DataTransformOption | PipedDataTransformOption, sourceList: Source[], infoForPrint: {\n    datasetIndex: number;\n}): Source[];\nexport {};\n"
  },
  {
    "path": "echarts/types/src/data/List.d.ts",
    "code": "import Model from '../model/Model';\nimport DataDiffer from './DataDiffer';\nimport { DataProvider } from './helper/dataProvider';\nimport DataDimensionInfo from './DataDimensionInfo';\nimport { ArrayLike, Dictionary, FunctionPropertyNames } from 'zrender/esm/core/types';\nimport Element from 'zrender/esm/Element';\nimport { DimensionIndex, DimensionName, DimensionLoose, OptionDataItem, ParsedValue, ParsedValueNumeric, OrdinalNumber, DimensionUserOuput, SeriesDataType } from '../util/types';\nimport { PathStyleProps } from 'zrender/esm/graphic/Path';\nimport Graph from './Graph';\nimport Tree from './Tree';\nimport { VisualMeta } from '../component/visualMap/VisualMapModel';\ndeclare const dataCtors: {\n    float: ArrayConstructor | Float64ArrayConstructor;\n    int: ArrayConstructor | Int32ArrayConstructor;\n    ordinal: ArrayConstructor;\n    number: ArrayConstructor;\n    time: ArrayConstructor;\n};\nexport declare type ListDimensionType = keyof typeof dataCtors;\ndeclare type DimValueGetter = (this: List, dataItem: any, dimName: DimensionName, dataIndex: number, dimIndex: DimensionIndex) => ParsedValue;\ndeclare type ItrParamDims = DimensionLoose | Array<DimensionLoose>;\ndeclare type CtxOrList<Ctx> = unknown extends Ctx ? List : Ctx;\ndeclare type EachCb0<Ctx> = (this: CtxOrList<Ctx>, idx: number) => void;\ndeclare type EachCb1<Ctx> = (this: CtxOrList<Ctx>, x: ParsedValue, idx: number) => void;\ndeclare type EachCb2<Ctx> = (this: CtxOrList<Ctx>, x: ParsedValue, y: ParsedValue, idx: number) => void;\ndeclare type EachCb<Ctx> = (this: CtxOrList<Ctx>, ...args: any) => void;\ndeclare type FilterCb0<Ctx> = (this: CtxOrList<Ctx>, idx: number) => boolean;\ndeclare type FilterCb1<Ctx> = (this: CtxOrList<Ctx>, x: ParsedValue, idx: number) => boolean;\ndeclare type FilterCb2<Ctx> = (this: CtxOrList<Ctx>, x: ParsedValue, y: ParsedValue, idx: number) => boolean;\ndeclare type FilterCb<Ctx> = (this: CtxOrList<Ctx>, ...args: any) => boolean;\ndeclare type MapArrayCb0<Ctx> = (this: CtxOrList<Ctx>, idx: number) => any;\ndeclare type MapArrayCb1<Ctx> = (this: CtxOrList<Ctx>, x: ParsedValue, idx: number) => any;\ndeclare type MapArrayCb2<Ctx> = (this: CtxOrList<Ctx>, x: ParsedValue, y: ParsedValue, idx: number) => any;\ndeclare type MapArrayCb<Ctx> = (this: CtxOrList<Ctx>, ...args: any) => any;\ndeclare type MapCb1<Ctx> = (this: CtxOrList<Ctx>, x: ParsedValue, idx: number) => ParsedValue | ParsedValue[];\ndeclare type MapCb2<Ctx> = (this: CtxOrList<Ctx>, x: ParsedValue, y: ParsedValue, idx: number) => ParsedValue | ParsedValue[];\nexport interface DefaultDataVisual {\n    style: PathStyleProps;\n    drawType: 'fill' | 'stroke';\n    symbol?: string;\n    symbolSize?: number | number[];\n    symbolRotate?: number;\n    symbolKeepAspect?: boolean;\n    liftZ?: number;\n    legendSymbol?: string;\n    visualMeta?: VisualMeta[];\n    colorFromPalette?: boolean;\n}\ndeclare class List<HostModel extends Model = Model, Visual extends DefaultDataVisual = DefaultDataVisual> {\n    readonly type = \"list\";\n    readonly dimensions: string[];\n    private _dimensionInfos;\n    readonly hostModel: HostModel;\n    dataType: SeriesDataType;\n    graph?: Graph;\n    tree?: Tree;\n    private _indices;\n    private _count;\n    private _rawCount;\n    private _storage;\n    private _nameList;\n    private _idList;\n    private _visual;\n    private _layout;\n    private _itemVisuals;\n    private _itemLayouts;\n    private _graphicEls;\n    private _chunkSize;\n    private _chunkCount;\n    private _rawData;\n    private _rawExtent;\n    private _extent;\n    private _approximateExtent;\n    private _dimensionsSummary;\n    private _invertedIndicesMap;\n    private _calculationInfo;\n    readonly userOutput: DimensionUserOuput;\n    hasItemOption: boolean;\n    defaultDimValueGetter: DimValueGetter;\n    private _dimValueGetter;\n    private _dimValueGetterArrayRows;\n    private _nameRepeatCount;\n    private _nameDimIdx;\n    private _idDimIdx;\n    private __wrappedMethods;\n    TRANSFERABLE_METHODS: readonly [\"cloneShallow\", \"downSample\", \"map\"];\n    CHANGABLE_METHODS: readonly [\"filterSelf\", \"selectRange\"];\n    constructor(dimensions: Array<string | object | DataDimensionInfo>, hostModel: HostModel);\n    getDimension(dim: DimensionLoose): DimensionName;\n    getDimensionInfo(dim: DimensionLoose): DataDimensionInfo;\n    getDimensionsOnCoord(): DimensionName[];\n    mapDimension(coordDim: DimensionName): DimensionName;\n    mapDimension(coordDim: DimensionName, idx: number): DimensionName;\n    mapDimensionsAll(coordDim: DimensionName): DimensionName[];\n    initData(data: any, nameList?: string[], dimValueGetter?: DimValueGetter): void;\n    getProvider(): DataProvider;\n    appendData(data: ArrayLike<any>): void;\n    appendValues(values: any[][], names?: string[]): void;\n    private _initDataFromProvider;\n    count(): number;\n    getIndices(): ArrayLike<number>;\n    get(dim: DimensionName, idx: number): ParsedValue;\n    getByRawIndex(dim: DimensionName, rawIdx: number): ParsedValue;\n    private _getFast;\n    getValues(idx: number): ParsedValue[];\n    getValues(dimensions: readonly DimensionName[], idx: number): ParsedValue[];\n    hasValue(idx: number): boolean;\n    getDataExtent(dim: DimensionLoose): [number, number];\n    getApproximateExtent(dim: DimensionLoose): [number, number];\n    setApproximateExtent(extent: [number, number], dim: DimensionLoose): void;\n    getCalculationInfo(key: string): any;\n    setCalculationInfo(key: string | object, value?: any): void;\n    getSum(dim: DimensionName): number;\n    getMedian(dim: DimensionLoose): number;\n    rawIndexOf(dim: DimensionName, value: OrdinalNumber): number;\n    indexOfName(name: string): number;\n    indexOfRawIndex(rawIndex: number): number;\n    indicesOfNearest(dim: DimensionName, value: number, maxDistance?: number): number[];\n    getRawIndex: (idx: number) => number;\n    getRawDataItem(idx: number): OptionDataItem;\n    getName(idx: number): string;\n    getId(idx: number): string;\n    each<Ctx>(cb: EachCb0<Ctx>, ctx?: Ctx, ctxCompat?: Ctx): void;\n    each<Ctx>(dims: DimensionLoose, cb: EachCb1<Ctx>, ctx?: Ctx, ctxCompat?: Ctx): void;\n    each<Ctx>(dims: [DimensionLoose], cb: EachCb1<Ctx>, ctx?: Ctx, ctxCompat?: Ctx): void;\n    each<Ctx>(dims: [DimensionLoose, DimensionLoose], cb: EachCb2<Ctx>, ctx?: Ctx, ctxCompat?: Ctx): void;\n    each<Ctx>(dims: ItrParamDims, cb: EachCb<Ctx>, ctx?: Ctx, ctxCompat?: Ctx): void;\n    filterSelf<Ctx>(cb: FilterCb0<Ctx>, ctx?: Ctx, ctxCompat?: Ctx): this;\n    filterSelf<Ctx>(dims: DimensionLoose, cb: FilterCb1<Ctx>, ctx?: Ctx, ctxCompat?: Ctx): this;\n    filterSelf<Ctx>(dims: [DimensionLoose], cb: FilterCb1<Ctx>, ctx?: Ctx, ctxCompat?: Ctx): this;\n    filterSelf<Ctx>(dims: [DimensionLoose, DimensionLoose], cb: FilterCb2<Ctx>, ctx?: Ctx, ctxCompat?: Ctx): this;\n    filterSelf<Ctx>(dims: ItrParamDims, cb: FilterCb<Ctx>, ctx?: Ctx, ctxCompat?: Ctx): this;\n    selectRange(range: {\n        [dimName: string]: [number, number];\n    }): List;\n    mapArray<Ctx, Cb extends MapArrayCb0<Ctx>>(cb: Cb, ctx?: Ctx, ctxCompat?: Ctx): ReturnType<Cb>[];\n    mapArray<Ctx, Cb extends MapArrayCb1<Ctx>>(dims: DimensionLoose, cb: Cb, ctx?: Ctx, ctxCompat?: Ctx): ReturnType<Cb>[];\n    mapArray<Ctx, Cb extends MapArrayCb1<Ctx>>(dims: [DimensionLoose], cb: Cb, ctx?: Ctx, ctxCompat?: Ctx): ReturnType<Cb>[];\n    mapArray<Ctx, Cb extends MapArrayCb2<Ctx>>(dims: [DimensionLoose, DimensionLoose], cb: Cb, ctx?: Ctx, ctxCompat?: Ctx): ReturnType<Cb>[];\n    mapArray<Ctx, Cb extends MapArrayCb<Ctx>>(dims: ItrParamDims, cb: Cb, ctx?: Ctx, ctxCompat?: Ctx): ReturnType<Cb>[];\n    map<Ctx>(dims: DimensionLoose, cb: MapCb1<Ctx>, ctx?: Ctx, ctxCompat?: Ctx): List<HostModel>;\n    map<Ctx>(dims: [DimensionLoose], cb: MapCb1<Ctx>, ctx?: Ctx, ctxCompat?: Ctx): List<HostModel>;\n    map<Ctx>(dims: [DimensionLoose, DimensionLoose], cb: MapCb2<Ctx>, ctx?: Ctx, ctxCompat?: Ctx): List<HostModel>;\n    downSample(dimension: DimensionName, rate: number, sampleValue: (frameValues: ArrayLike<ParsedValue>) => ParsedValueNumeric, sampleIndex: (frameValues: ArrayLike<ParsedValue>, value: ParsedValueNumeric) => number): List<HostModel>;\n    getItemModel<ItemOpts extends unknown = unknown>(idx: number): Model<ItemOpts>;\n    diff(otherList: List): DataDiffer;\n    getVisual<K extends keyof Visual>(key: K): Visual[K];\n    setVisual<K extends keyof Visual>(key: K, val: Visual[K]): void;\n    setVisual(kvObj: Partial<Visual>): void;\n    getItemVisual<K extends keyof Visual>(idx: number, key: K): Visual[K];\n    ensureUniqueItemVisual<K extends keyof Visual>(idx: number, key: K): Visual[K];\n    setItemVisual<K extends keyof Visual>(idx: number, key: K, value: Visual[K]): void;\n    setItemVisual(idx: number, kvObject: Partial<Visual>): void;\n    clearAllVisual(): void;\n    setLayout(key: string, val: any): void;\n    setLayout(kvObj: Dictionary<any>): void;\n    getLayout(key: string): any;\n    getItemLayout(idx: number): any;\n    setItemLayout<M = false>(idx: number, layout: (M extends true ? Dictionary<any> : any), merge?: M): void;\n    clearItemLayouts(): void;\n    setItemGraphicEl(idx: number, el: Element): void;\n    getItemGraphicEl(idx: number): Element;\n    eachItemGraphicEl<Ctx = unknown>(cb: (this: Ctx, el: Element, idx: number) => void, context?: Ctx): void;\n    cloneShallow(list?: List<HostModel>): List<HostModel>;\n    wrapMethod(methodName: FunctionPropertyNames<List>, injectFunction: (...args: any) => any): void;\n    private static internalField;\n}\ninterface List {\n    getLinkedData(dataType?: SeriesDataType): List;\n    getLinkedDataAll(): {\n        data: List;\n        type?: SeriesDataType;\n    }[];\n}\nexport default List;\n"
  },
  {
    "path": "echarts/types/src/data/OrdinalMeta.d.ts",
    "code": "import Model from '../model/Model';\nimport { OrdinalNumber, OrdinalRawValue } from '../util/types';\ndeclare class OrdinalMeta {\n    readonly categories: OrdinalRawValue[];\n    private _needCollect;\n    private _deduplication;\n    private _map;\n    constructor(opt: {\n        categories?: OrdinalRawValue[];\n        needCollect?: boolean;\n        deduplication?: boolean;\n    });\n    static createByAxisModel(axisModel: Model): OrdinalMeta;\n    getOrdinal(category: OrdinalRawValue): OrdinalNumber;\n    parseAndCollect(category: OrdinalRawValue | OrdinalNumber): OrdinalNumber;\n    private _getOrCreateMap;\n}\nexport default OrdinalMeta;\n"
  },
  {
    "path": "echarts/types/src/data/Source.d.ts",
    "code": "import { HashMap } from 'zrender/esm/core/util';\nimport { SourceFormat, SeriesLayoutBy, DimensionDefinition, OptionEncodeValue, OptionSourceData, DimensionName, OptionSourceHeader, DimensionDefinitionLoose } from '../util/types';\nexport interface SourceMetaRawOption {\n    seriesLayoutBy: SeriesLayoutBy;\n    sourceHeader: OptionSourceHeader;\n    dimensions: DimensionDefinitionLoose[];\n}\ndeclare class Source {\n    readonly data: OptionSourceData;\n    readonly sourceFormat: SourceFormat;\n    readonly seriesLayoutBy: SeriesLayoutBy;\n    readonly dimensionsDefine: DimensionDefinition[];\n    readonly encodeDefine: HashMap<OptionEncodeValue, DimensionName>;\n    readonly startIndex: number;\n    readonly dimensionsDetectCount: number;\n    readonly metaRawOption: SourceMetaRawOption;\n    constructor(fields: {\n        data: OptionSourceData;\n        sourceFormat: SourceFormat;\n        seriesLayoutBy?: SeriesLayoutBy;\n        dimensionsDefine?: DimensionDefinition[];\n        startIndex?: number;\n        dimensionsDetectCount?: number;\n        metaRawOption?: SourceMetaRawOption;\n        encodeDefine?: HashMap<OptionEncodeValue, DimensionName>;\n    });\n    static seriesDataToSource(data: OptionSourceData): Source;\n}\nexport default Source;\n"
  },
  {
    "path": "echarts/types/src/data/Tree.d.ts",
    "code": "import Model from '../model/Model';\nimport List from './List';\nimport { DimensionLoose, ParsedValue } from '../util/types';\nimport { Dictionary } from 'zrender/esm/core/types';\ndeclare type TreeTraverseOrder = 'preorder' | 'postorder';\ndeclare type TreeTraverseCallback<Ctx> = (this: Ctx, node: TreeNode) => boolean | void;\ndeclare type TreeTraverseOption = {\n    order?: TreeTraverseOrder;\n    attr?: 'children' | 'viewChildren';\n};\ninterface TreeNodeData {\n    name?: string;\n    value?: any;\n    children?: TreeNodeData[];\n}\nexport declare class TreeNode {\n    name: string;\n    depth: number;\n    height: number;\n    parentNode: TreeNode;\n    dataIndex: number;\n    children: TreeNode[];\n    viewChildren: TreeNode[];\n    isExpand: boolean;\n    readonly hostTree: Tree<Model, any, any>;\n    constructor(name: string, hostTree: Tree<Model, any, any>);\n    isRemoved(): boolean;\n    eachNode<Ctx>(options: TreeTraverseOrder, cb: TreeTraverseCallback<Ctx>, context?: Ctx): void;\n    eachNode<Ctx>(options: TreeTraverseOption, cb: TreeTraverseCallback<Ctx>, context?: Ctx): void;\n    eachNode<Ctx>(cb: TreeTraverseCallback<Ctx>, context?: Ctx): void;\n    updateDepthAndHeight(depth: number): void;\n    getNodeById(id: string): TreeNode;\n    contains(node: TreeNode): boolean;\n    getAncestors(includeSelf?: boolean): TreeNode[];\n    getAncestorsIndices(): number[];\n    getDescendantIndices(): number[];\n    getValue(dimension?: DimensionLoose): ParsedValue;\n    setLayout(layout: any, merge?: boolean): void;\n    getLayout(): any;\n    getModel<T = unknown>(): Model<T>;\n    getLevelModel(): Model;\n    setVisual(key: string, value: any): void;\n    setVisual(obj: Dictionary<any>): void;\n    getVisual(key: string): any;\n    getRawIndex(): number;\n    getId(): string;\n    isAncestorOf(node: TreeNode): boolean;\n    isDescendantOf(node: TreeNode): boolean;\n}\ndeclare class Tree<HostModel extends Model = Model, LevelOption = any, LeavesOption = any> {\n    type: 'tree';\n    root: TreeNode;\n    data: List;\n    hostModel: HostModel;\n    levelModels: Model<LevelOption>[];\n    private _nodes;\n    constructor(hostModel: HostModel, levelOptions: LevelOption[]);\n    eachNode<Ctx>(options: TreeTraverseOrder, cb: TreeTraverseCallback<Ctx>, context?: Ctx): void;\n    eachNode<Ctx>(options: TreeTraverseOption, cb: TreeTraverseCallback<Ctx>, context?: Ctx): void;\n    eachNode<Ctx>(cb: TreeTraverseCallback<Ctx>, context?: Ctx): void;\n    getNodeByDataIndex(dataIndex: number): TreeNode;\n    getNodeById(name: string): TreeNode;\n    update(): void;\n    clearLayouts(): void;\n    static createTree<T extends TreeNodeData, HostModel extends Model, LevelOption>(dataRoot: T, hostModel: HostModel, treeOptions?: {\n        levels?: LevelOption[];\n    }, beforeLink?: (data: List) => void): Tree<HostModel, LevelOption, any>;\n}\nexport default Tree;\n"
  },
  {
    "path": "echarts/types/src/echarts.d.ts",
    "code": "import * as zrender from 'zrender/esm/zrender';\nimport Eventful from 'zrender/esm/core/Eventful';\nimport GlobalModel, { GlobalModelSetOptionOpts } from './model/Global';\nimport ComponentModel from './model/Component';\nimport SeriesModel from './model/Series';\nimport ComponentView from './view/Component';\nimport ChartView from './view/Chart';\nimport * as modelUtil from './util/model';\nimport './component/dataset';\nimport mapDataStorage from './coord/geo/mapDataStorage';\nimport { CoordinateSystemCreator } from './coord/CoordinateSystem';\nimport { ECEventProcessor } from './util/ECEventProcessor';\nimport { Payload, RendererType, ECEvent, ActionHandler, ActionInfo, OptionPreprocessor, PostUpdater, LoadingEffectCreator, StageHandlerOverallReset, StageHandler, DimensionDefinitionLoose, ThemeOption, ZRColor, ComponentMainType } from './util/types';\nimport 'zrender/esm/canvas/canvas';\nimport { registerExternalTransform } from './data/helper/transform';\nimport { LocaleOption } from './locale';\nimport { EChartsFullOption } from './option';\ndeclare type ModelFinder = modelUtil.ModelFinder;\nexport declare const version = \"5.0.0-alpha.1\";\nexport declare const dependencies: {\n    zrender: string;\n};\nexport declare const PRIORITY: {\n    PROCESSOR: {\n        FILTER: number;\n        SERIES_FILTER: number;\n        STATISTIC: number;\n    };\n    VISUAL: {\n        LAYOUT: number;\n        PROGRESSIVE_LAYOUT: number;\n        GLOBAL: number;\n        CHART: number;\n        POST_CHART_LAYOUT: number;\n        COMPONENT: number;\n        BRUSH: number;\n        CHART_ITEM: number;\n    };\n};\ndeclare const IN_MAIN_PROCESS_KEY: \"__flagInMainProcess\";\ndeclare const OPTION_UPDATED_KEY: \"__optionUpdated\";\ndeclare const STATUS_NEEDS_UPDATE_KEY: \"__needsUpdateStatus\";\ndeclare const CONNECT_STATUS_KEY: \"__connectUpdateStatus\";\ninterface SetOptionOpts {\n    notMerge?: boolean;\n    lazyUpdate?: boolean;\n    silent?: boolean;\n    replaceMerge?: GlobalModelSetOptionOpts['replaceMerge'];\n}\ndeclare class ECharts extends Eventful {\n    id: string;\n    group: string;\n    private _zr;\n    private _dom;\n    private _model;\n    private _throttledZrFlush;\n    private _theme;\n    private _locale;\n    private _chartsViews;\n    private _chartsMap;\n    private _componentsViews;\n    private _componentsMap;\n    private _coordSysMgr;\n    private _api;\n    private _scheduler;\n    private _messageCenter;\n    private _pendingActions;\n    protected _$eventProcessor: ECEventProcessor;\n    private _disposed;\n    private _loadingFX;\n    private _labelManager;\n    private [OPTION_UPDATED_KEY];\n    private [IN_MAIN_PROCESS_KEY];\n    private [CONNECT_STATUS_KEY];\n    private [STATUS_NEEDS_UPDATE_KEY];\n    constructor(dom: HTMLElement, theme?: string | ThemeOption, opts?: {\n        locale?: string | LocaleOption;\n        renderer?: RendererType;\n        devicePixelRatio?: number;\n        width?: number;\n        height?: number;\n    });\n    private _onframe;\n    getDom(): HTMLElement;\n    getId(): string;\n    getZr(): zrender.ZRenderType;\n    setOption(option: EChartsFullOption, notMerge?: boolean, lazyUpdate?: boolean): void;\n    setOption(option: EChartsFullOption, opts?: SetOptionOpts): void;\n    setTheme(): void;\n    getModel(): GlobalModel;\n    getOption(): EChartsFullOption;\n    getWidth(): number;\n    getHeight(): number;\n    getDevicePixelRatio(): number;\n    getRenderedCanvas(opts?: {\n        backgroundColor?: ZRColor;\n        pixelRatio?: number;\n    }): HTMLCanvasElement;\n    getSvgDataURL(): string;\n    getDataURL(opts?: {\n        type?: 'png' | 'jpg' | 'svg';\n        pixelRatio?: number;\n        backgroundColor?: ZRColor;\n        excludeComponents?: ComponentMainType[];\n    }): string;\n    getConnectedDataURL(opts?: {\n        type?: 'png' | 'jpg' | 'svg';\n        pixelRatio?: number;\n        backgroundColor?: ZRColor;\n        connectedBackgroundColor?: ZRColor;\n        excludeComponents?: string[];\n    }): string;\n    convertToPixel(finder: ModelFinder, value: any): number[];\n    convertFromPixel(finder: ModelFinder, value: number[]): any;\n    containPixel(finder: ModelFinder, value: number[]): boolean;\n    getVisual(finder: ModelFinder, visualType: string): string | number | number[] | import(\"zrender/esm/graphic/Pattern\").PatternObject | import(\"zrender/esm/graphic/LinearGradient\").LinearGradientObject | import(\"zrender/esm/graphic/RadialGradient\").RadialGradientObject;\n    getViewOfComponentModel(componentModel: ComponentModel): ComponentView;\n    getViewOfSeriesModel(seriesModel: SeriesModel): ChartView;\n    private _initEvents;\n    isDisposed(): boolean;\n    clear(): void;\n    dispose(): void;\n    resize(opts?: {\n        width?: number | 'auto';\n        height?: number | 'auto';\n        silent?: boolean;\n    }): void;\n    showLoading(cfg?: object): void;\n    showLoading(name?: string, cfg?: object): void;\n    hideLoading(): void;\n    makeActionFromEvent(eventObj: ECEvent): Payload;\n    dispatchAction(payload: Payload, opt?: boolean | {\n        silent?: boolean;\n        flush?: boolean | undefined;\n    }): void;\n    updateLabelLayout(): void;\n    appendData(params: {\n        seriesIndex: number;\n        data: any;\n    }): void;\n    private static internalField;\n}\nexport declare function init(dom: HTMLElement, theme?: string | object, opts?: {\n    renderer?: RendererType;\n    devicePixelRatio?: number;\n    width?: number;\n    height?: number;\n    locale?: string | LocaleOption;\n}): ECharts;\nexport declare function connect(groupId: string | ECharts[]): string;\nexport declare function disConnect(groupId: string): void;\nexport declare const disconnect: typeof disConnect;\nexport declare function dispose(chart: ECharts | HTMLElement | string): void;\nexport declare function getInstanceByDom(dom: HTMLElement): ECharts;\nexport declare function getInstanceById(key: string): ECharts;\nexport declare function registerTheme(name: string, theme: ThemeOption): void;\nexport declare function registerPreprocessor(preprocessorFunc: OptionPreprocessor): void;\nexport declare function registerProcessor(priority: number | StageHandler | StageHandlerOverallReset, processor?: StageHandler | StageHandlerOverallReset): void;\nexport declare function registerPostUpdate(postUpdateFunc: PostUpdater): void;\nexport declare function registerAction(type: string, eventName: string, action: ActionHandler): void;\nexport declare function registerAction(type: string, action: ActionHandler): void;\nexport declare function registerAction(actionInfo: ActionInfo, action: ActionHandler): void;\nexport declare function registerCoordinateSystem(type: string, coordSysCreator: CoordinateSystemCreator): void;\nexport declare function getCoordinateSystemDimensions(type: string): DimensionDefinitionLoose[];\nexport { registerLocale } from './locale';\ndeclare function registerLayout(priority: number, layoutTask: StageHandler | StageHandlerOverallReset): void;\ndeclare function registerLayout(layoutTask: StageHandler | StageHandlerOverallReset): void;\ndeclare function registerVisual(priority: number, layoutTask: StageHandler | StageHandlerOverallReset): void;\ndeclare function registerVisual(layoutTask: StageHandler | StageHandlerOverallReset): void;\nexport { registerLayout, registerVisual };\nexport declare function registerLoading(name: string, loadingFx: LoadingEffectCreator): void;\nexport declare function extendComponentModel(proto: object): ComponentModel;\nexport declare function extendComponentView(proto: object): ChartView;\nexport declare function extendSeriesModel(proto: object): SeriesModel;\nexport declare function extendChartView(proto: object): ChartView;\nexport declare function setCanvasCreator(creator: () => HTMLCanvasElement): void;\nexport declare function registerMap(mapName: Parameters<typeof mapDataStorage.registerMap>[0], geoJson: Parameters<typeof mapDataStorage.registerMap>[1], specialAreas?: Parameters<typeof mapDataStorage.registerMap>[2]): void;\nexport declare function getMap(mapName: string): {\n    geoJson: any;\n    specialAreas: import(\"./coord/geo/geoTypes\").GeoSpecialAreas;\n};\nexport declare const registerTransform: typeof registerExternalTransform;\nexport declare const dataTool: {};\nexport interface EChartsType extends ECharts {\n}\n"
  },
  {
    "path": "echarts/types/src/export.d.ts",
    "code": "import * as zrender from 'zrender/esm/zrender';\nimport * as matrix from 'zrender/esm/core/matrix';\nimport * as vector from 'zrender/esm/core/vector';\nimport * as colorTool from 'zrender/esm/tool/color';\nimport * as numberUtil from './util/number';\nimport * as formatUtil from './util/format';\nimport * as timeUtil from './util/time';\nimport { throttle } from './util/throttle';\nimport * as ecHelper from './helper';\nimport parseGeoJSON from './coord/geo/parseGeoJson';\nexport { zrender };\nexport { default as List } from './data/List';\nexport { default as Model } from './model/Model';\nexport { default as Axis } from './coord/Axis';\nexport { numberUtil as number };\nexport { formatUtil as format };\nexport { throttle };\nexport { ecHelper as helper };\nexport { matrix };\nexport { vector };\nexport { colorTool as color };\nexport { default as env } from 'zrender/esm/core/env';\nexport { parseGeoJSON };\nexport declare const parseGeoJson: typeof parseGeoJSON;\nexport declare const time: {\n    parse: typeof numberUtil.parseDate;\n    format: typeof timeUtil.format;\n};\ndeclare const ecUtil: {};\nexport { ecUtil as util };\ndeclare const graphic: Record<\"Polygon\" | \"extendShape\" | \"extendPath\" | \"makePath\" | \"makeImage\" | \"mergePath\" | \"resizePath\" | \"createIcon\" | \"updateProps\" | \"initProps\" | \"getTransform\" | \"clipPointsByRect\" | \"clipRectByRect\" | \"registerShape\" | \"getShapeClass\" | \"Group\" | \"Image\" | \"Text\" | \"Circle\" | \"Ellipse\" | \"Sector\" | \"Ring\" | \"Polyline\" | \"Rect\" | \"Line\" | \"BezierCurve\" | \"Arc\" | \"IncrementalDisplayable\" | \"CompoundPath\" | \"LinearGradient\" | \"RadialGradient\" | \"BoundingRect\", any>;\nexport { graphic };\n"
  },
  {
    "path": "echarts/types/src/ExtensionAPI.d.ts",
    "code": "import { EChartsType } from './echarts';\nimport { CoordinateSystemMaster } from './coord/CoordinateSystem';\nimport Element from 'zrender/esm/Element';\nimport ComponentModel from './model/Component';\ndeclare const availableMethods: (keyof EChartsType)[];\ninterface ExtensionAPI extends Pick<EChartsType, (typeof availableMethods)[number]> {\n}\ndeclare abstract class ExtensionAPI {\n    constructor(ecInstance: EChartsType);\n    abstract getCoordinateSystems(): CoordinateSystemMaster[];\n    abstract getComponentByElement(el: Element): ComponentModel;\n    abstract enterEmphasis(el: Element, highlightDigit?: number): void;\n    abstract leaveEmphasis(el: Element, highlightDigit?: number): void;\n    abstract enterSelect(el: Element): void;\n    abstract leaveSelect(el: Element): void;\n    abstract enterBlur(el: Element): void;\n    abstract leaveBlur(el: Element): void;\n}\nexport default ExtensionAPI;\n"
  },
  {
    "path": "echarts/types/src/helper.d.ts",
    "code": "import Model from './model/Model';\nimport { getLayoutRect } from './util/layout';\nimport { enableDataStack, isDimensionStacked, getStackedDimension } from './data/helper/dataStackHelper';\nimport SeriesModel from './model/Series';\nimport { AxisBaseModel } from './coord/AxisBaseModel';\nexport declare function createList(seriesModel: SeriesModel): import(\"./data/List\").default<Model<any>, import(\"./data/List\").DefaultDataVisual>;\nexport { getLayoutRect };\nexport { default as createDimensions } from './data/helper/createDimensions';\nexport declare const dataStack: {\n    isDimensionStacked: typeof isDimensionStacked;\n    enableDataStack: typeof enableDataStack;\n    getStackedDimension: typeof getStackedDimension;\n};\nexport { createSymbol } from './util/symbol';\nexport declare function createScale(dataExtent: number[], option: object | AxisBaseModel): import(\"./scale/Scale\").default;\nexport declare function mixinAxisModelCommonMethods(Model: Model): void;\n"
  },
  {
    "path": "echarts/types/src/i18n/langEN.d.ts",
    "code": "declare const _default: {\n    time: {\n        month: string[];\n        monthAbbr: string[];\n        dayOfWeek: string[];\n        dayOfWeekAbbr: string[];\n    };\n    legend: {\n        selector: {\n            all: string;\n            inverse: string;\n        };\n    };\n    toolbox: {\n        brush: {\n            title: {\n                rect: string;\n                polygon: string;\n                lineX: string;\n                lineY: string;\n                keep: string;\n                clear: string;\n            };\n        };\n        dataView: {\n            title: string;\n            lang: string[];\n        };\n        dataZoom: {\n            title: {\n                zoom: string;\n                back: string;\n            };\n        };\n        magicType: {\n            title: {\n                line: string;\n                bar: string;\n                stack: string;\n                tiled: string;\n            };\n        };\n        restore: {\n            title: string;\n        };\n        saveAsImage: {\n            title: string;\n            lang: string[];\n        };\n    };\n    series: {\n        typeNames: {\n            pie: string;\n            bar: string;\n            line: string;\n            scatter: string;\n            effectScatter: string;\n            radar: string;\n            tree: string;\n            treemap: string;\n            boxplot: string;\n            candlestick: string;\n            k: string;\n            heatmap: string;\n            map: string;\n            parallel: string;\n            lines: string;\n            graph: string;\n            sankey: string;\n            funnel: string;\n            gauge: string;\n            pictorialBar: string;\n            themeRiver: string;\n            sunburst: string;\n        };\n    };\n    aria: {\n        general: {\n            withTitle: string;\n            withoutTitle: string;\n        };\n        series: {\n            single: {\n                prefix: string;\n                withName: string;\n                withoutName: string;\n            };\n            multiple: {\n                prefix: string;\n                withName: string;\n                withoutName: string;\n                separator: {\n                    middle: string;\n                    end: string;\n                };\n            };\n        };\n        data: {\n            allData: string;\n            partialData: string;\n            withName: string;\n            withoutName: string;\n            separator: {\n                middle: string;\n                end: string;\n            };\n        };\n    };\n};\nexport default _default;\n"
  },
  {
    "path": "echarts/types/src/i18n/langES.d.ts",
    "code": "declare const _default: {\n    time: {\n        month: string[];\n        monthAbbr: string[];\n        dayOfWeek: string[];\n        dayOfWeekAbbr: string[];\n    };\n    legend: {\n        selector: {\n            all: string;\n            inverse: string;\n        };\n    };\n    toolbox: {\n        brush: {\n            title: {\n                rect: string;\n                polygon: string;\n                lineX: string;\n                lineY: string;\n                keep: string;\n                clear: string;\n            };\n        };\n        dataView: {\n            title: string;\n            lang: string[];\n        };\n        dataZoom: {\n            title: {\n                zoom: string;\n                back: string;\n            };\n        };\n        magicType: {\n            title: {\n                line: string;\n                bar: string;\n                stack: string;\n                tiled: string;\n            };\n        };\n        restore: {\n            title: string;\n        };\n        saveAsImage: {\n            title: string;\n            lang: string[];\n        };\n    };\n};\nexport default _default;\n"
  },
  {
    "path": "echarts/types/src/i18n/langFI.d.ts",
    "code": "declare const _default: {\n    time: {\n        month: string[];\n        monthAbbr: string[];\n        dayOfWeek: string[];\n        dayOfWeekAbbr: string[];\n    };\n    legend: {\n        selector: {\n            all: string;\n            inverse: string;\n        };\n    };\n    toolbox: {\n        brush: {\n            title: {\n                rect: string;\n                polygon: string;\n                lineX: string;\n                lineY: string;\n                keep: string;\n                clear: string;\n            };\n        };\n        dataView: {\n            title: string;\n            lang: string[];\n        };\n        dataZoom: {\n            title: {\n                zoom: string;\n                back: string;\n            };\n        };\n        magicType: {\n            title: {\n                line: string;\n                bar: string;\n                stack: string;\n                tiled: string;\n            };\n        };\n        restore: {\n            title: string;\n        };\n        saveAsImage: {\n            title: string;\n            lang: string[];\n        };\n    };\n};\nexport default _default;\n"
  },
  {
    "path": "echarts/types/src/i18n/langFR.d.ts",
    "code": "declare const _default: {\n    time: {\n        month: string[];\n        monthAbbr: string[];\n        dayOfWeek: string[];\n        dayOfWeekAbbr: string[];\n    };\n    legend: {\n        selector: {\n            all: string;\n            inverse: string;\n        };\n    };\n    toolbox: {\n        brush: {\n            title: {\n                rect: string;\n                polygon: string;\n                lineX: string;\n                lineY: string;\n                keep: string;\n                clear: string;\n            };\n        };\n        dataView: {\n            title: string;\n            lang: string[];\n        };\n        dataZoom: {\n            title: {\n                zoom: string;\n                back: string;\n            };\n        };\n        magicType: {\n            title: {\n                line: string;\n                bar: string;\n                stack: string;\n                tiled: string;\n            };\n        };\n        restore: {\n            title: string;\n        };\n        saveAsImage: {\n            title: string;\n            lang: string[];\n        };\n    };\n    series: {\n        typeNames: {\n            pie: string;\n            bar: string;\n            line: string;\n            scatter: string;\n            effectScatter: string;\n            radar: string;\n            tree: string;\n            treemap: string;\n            boxplot: string;\n            candlestick: string;\n            k: string;\n            heatmap: string;\n            map: string;\n            parallel: string;\n            lines: string;\n            graph: string;\n            sankey: string;\n            funnel: string;\n            gauge: string;\n            pictorialBar: string;\n            themeRiver: string;\n            sunburst: string;\n        };\n    };\n    aria: {\n        general: {\n            withTitle: string;\n            withoutTitle: string;\n        };\n        series: {\n            single: {\n                prefix: string;\n                withName: string;\n                withoutName: string;\n            };\n            multiple: {\n                prefix: string;\n                withName: string;\n                withoutName: string;\n                separator: {\n                    middle: string;\n                    end: string;\n                };\n            };\n        };\n        data: {\n            allData: string;\n            partialData: string;\n            withName: string;\n            withoutName: string;\n            separator: {\n                middle: string;\n                end: string;\n            };\n        };\n    };\n};\nexport default _default;\n"
  },
  {
    "path": "echarts/types/src/i18n/langTH.d.ts",
    "code": "declare const _default: {\n    time: {\n        month: string[];\n        monthAbbr: string[];\n        dayOfWeek: string[];\n        dayOfWeekAbbr: string[];\n    };\n    legend: {\n        selector: {\n            all: string;\n            inverse: string;\n        };\n    };\n    toolbox: {\n        brush: {\n            title: {\n                rect: string;\n                polygon: string;\n                lineX: string;\n                lineY: string;\n                keep: string;\n                clear: string;\n            };\n        };\n        dataView: {\n            title: string;\n            lang: string[];\n        };\n        dataZoom: {\n            title: {\n                zoom: string;\n                back: string;\n            };\n        };\n        magicType: {\n            title: {\n                line: string;\n                bar: string;\n                stack: string;\n                tiled: string;\n            };\n        };\n        restore: {\n            title: string;\n        };\n        saveAsImage: {\n            title: string;\n            lang: string[];\n        };\n    };\n};\nexport default _default;\n"
  },
  {
    "path": "echarts/types/src/i18n/langZH.d.ts",
    "code": "declare const _default: {\n    time: {\n        month: string[];\n        monthAbbr: string[];\n        dayOfWeek: string[];\n        dayOfWeekAbbr: string[];\n    };\n    legend: {\n        selector: {\n            all: string;\n            inverse: string;\n        };\n    };\n    toolbox: {\n        brush: {\n            title: {\n                rect: string;\n                polygon: string;\n                lineX: string;\n                lineY: string;\n                keep: string;\n                clear: string;\n            };\n        };\n        dataView: {\n            title: string;\n            lang: string[];\n        };\n        dataZoom: {\n            title: {\n                zoom: string;\n                back: string;\n            };\n        };\n        magicType: {\n            title: {\n                line: string;\n                bar: string;\n                stack: string;\n                tiled: string;\n            };\n        };\n        restore: {\n            title: string;\n        };\n        saveAsImage: {\n            title: string;\n            lang: string[];\n        };\n    };\n    series: {\n        typeNames: {\n            pie: string;\n            bar: string;\n            line: string;\n            scatter: string;\n            effectScatter: string;\n            radar: string;\n            tree: string;\n            treemap: string;\n            boxplot: string;\n            candlestick: string;\n            k: string;\n            heatmap: string;\n            map: string;\n            parallel: string;\n            lines: string;\n            graph: string;\n            sankey: string;\n            funnel: string;\n            gauge: string;\n            pictorialBar: string;\n            themeRiver: string;\n            sunburst: string;\n        };\n    };\n    aria: {\n        general: {\n            withTitle: string;\n            withoutTitle: string;\n        };\n        series: {\n            single: {\n                prefix: string;\n                withName: string;\n                withoutName: string;\n            };\n            multiple: {\n                prefix: string;\n                withName: string;\n                withoutName: string;\n                separator: {\n                    middle: string;\n                    end: string;\n                };\n            };\n        };\n        data: {\n            allData: string;\n            partialData: string;\n            withName: string;\n            withoutName: string;\n            separator: {\n                middle: string;\n                end: string;\n            };\n        };\n    };\n};\nexport default _default;\n"
  },
  {
    "path": "echarts/types/src/label/labelGuideHelper.d.ts",
    "code": "import { Point, Polyline } from '../util/graphic';\nimport Element from 'zrender/esm/Element';\nimport { LabelLineOption, DisplayState, StatesOptionMixin } from '../util/types';\nimport Model from '../model/Model';\nimport * as vector from 'zrender/esm/core/vector';\nexport declare function updateLabelLinePoints(target: Element, labelLineModel: Model<LabelLineOption>): void;\nexport declare function limitTurnAngle(linePoints: number[][], minTurnAngle: number): void;\nexport declare function limitSurfaceAngle(linePoints: vector.VectorArray[], surfaceNormal: Point, maxSurfaceAngle: number): void;\ndeclare type LabelLineModel = Model<LabelLineOption>;\nexport declare function setLabelLineStyle(targetEl: Element, statesModels: Record<DisplayState, LabelLineModel>, defaultStyle?: Polyline['style']): void;\nexport declare function getLabelLineStatesModels<LabelName extends string = 'labelLine'>(itemModel: Model<StatesOptionMixin<any> & Partial<Record<LabelName, any>>>, labelLineName?: LabelName): Record<DisplayState, LabelLineModel>;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/label/labelLayoutHelper.d.ts",
    "code": "import ZRText from 'zrender/esm/graphic/Text';\nimport { LabelLayoutOption } from '../util/types';\nimport { BoundingRect, OrientedBoundingRect, Polyline } from '../util/graphic';\ninterface LabelLayoutListPrepareInput {\n    label: ZRText;\n    labelLine: Polyline;\n    computedLayoutOption: LabelLayoutOption;\n    priority: number;\n    defaultAttr: {\n        ignore: boolean;\n        labelGuideIgnore: boolean;\n    };\n}\nexport interface LabelLayoutInfo {\n    label: ZRText;\n    labelLine: Polyline;\n    priority: number;\n    rect: BoundingRect;\n    localRect: BoundingRect;\n    obb?: OrientedBoundingRect;\n    axisAligned: boolean;\n    layoutOption: LabelLayoutOption;\n    defaultAttr: {\n        ignore: boolean;\n        labelGuideIgnore: boolean;\n    };\n    transform: number[];\n}\nexport declare function prepareLayoutList(input: LabelLayoutListPrepareInput[]): LabelLayoutInfo[];\nexport declare function shiftLayoutOnX(list: Pick<LabelLayoutInfo, 'rect' | 'label'>[], leftBound: number, rightBound: number, balanceShift?: boolean): boolean;\nexport declare function shiftLayoutOnY(list: Pick<LabelLayoutInfo, 'rect' | 'label'>[], topBound: number, bottomBound: number, balanceShift?: boolean): boolean;\nexport declare function hideOverlap(labelList: LabelLayoutInfo[]): void;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/label/LabelManager.d.ts",
    "code": "import ExtensionAPI from '../ExtensionAPI';\nimport ChartView from '../view/Chart';\ndeclare class LabelManager {\n    private _labelList;\n    private _chartViewList;\n    constructor();\n    clearLabels(): void;\n    private _addLabel;\n    addLabelsOfSeries(chartView: ChartView): void;\n    updateLayoutConfig(api: ExtensionAPI): void;\n    layout(api: ExtensionAPI): void;\n    processLabelsOverall(): void;\n    private _updateLabelLine;\n    private _animateLabels;\n}\nexport default LabelManager;\n"
  },
  {
    "path": "echarts/types/src/label/labelStyle.d.ts",
    "code": "import ZRText, { TextStyleProps } from 'zrender/esm/graphic/Text';\nimport Element, { ElementTextConfig } from 'zrender/esm/Element';\nimport Model from '../model/Model';\nimport { LabelOption, DisplayState, TextCommonOption, ParsedValue, CallbackDataParams, StatesOptionMixin, DisplayStateNonNormal, ColorString, ZRStyleProps } from '../util/types';\nimport GlobalModel from '../model/Global';\ndeclare type TextCommonParams = {\n    disableBox?: boolean;\n    inheritColor?: ColorString;\n    defaultOutsidePosition?: LabelOption['position'];\n    textStyle?: ZRStyleProps;\n};\ninterface SetLabelStyleOpt<LDI> extends TextCommonParams {\n    defaultText?: string | ((labelDataIndex: LDI, opt: SetLabelStyleOpt<LDI>) => string);\n    labelFetcher?: {\n        getFormattedLabel: (labelDataIndex: LDI, status: DisplayState, dataType?: string, labelDimIndex?: number, formatter?: string | ((params: object) => string), extendParams?: Partial<CallbackDataParams>) => string;\n    };\n    labelDataIndex?: LDI;\n    labelDimIndex?: number;\n}\ndeclare type LabelModel = Model<LabelOption & {\n    formatter?: string | ((params: any) => string);\n}>;\ndeclare type LabelModelForText = Model<Omit<LabelOption, 'position' | 'rotate'> & {\n    formatter?: string | ((params: any) => string);\n}>;\ndeclare type LabelStatesModels<LabelModel> = Partial<Record<DisplayStateNonNormal, LabelModel>> & {\n    normal: LabelModel;\n};\nexport declare function getLabelText<LDI>(opt: SetLabelStyleOpt<LDI>, stateModels?: LabelStatesModels<LabelModel>, overrideValue?: ParsedValue | ParsedValue[]): Record<DisplayState, string>;\ndeclare function setLabelStyle<LDI>(targetEl: ZRText, labelStatesModels: LabelStatesModels<LabelModelForText>, opt?: SetLabelStyleOpt<LDI>, stateSpecified?: Partial<Record<DisplayState, TextStyleProps>>): void;\ndeclare function setLabelStyle<LDI>(targetEl: Element, labelStatesModels: LabelStatesModels<LabelModel>, opt?: SetLabelStyleOpt<LDI>, stateSpecified?: Partial<Record<DisplayState, TextStyleProps>>): void;\nexport { setLabelStyle };\nexport declare function getLabelStatesModels<LabelName extends string = 'label'>(itemModel: Model<StatesOptionMixin<any> & Partial<Record<LabelName, any>>>, labelName?: LabelName): Record<DisplayState, LabelModel>;\nexport declare function createTextStyle(textStyleModel: Model, specifiedTextStyle?: TextStyleProps, opt?: Pick<TextCommonParams, 'inheritColor' | 'disableBox'>, isNotNormal?: boolean, isAttached?: boolean): TextStyleProps;\nexport declare function createTextConfig(textStyleModel: Model, opt?: Pick<TextCommonParams, 'defaultOutsidePosition' | 'inheritColor'>, isNotNormal?: boolean): ElementTextConfig;\nexport declare function getFont(opt: Pick<TextCommonOption, 'fontStyle' | 'fontWeight' | 'fontSize' | 'fontFamily'>, ecModel: GlobalModel): string;\n"
  },
  {
    "path": "echarts/types/src/layout/barGrid.d.ts",
    "code": "import BarSeriesModel from '../chart/bar/BarSeries';\nimport Axis2D from '../coord/cartesian/Axis2D';\nimport GlobalModel from '../model/Global';\nimport { StageHandler, Dictionary } from '../util/types';\ndeclare type BarWidthAndOffset = Dictionary<Dictionary<{\n    bandWidth: number;\n    offset: number;\n    offsetCenter: number;\n    width: number;\n}>>;\ninterface LayoutOption {\n    axis: Axis2D;\n    count: number;\n    barWidth?: number;\n    barMaxWidth?: number;\n    barMinWidth?: number;\n    barGap?: number;\n    barCategoryGap?: number;\n}\nexport declare function getLayoutOnAxis(opt: LayoutOption): {\n    bandWidth: number;\n    offset: number;\n    offsetCenter: number;\n    width: number;\n}[];\nexport declare function prepareLayoutBarSeries(seriesType: string, ecModel: GlobalModel): BarSeriesModel[];\nexport declare function makeColumnLayout(barSeries: BarSeriesModel[]): Dictionary<Dictionary<{\n    bandWidth: number;\n    offset: number;\n    offsetCenter: number;\n    width: number;\n}>>;\ndeclare function retrieveColumnLayout(barWidthAndOffset: BarWidthAndOffset, axis: Axis2D): typeof barWidthAndOffset[string];\ndeclare function retrieveColumnLayout(barWidthAndOffset: BarWidthAndOffset, axis: Axis2D, seriesModel: BarSeriesModel): typeof barWidthAndOffset[string][string];\nexport { retrieveColumnLayout };\nexport declare function layout(seriesType: string, ecModel: GlobalModel): void;\nexport declare const largeLayout: StageHandler;\n"
  },
  {
    "path": "echarts/types/src/layout/barPolar.d.ts",
    "code": "import GlobalModel from '../model/Global';\nimport ExtensionAPI from '../ExtensionAPI';\ndeclare function barLayoutPolar(seriesType: string, ecModel: GlobalModel, api: ExtensionAPI): void;\nexport default barLayoutPolar;\n"
  },
  {
    "path": "echarts/types/src/layout/points.d.ts",
    "code": "import { StageHandler } from '../util/types';\nexport default function (seriesType?: string): StageHandler;\n"
  },
  {
    "path": "echarts/types/src/legacy/dataSelectAction.d.ts",
    "code": "import Eventful from 'zrender/esm/core/Eventful';\nimport { EChartsType, registerAction } from '../echarts';\nexport declare function createLegacyDataSelectAction(seriesType: string, ecRegisterAction: typeof registerAction): void;\nexport declare function handleLegacySelectEvents(messageCenter: Eventful, ecIns: EChartsType): void;\n"
  },
  {
    "path": "echarts/types/src/legacy/getTextRect.d.ts",
    "code": "import { Text } from '../util/graphic';\ndeclare type TextStyleProps = Text['style'];\nexport declare function getTextRect(text: TextStyleProps['text'], font?: TextStyleProps['font'], align?: TextStyleProps['align'], verticalAlign?: TextStyleProps['verticalAlign'], padding?: TextStyleProps['padding'], rich?: TextStyleProps['rich'], truncate?: boolean, lineHeight?: number): import(\"zrender/esm/core/BoundingRect\").default;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/loading/default.d.ts",
    "code": "import { LoadingEffect } from '../util/types';\nimport ExtensionAPI from '../ExtensionAPI';\nexport default function (api: ExtensionAPI, opts?: {\n    text?: string;\n    color?: string;\n    textColor?: string;\n    maskColor?: string;\n    zlevel?: number;\n    showSpinner?: boolean;\n    spinnerRadius?: number;\n    lineWidth?: number;\n    fontSize?: number;\n}): LoadingEffect;\n"
  },
  {
    "path": "echarts/types/src/locale.d.ts",
    "code": "import Model from './model/Model';\nimport langEN from './i18n/langEN';\nexport declare type LocaleOption = typeof langEN;\nexport declare const SYSTEM_LANG: string;\nexport declare function registerLocale(locale: string, localeObj: LocaleOption): void;\nexport declare function createLocaleObject(locale: string | LocaleOption): LocaleOption;\nexport declare function getLocaleModel(lang: string): Model<LocaleOption>;\nexport declare function getDefaultLocaleModel(): Model<LocaleOption>;\n"
  },
  {
    "path": "echarts/types/src/model/Component.d.ts",
    "code": "import Model from './Model';\nimport * as componentUtil from '../util/component';\nimport { ExtendableConstructor, ClassManager } from '../util/clazz';\nimport { QueryReferringOpt } from '../util/model';\nimport GlobalModel from './Global';\nimport { ComponentOption, ComponentMainType, ComponentSubType, ComponentFullType, ComponentLayoutMode } from '../util/types';\ndeclare class ComponentModel<Opt extends ComponentOption = ComponentOption> extends Model<Opt> {\n    type: ComponentFullType;\n    id: string;\n    name: string;\n    mainType: ComponentMainType;\n    subType: ComponentSubType;\n    componentIndex: number;\n    protected defaultOption: ComponentOption;\n    ecModel: GlobalModel;\n    static dependencies: string[];\n    readonly uid: string;\n    static layoutMode: ComponentLayoutMode | ComponentLayoutMode['type'];\n    preventAutoZ: boolean;\n    __viewId: string;\n    __requireNewView: boolean;\n    static protoInitialize: void;\n    constructor(option: Opt, parentModel: Model, ecModel: GlobalModel);\n    init(option: Opt, parentModel: Model, ecModel: GlobalModel): void;\n    mergeDefaultAndTheme(option: Opt, ecModel: GlobalModel): void;\n    mergeOption(option: Opt, ecModel: GlobalModel): void;\n    optionUpdated(newCptOption: Opt, isInit: boolean): void;\n    getDefaultOption(): Opt;\n    getReferringComponents(mainType: ComponentMainType, opt: QueryReferringOpt): {\n        models: ComponentModel[];\n        specified: boolean;\n    };\n    getBoxLayoutParams(): {\n        left: string | number;\n        top: string | number;\n        right: string | number;\n        bottom: string | number;\n        width: string | number;\n        height: string | number;\n    };\n    static registerClass: ClassManager['registerClass'];\n    static hasClass: ClassManager['hasClass'];\n    static registerSubTypeDefaulter: componentUtil.SubTypeDefaulterManager['registerSubTypeDefaulter'];\n}\nexport declare type ComponentModelConstructor = typeof ComponentModel & ClassManager & componentUtil.SubTypeDefaulterManager & ExtendableConstructor & componentUtil.TopologicalTravelable<object>;\nexport default ComponentModel;\n"
  },
  {
    "path": "echarts/types/src/model/Global.d.ts",
    "code": "import { HashMap } from 'zrender/esm/core/util';\nimport Model from './Model';\nimport ComponentModel from './Component';\nimport { ColorPaletteMixin } from './mixin/colorPalette';\nimport SeriesModel from './Series';\nimport { Payload, OptionPreprocessor, ECOption, ECUnitOption, ComponentMainType, ComponentSubType } from '../util/types';\nimport OptionManager from './OptionManager';\nimport Scheduler from '../stream/Scheduler';\nimport { LocaleOption } from '../locale';\nexport interface GlobalModelSetOptionOpts {\n    replaceMerge: ComponentMainType | ComponentMainType[];\n}\nexport interface InnerSetOptionOpts {\n    replaceMergeMainTypeMap: HashMap<boolean, string>;\n}\ndeclare class GlobalModel extends Model<ECUnitOption> {\n    option: ECUnitOption;\n    private _theme;\n    private _locale;\n    private _optionManager;\n    private _componentsMap;\n    private _componentsCount;\n    private _seriesIndices;\n    private _seriesIndicesMap;\n    private _payload;\n    scheduler: Scheduler;\n    init(option: ECOption, parentModel: Model, ecModel: GlobalModel, theme: object, locale: object, optionManager: OptionManager): void;\n    setOption(option: ECOption, opts: GlobalModelSetOptionOpts, optionPreprocessorFuncs: OptionPreprocessor[]): void;\n    resetOption(type: 'recreate' | 'timeline' | 'media', opt?: GlobalModelSetOptionOpts): boolean;\n    private _resetOption;\n    mergeOption(option: ECUnitOption): void;\n    private _mergeOption;\n    getOption(): ECUnitOption;\n    getTheme(): Model;\n    getLocaleModel(): Model<LocaleOption>;\n    getLocale(localePosition: Parameters<Model<LocaleOption>['get']>[0]): any;\n    setUpdatePayload(payload: Payload): void;\n    getUpdatePayload(): Payload;\n    getComponent(mainType: ComponentMainType, idx?: number): ComponentModel;\n    queryComponents(condition: QueryConditionKindB): ComponentModel[];\n    findComponents(condition: QueryConditionKindA): ComponentModel[];\n    eachComponent<T>(cb: EachComponentAllCallback, context?: T): void;\n    eachComponent<T>(mainType: string, cb: EachComponentInMainTypeCallback, context?: T): void;\n    eachComponent<T>(mainType: QueryConditionKindA, cb: EachComponentInMainTypeCallback, context?: T): void;\n    getSeriesByName(name: string): SeriesModel[];\n    getSeriesByIndex(seriesIndex: number): SeriesModel;\n    getSeriesByType(subType: ComponentSubType): SeriesModel[];\n    getSeries(): SeriesModel[];\n    getSeriesCount(): number;\n    eachSeries<T>(cb: (this: T, series: SeriesModel, rawSeriesIndex: number) => void, context?: T): void;\n    eachRawSeries<T>(cb: (this: T, series: SeriesModel, rawSeriesIndex: number) => void, context?: T): void;\n    eachSeriesByType<T>(subType: ComponentSubType, cb: (this: T, series: SeriesModel, rawSeriesIndex: number) => void, context?: T): void;\n    eachRawSeriesByType<T>(subType: ComponentSubType, cb: (this: T, series: SeriesModel, rawSeriesIndex: number) => void, context?: T): void;\n    isSeriesFiltered(seriesModel: SeriesModel): boolean;\n    getCurrentSeriesIndices(): number[];\n    filterSeries<T>(cb: (this: T, series: SeriesModel, rawSeriesIndex: number) => boolean, context?: T): void;\n    restoreData(payload?: Payload): void;\n    private static internalField;\n}\nexport interface QueryConditionKindA {\n    mainType: ComponentMainType;\n    subType?: ComponentSubType;\n    query?: {\n        [k: string]: number | number[] | string | string[];\n    };\n    filter?: (cmpt: ComponentModel) => boolean;\n}\nexport interface QueryConditionKindB {\n    mainType: ComponentMainType;\n    subType?: ComponentSubType;\n    index?: number | number[];\n    id?: string | number | (string | number)[];\n    name?: (string | number) | (string | number)[];\n}\nexport interface EachComponentAllCallback {\n    (mainType: string, model: ComponentModel, componentIndex: number): void;\n}\ninterface EachComponentInMainTypeCallback {\n    (model: ComponentModel, componentIndex: number): void;\n}\ninterface GlobalModel extends ColorPaletteMixin<ECUnitOption> {\n}\nexport default GlobalModel;\n"
  },
  {
    "path": "echarts/types/src/model/globalDefault.d.ts",
    "code": "declare const _default: {\n    darkMode: string;\n    color: string[];\n    gradientColor: string[];\n    textStyle: {\n        fontFamily: string;\n        fontSize: number;\n        fontStyle: string;\n        fontWeight: string;\n    };\n    blendMode: any;\n    stateAnimation: {\n        duration: number;\n        easing: string;\n    };\n    animation: string;\n    animationDuration: number;\n    animationDurationUpdate: number;\n    animationEasing: string;\n    animationEasingUpdate: string;\n    animationThreshold: number;\n    progressiveThreshold: number;\n    progressive: number;\n    hoverLayerThreshold: number;\n    useUTC: boolean;\n};\nexport default _default;\n"
  },
  {
    "path": "echarts/types/src/model/internalComponentCreator.d.ts",
    "code": "import GlobalModel from './Global';\nimport { ComponentOption, ComponentMainType } from '../util/types';\ninterface InternalOptionCreator {\n    (ecModel: GlobalModel): ComponentOption[];\n}\nexport declare function registerInternalOptionCreator(mainType: ComponentMainType, creator: InternalOptionCreator): void;\nexport declare function concatInternalOptions(ecModel: GlobalModel, mainType: ComponentMainType, newCmptOptionList: ComponentOption[]): ComponentOption[];\nexport {};\n"
  },
  {
    "path": "echarts/types/src/model/mixin/areaStyle.d.ts",
    "code": "import Model from '../Model';\nimport { AreaStyleOption } from '../../util/types';\nimport { PathStyleProps } from 'zrender/esm/graphic/Path';\nexport declare const AREA_STYLE_KEY_MAP: string[][];\ndeclare type AreaStyleProps = Pick<PathStyleProps, 'fill' | 'shadowBlur' | 'shadowOffsetX' | 'shadowOffsetY' | 'opacity' | 'shadowColor'>;\ndeclare class AreaStyleMixin {\n    getAreaStyle(this: Model, excludes?: readonly (keyof AreaStyleOption)[], includes?: readonly (keyof AreaStyleOption)[]): AreaStyleProps;\n}\nexport { AreaStyleMixin };\n"
  },
  {
    "path": "echarts/types/src/model/mixin/colorPalette.d.ts",
    "code": "import Model from '../Model';\nimport { ZRColor, ColorPaletteOptionMixin } from '../../util/types';\ninterface ColorPaletteMixin<T extends ColorPaletteOptionMixin = ColorPaletteOptionMixin> extends Pick<Model<T>, 'get'> {\n}\ndeclare class ColorPaletteMixin<T extends ColorPaletteOptionMixin = ColorPaletteOptionMixin> {\n    clearColorPalette(this: ColorPaletteMixin): void;\n    getColorFromPalette(this: ColorPaletteMixin, name: string, scope?: any, requestColorNum?: number): ZRColor;\n}\nexport { ColorPaletteMixin };\n"
  },
  {
    "path": "echarts/types/src/model/mixin/dataFormat.d.ts",
    "code": "import { DataHost, DisplayState, TooltipRenderMode, CallbackDataParams, OptionDataValue, SeriesDataType, TooltipOrderMode } from '../../util/types';\nimport GlobalModel from '../Global';\ninterface DataFormatMixin extends DataHost {\n    ecModel: GlobalModel;\n    mainType: string;\n    subType: string;\n    componentIndex: number;\n    id: string;\n    name: string;\n    animatedValue: OptionDataValue[];\n}\ndeclare class DataFormatMixin {\n    getDataParams(dataIndex: number, dataType?: SeriesDataType): CallbackDataParams;\n    getFormattedLabel(dataIndex: number, status?: DisplayState, dataType?: SeriesDataType, labelDimIndex?: number, formatter?: string | ((params: object) => string), extendParams?: Partial<CallbackDataParams>): string;\n    getRawValue(idx: number, dataType?: SeriesDataType): unknown;\n    formatTooltip(dataIndex: number, multipleSeries?: boolean, dataType?: string, renderMode?: TooltipRenderMode, order?: TooltipOrderMode): string | {\n        html: string;\n        markers: {\n            [markName: string]: string;\n        };\n    };\n}\nexport default DataFormatMixin;\n"
  },
  {
    "path": "echarts/types/src/model/mixin/itemStyle.d.ts",
    "code": "import Model from '../Model';\nimport { ItemStyleOption } from '../../util/types';\nimport { PathStyleProps } from 'zrender/esm/graphic/Path';\nexport declare const ITEM_STYLE_KEY_MAP: string[][];\ndeclare type ItemStyleKeys = 'fill' | 'stroke' | 'lineWidth' | 'opacity' | 'shadowBlur' | 'shadowOffsetX' | 'shadowOffsetY' | 'shadowColor';\nexport declare type ItemStyleProps = Pick<PathStyleProps, ItemStyleKeys>;\ndeclare class ItemStyleMixin {\n    getItemStyle(this: Model, excludes?: readonly (keyof ItemStyleOption)[], includes?: readonly (keyof ItemStyleOption)[]): ItemStyleProps;\n    getBorderLineDash(this: Model): number[];\n}\nexport { ItemStyleMixin };\n"
  },
  {
    "path": "echarts/types/src/model/mixin/lineStyle.d.ts",
    "code": "import Model from '../Model';\nimport { LineStyleOption } from '../../util/types';\nimport { PathStyleProps } from 'zrender/esm/graphic/Path';\nexport declare const LINE_STYLE_KEY_MAP: string[][];\ndeclare type LineStyleKeys = 'lineWidth' | 'stroke' | 'opacity' | 'shadowBlur' | 'shadowOffsetX' | 'shadowOffsetY' | 'shadowColor';\ndeclare type LineStyleProps = Pick<PathStyleProps, LineStyleKeys>;\ndeclare class LineStyleMixin {\n    getLineStyle(this: Model, excludes?: readonly (keyof LineStyleOption)[]): LineStyleProps;\n    getLineDash(this: Model, lineWidth?: number): false | number[];\n}\nexport { LineStyleMixin };\n"
  },
  {
    "path": "echarts/types/src/model/mixin/makeStyleMapper.d.ts",
    "code": "import Model from '../Model';\nimport { PathStyleProps } from 'zrender/esm/graphic/Path';\nexport default function (properties: readonly string[][], ignoreParent?: boolean): (model: Model<any>, excludes?: readonly string[], includes?: readonly string[]) => PathStyleProps;\n"
  },
  {
    "path": "echarts/types/src/model/mixin/textStyle.d.ts",
    "code": "import * as graphicUtil from '../../util/graphic';\nimport Model from '../Model';\nimport { LabelOption, ColorString } from '../../util/types';\nexport declare type LabelFontOption = Pick<LabelOption, 'fontStyle' | 'fontWeight' | 'fontSize' | 'fontFamily'>;\ndeclare type LabelRectRelatedOption = Pick<LabelOption, 'align' | 'verticalAlign' | 'padding' | 'lineHeight' | 'baseline' | 'rich'> & LabelFontOption;\ndeclare class TextStyleMixin {\n    getTextColor(this: Model, isEmphasis?: boolean): ColorString;\n    getFont(this: Model<LabelFontOption>): string;\n    getTextRect(this: Model<LabelRectRelatedOption> & TextStyleMixin, text: string): graphicUtil.BoundingRect;\n}\nexport default TextStyleMixin;\n"
  },
  {
    "path": "echarts/types/src/model/Model.d.ts",
    "code": "import { AreaStyleMixin } from './mixin/areaStyle';\nimport TextStyleMixin from './mixin/textStyle';\nimport { LineStyleMixin } from './mixin/lineStyle';\nimport { ItemStyleMixin } from './mixin/itemStyle';\nimport GlobalModel from './Global';\nimport { ModelOption } from '../util/types';\ndeclare class Model<Opt extends ModelOption = ModelOption> {\n    parentModel: Model;\n    ecModel: GlobalModel;\n    option: Opt;\n    constructor(option?: Opt, parentModel?: Model, ecModel?: GlobalModel);\n    init(option: Opt, parentModel?: Model, ecModel?: GlobalModel, ...rest: any): void;\n    mergeOption(option: Opt, ecModel?: GlobalModel): void;\n    get<R extends keyof Opt>(path: R, ignoreParent?: boolean): Opt[R];\n    get<R extends keyof Opt>(path: readonly [R], ignoreParent?: boolean): Opt[R];\n    get<R extends keyof Opt, S extends keyof Opt[R]>(path: readonly [R, S], ignoreParent?: boolean): Opt[R][S];\n    get<R extends keyof Opt, S extends keyof Opt[R], T extends keyof Opt[R][S]>(path: readonly [R, S, T], ignoreParent?: boolean): Opt[R][S][T];\n    getShallow<R extends keyof Opt>(key: R, ignoreParent?: boolean): Opt[R];\n    getModel<R extends keyof Opt>(path: R, parentModel?: Model): Model<Opt[R]>;\n    getModel<R extends keyof Opt>(path: readonly [R], parentModel?: Model): Model<Opt[R]>;\n    getModel<R extends keyof Opt, S extends keyof Opt[R]>(path: readonly [R, S], parentModel?: Model): Model<Opt[R][S]>;\n    getModel<Ra extends keyof Opt, Rb extends keyof Opt, S extends keyof Opt[Rb]>(path: readonly [Ra] | readonly [Rb, S], parentModel?: Model): Model<Opt[Ra]> | Model<Opt[Rb][S]>;\n    getModel<R extends keyof Opt, S extends keyof Opt[R], T extends keyof Opt[R][S]>(path: readonly [R, S, T], parentModel?: Model): Model<Opt[R][S][T]>;\n    isEmpty(): boolean;\n    restoreData(): void;\n    clone(): Model<Opt>;\n    parsePath(path: string | readonly string[]): readonly string[];\n    resolveParentPath(path: readonly string[]): string[];\n    isAnimationEnabled(): boolean;\n    private _doGet;\n}\ninterface Model extends LineStyleMixin, ItemStyleMixin, TextStyleMixin, AreaStyleMixin {\n}\nexport default Model;\n"
  },
  {
    "path": "echarts/types/src/model/OptionManager.d.ts",
    "code": "import ExtensionAPI from '../ExtensionAPI';\nimport { OptionPreprocessor, ECUnitOption, ECOption } from '../util/types';\nimport GlobalModel, { InnerSetOptionOpts } from './Global';\ndeclare class OptionManager {\n    private _api;\n    private _timelineOptions;\n    private _mediaList;\n    private _mediaDefault;\n    private _currentMediaIndices;\n    private _optionBackup;\n    private _newBaseOption;\n    constructor(api: ExtensionAPI);\n    setOption(rawOption: ECOption, optionPreprocessorFuncs: OptionPreprocessor[], opt: InnerSetOptionOpts): void;\n    mountOption(isRecreate: boolean): ECUnitOption;\n    getTimelineOption(ecModel: GlobalModel): ECUnitOption;\n    getMediaOption(ecModel: GlobalModel): ECUnitOption[];\n}\nexport default OptionManager;\n"
  },
  {
    "path": "echarts/types/src/model/referHelper.d.ts",
    "code": "import { HashMap } from 'zrender/esm/core/util';\nimport SeriesModel from './Series';\nimport { AxisBaseModel } from '../coord/AxisBaseModel';\ndeclare class CoordSysInfo {\n    coordSysName: string;\n    coordSysDims: string[];\n    axisMap: HashMap<AxisBaseModel<import(\"../coord/axisCommonTypes\").AxisBaseOption>, string | number>;\n    categoryAxisMap: HashMap<AxisBaseModel<import(\"../coord/axisCommonTypes\").AxisBaseOption>, string | number>;\n    firstCategoryDimIndex: number;\n    constructor(coordSysName: string);\n}\nexport declare function getCoordSysInfoBySeries(seriesModel: SeriesModel): CoordSysInfo;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/model/Series.d.ts",
    "code": "import { DataHost, DimensionName, SeriesOption, TooltipRenderMode, ZRColor, ScaleDataValue, Dictionary, ColorString, SeriesDataType } from '../util/types';\nimport ComponentModel from './Component';\nimport { ColorPaletteMixin } from './mixin/colorPalette';\nimport DataFormatMixin from '../model/mixin/dataFormat';\nimport Model from '../model/Model';\nimport GlobalModel from './Global';\nimport { CoordinateSystem } from '../coord/CoordinateSystem';\nimport { ExtendableConstructor, Constructor } from '../util/clazz';\nimport { PipelineContext, SeriesTask } from '../stream/Scheduler';\nimport LegendVisualProvider from '../visual/LegendVisualProvider';\nimport List from '../data/List';\nimport Source from '../data/Source';\nimport Axis from '../coord/Axis';\nimport { BrushCommonSelectorsForSeries, BrushSelectableArea } from '../component/brush/selector';\nimport makeStyleMapper from './mixin/makeStyleMapper';\ninterface SeriesModel {\n    preventIncremental(): boolean;\n    getTooltipPosition(dataIndex: number): number[];\n    getAxisTooltipData(dim: DimensionName[], value: ScaleDataValue, baseAxis: Axis): {\n        dataIndices: number[];\n        nestestValue: any;\n    };\n    getMarkerPosition(value: ScaleDataValue[]): number[];\n    brushSelector(dataIndex: number, data: List, selectors: BrushCommonSelectorsForSeries, area: BrushSelectableArea): boolean;\n}\ndeclare class SeriesModel<Opt extends SeriesOption = SeriesOption> extends ComponentModel<Opt> {\n    type: string;\n    defaultOption: SeriesOption;\n    seriesIndex: number;\n    coordinateSystem: CoordinateSystem;\n    dataTask: SeriesTask;\n    pipelineContext: PipelineContext;\n    legendVisualProvider: LegendVisualProvider;\n    visualStyleAccessPath: string;\n    visualDrawType: 'fill' | 'stroke';\n    visualStyleMapper: ReturnType<typeof makeStyleMapper>;\n    ignoreStyleOnData: boolean;\n    useColorPaletteOnData: boolean;\n    hasSymbolVisual: boolean;\n    defaultSymbol: string;\n    legendSymbol: string;\n    private _selectedDataIndicesMap;\n    readonly preventUsingHoverLayer: boolean;\n    static protoInitialize: void;\n    init(option: Opt, parentModel: Model, ecModel: GlobalModel): void;\n    mergeDefaultAndTheme(option: Opt, ecModel: GlobalModel): void;\n    mergeOption(newSeriesOption: Opt, ecModel: GlobalModel): void;\n    fillDataTextStyle(data: ArrayLike<any>): void;\n    getInitialData(option: Opt, ecModel: GlobalModel): List;\n    appendData(params: {\n        data: ArrayLike<any>;\n    }): void;\n    getData(dataType?: SeriesDataType): List<this>;\n    getAllData(): ({\n        data: List;\n        type?: SeriesDataType;\n    })[];\n    setData(data: List): void;\n    getSource(): Source;\n    getRawData(): List;\n    getBaseAxis(): Axis;\n    formatTooltip(dataIndex: number, multipleSeries?: boolean, dataType?: SeriesDataType, renderMode?: TooltipRenderMode): {\n        html: string;\n        markers: Dictionary<ColorString>;\n    } | string;\n    isAnimationEnabled(): boolean;\n    restoreData(): void;\n    getColorFromPalette(name: string, scope: any, requestColorNum?: number): ZRColor;\n    coordDimToDataDim(coordDim: DimensionName): DimensionName[];\n    getProgressive(): number | false;\n    getProgressiveThreshold(): number;\n    select(innerDataIndices: number[], dataType?: SeriesDataType): void;\n    unselect(innerDataIndices: number[], dataType?: SeriesDataType): void;\n    toggleSelect(innerDataIndices: number[], dataType?: SeriesDataType): void;\n    getSelectedDataIndices(): number[];\n    isSelected(dataIndex: number, dataType?: SeriesDataType): boolean;\n    private _innerSelect;\n    private _initSelectedMapFromData;\n    static registerClass(clz: Constructor): Constructor;\n}\ninterface SeriesModel<Opt extends SeriesOption = SeriesOption> extends DataFormatMixin, ColorPaletteMixin<Opt>, DataHost {\n    getShadowDim?(): string;\n}\nexport declare type SeriesModelConstructor = typeof SeriesModel & ExtendableConstructor;\nexport default SeriesModel;\n"
  },
  {
    "path": "echarts/types/src/option.d.ts",
    "code": "import { GridOption } from './coord/cartesian/GridModel';\nimport { PolarOption } from './coord/polar/PolarModel';\nimport { GeoOption } from './coord/geo/GeoModel';\nimport { RadiusAxisOption, AngleAxisOption } from './coord/polar/AxisModel';\nimport { CartesianAxisOption } from './coord/cartesian/AxisModel';\nimport { SingleAxisOption } from './coord/single/AxisModel';\nimport { ParallelAxisOption } from './coord/parallel/AxisModel';\nimport { ParallelCoordinateSystemOption } from './coord/parallel/ParallelModel';\nimport { CalendarOption } from './coord/calendar/CalendarModel';\nimport { ToolboxOption } from './component/toolbox/ToolboxModel';\nimport { TooltipOption } from './component/tooltip/TooltipModel';\nimport { AxisPointerOption } from './component/axisPointer/AxisPointerModel';\nimport { BrushOption } from './component/brush/BrushModel';\nimport { TitleOption } from './component/title';\nimport { TimelineOption } from './component/timeline/TimelineModel';\nimport { SliderTimelineOption } from './component/timeline/SliderTimelineModel';\nimport { LegendOption } from './component/legend/LegendModel';\nimport { ScrollableLegendOption } from './component/legend/ScrollableLegendModel';\nimport { SliderDataZoomOption } from './component/dataZoom/SliderZoomModel';\nimport { InsideDataZoomOption } from './component/dataZoom/InsideZoomModel';\nimport { ContinousVisualMapOption } from './component/visualMap/ContinuousModel';\nimport { PiecewiseVisualMapOption } from './component/visualMap/PiecewiseModel';\nimport { LineSeriesOption } from './chart/line/LineSeries';\nimport { BarSeriesOption } from './chart/bar/BarSeries';\nimport { ScatterSeriesOption } from './chart/scatter/ScatterSeries';\nimport { RadarSeriesOption } from './chart/radar/RadarSeries';\nimport { MapSeriesOption } from './chart/map/MapSeries';\nimport { TreeSeriesOption } from './chart/tree/TreeSeries';\nimport { TreemapSeriesOption } from './chart/treemap/TreemapSeries';\nimport { GraphSeriesOption } from './chart/graph/GraphSeries';\nimport { GaugeSeriesOption } from './chart/gauge/GaugeSeries';\nimport { FunnelSeriesOption } from './chart/funnel/FunnelSeries';\nimport { ParallelSeriesOption } from './chart/parallel/ParallelSeries';\nimport { SankeySeriesOption } from './chart/sankey/SankeySeries';\nimport { BoxplotSeriesOption } from './chart/boxplot/BoxplotSeries';\nimport { CandlestickSeriesOption } from './chart/candlestick/CandlestickSeries';\nimport { EffectScatterSeriesOption } from './chart/effectScatter/EffectScatterSeries';\nimport { LinesSeriesOption } from './chart/lines/LinesSeries';\nimport { HeatmapSeriesOption } from './chart/heatmap/HeatmapSeries';\nimport { PictorialBarSeriesOption } from './chart/bar/PictorialBarSeries';\nimport { ThemeRiverSeriesOption } from './chart/themeRiver/ThemeRiverSeries';\nimport { SunburstSeriesOption } from './chart/sunburst/SunburstSeries';\nimport { ECOption } from './util/types';\nexport interface EChartsFullOption extends ECOption {\n    title?: TitleOption | TitleOption[];\n    grid?: GridOption | GridOption[];\n    polar?: PolarOption | PolarOption[];\n    geo?: GeoOption | GeoOption[];\n    angleAxis?: AngleAxisOption | AngleAxisOption[];\n    radiusAxis?: RadiusAxisOption | RadiusAxisOption[];\n    xAxis?: CartesianAxisOption | CartesianAxisOption[];\n    yAxis?: CartesianAxisOption | CartesianAxisOption[];\n    singleAxis?: SingleAxisOption | SingleAxisOption[];\n    parallel?: ParallelCoordinateSystemOption | ParallelCoordinateSystemOption[];\n    parallelAxis?: ParallelAxisOption | ParallelAxisOption[];\n    calendar?: CalendarOption | CalendarOption[];\n    toolbox?: ToolboxOption | ToolboxOption[];\n    tooltip?: TooltipOption | TooltipOption[];\n    axisPointer?: AxisPointerOption | AxisPointerOption[];\n    brush?: BrushOption | BrushOption[];\n    timeline?: TimelineOption | SliderTimelineOption;\n    legend?: LegendOption | ScrollableLegendOption | (LegendOption | ScrollableLegendOption)[];\n    dataZoom?: SliderDataZoomOption | InsideDataZoomOption | (SliderDataZoomOption | InsideDataZoomOption)[];\n    visualMap?: (ContinousVisualMapOption | PiecewiseVisualMapOption)[];\n    series?: (LineSeriesOption | BarSeriesOption | ScatterSeriesOption | RadarSeriesOption | MapSeriesOption | TreeSeriesOption | TreemapSeriesOption | GraphSeriesOption | GaugeSeriesOption | FunnelSeriesOption | ParallelSeriesOption | SankeySeriesOption | BoxplotSeriesOption | CandlestickSeriesOption | EffectScatterSeriesOption | LinesSeriesOption | HeatmapSeriesOption | PictorialBarSeriesOption | ThemeRiverSeriesOption | SunburstSeriesOption)[];\n    options?: EChartsFullOption[];\n    baseOption?: EChartsFullOption;\n}\n"
  },
  {
    "path": "echarts/types/src/preprocessor/backwardCompat.d.ts",
    "code": "import { ECUnitOption } from '../util/types';\nexport default function (option: ECUnitOption, isTheme?: boolean): void;\n"
  },
  {
    "path": "echarts/types/src/preprocessor/helper/compatStyle.d.ts",
    "code": "export default function (option: any, isTheme?: boolean): void;\n"
  },
  {
    "path": "echarts/types/src/processor/dataFilter.d.ts",
    "code": "import { StageHandler } from '../util/types';\nexport default function (seriesType: string): StageHandler;\n"
  },
  {
    "path": "echarts/types/src/processor/dataSample.d.ts",
    "code": "import { StageHandler } from '../util/types';\nexport default function (seriesType: string): StageHandler;\n"
  },
  {
    "path": "echarts/types/src/processor/dataStack.d.ts",
    "code": "import GlobalModel from '../model/Global';\nexport default function (ecModel: GlobalModel): void;\n"
  },
  {
    "path": "echarts/types/src/scale/helper.d.ts",
    "code": "declare type intervalScaleNiceTicksResult = {\n    interval: number;\n    intervalPrecision: number;\n    niceTickExtent: [number, number];\n};\nexport declare function intervalScaleNiceTicks(extent: [number, number], splitNumber: number, minInterval?: number, maxInterval?: number): intervalScaleNiceTicksResult;\nexport declare function getIntervalPrecision(interval: number): number;\nexport declare function fixExtent(niceTickExtent: [number, number], extent: [number, number]): void;\nexport declare function contain(val: number, extent: [number, number]): boolean;\nexport declare function normalize(val: number, extent: [number, number]): number;\nexport declare function scale(val: number, extent: [number, number]): number;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/scale/Interval.d.ts",
    "code": "import Scale from './Scale';\nimport { ScaleTick } from '../util/types';\ndeclare class IntervalScale extends Scale {\n    static type: string;\n    type: string;\n    protected _interval: number;\n    protected _niceExtent: [number, number];\n    private _intervalPrecision;\n    parse(val: number): number;\n    contain(val: number): boolean;\n    normalize(val: number): number;\n    scale(val: number): number;\n    setExtent(start: number | string, end: number | string): void;\n    unionExtent(other: [number, number]): void;\n    getInterval(): number;\n    setInterval(interval: number): void;\n    getTicks(expandToNicedExtent?: boolean): ScaleTick[];\n    getMinorTicks(splitNumber: number): number[][];\n    getLabel(data: ScaleTick, opt?: {\n        precision?: 'auto' | number;\n        pad?: boolean;\n    }): string;\n    niceTicks(splitNumber?: number, minInterval?: number, maxInterval?: number): void;\n    niceExtent(opt: {\n        splitNumber: number;\n        fixMin?: boolean;\n        fixMax?: boolean;\n        minInterval?: number;\n        maxInterval?: number;\n    }): void;\n}\nexport default IntervalScale;\n"
  },
  {
    "path": "echarts/types/src/scale/Log.d.ts",
    "code": "import Scale from './Scale';\nimport IntervalScale from './Interval';\nimport List from '../data/List';\nimport { DimensionName, ScaleTick } from '../util/types';\ndeclare class LogScale extends Scale {\n    static type: string;\n    readonly type = \"log\";\n    base: number;\n    private _originalScale;\n    private _fixMin;\n    private _fixMax;\n    private _interval;\n    private _niceExtent;\n    getTicks(expandToNicedExtent: boolean): ScaleTick[];\n    setExtent(start: number, end: number): void;\n    getExtent(): [number, number];\n    unionExtent(extent: [number, number]): void;\n    unionExtentFromData(data: List, dim: DimensionName): void;\n    niceTicks(approxTickNum: number): void;\n    niceExtent(opt: {\n        splitNumber: number;\n        fixMin?: boolean;\n        fixMax?: boolean;\n        minInterval?: number;\n        maxInterval?: number;\n    }): void;\n    parse(val: any): number;\n    contain(val: number): boolean;\n    normalize(val: number): number;\n    scale(val: number): number;\n    getMinorTicks: IntervalScale['getMinorTicks'];\n    getLabel: IntervalScale['getLabel'];\n}\nexport default LogScale;\n"
  },
  {
    "path": "echarts/types/src/scale/Ordinal.d.ts",
    "code": "import Scale from './Scale';\nimport OrdinalMeta from '../data/OrdinalMeta';\nimport List from '../data/List';\nimport { OrdinalRawValue, OrdinalNumber, DimensionLoose, OrdinalSortInfo, OrdinalScaleTick, ScaleTick } from '../util/types';\nimport { AxisBaseOption } from '../coord/axisCommonTypes';\ndeclare class OrdinalScale extends Scale {\n    static type: string;\n    readonly type = \"ordinal\";\n    private _ordinalMeta;\n    private _categorySortInfo;\n    constructor(setting?: {\n        ordinalMeta?: OrdinalMeta | AxisBaseOption['data'];\n        extent?: [number, number];\n    });\n    parse(val: OrdinalRawValue | OrdinalNumber): OrdinalNumber;\n    contain(rank: OrdinalRawValue | OrdinalNumber): boolean;\n    normalize(val: OrdinalRawValue | OrdinalNumber): number;\n    scale(val: number): OrdinalNumber;\n    getTicks(): OrdinalScaleTick[];\n    getMinorTicks(splitNumber: number): number[][];\n    setCategorySortInfo(info: OrdinalSortInfo[]): void;\n    getCategorySortInfo(): OrdinalSortInfo[];\n    getCategoryIndex(n: OrdinalNumber): OrdinalNumber;\n    getRawIndex(displayIndex: OrdinalNumber): OrdinalNumber;\n    getLabel(tick: ScaleTick): string;\n    count(): number;\n    unionExtentFromData(data: List, dim: DimensionLoose): void;\n    isInExtentRange(value: number): boolean;\n    getOrdinalMeta(): OrdinalMeta;\n    niceTicks(): void;\n    niceExtent(): void;\n}\nexport default OrdinalScale;\n"
  },
  {
    "path": "echarts/types/src/scale/Scale.d.ts",
    "code": "import * as clazzUtil from '../util/clazz';\nimport { Dictionary } from 'zrender/esm/core/types';\nimport List from '../data/List';\nimport { DimensionName, ScaleDataValue, OptionDataValue, DimensionLoose, ScaleTick } from '../util/types';\nimport { ScaleRawExtentInfo } from '../coord/scaleRawExtentInfo';\ndeclare abstract class Scale {\n    type: string;\n    private _setting;\n    protected _extent: [number, number];\n    private _isBlank;\n    readonly rawExtentInfo: ScaleRawExtentInfo;\n    constructor(setting?: Dictionary<any>);\n    getSetting(name: string): any;\n    abstract parse(val: OptionDataValue): number;\n    abstract contain(val: ScaleDataValue): boolean;\n    abstract normalize(val: ScaleDataValue): number;\n    abstract scale(val: number): number;\n    unionExtent(other: [number, number]): void;\n    unionExtentFromData(data: List, dim: DimensionName | DimensionLoose): void;\n    getExtent(): [number, number];\n    setExtent(start: number, end: number): void;\n    isInExtentRange(value: number): boolean;\n    isBlank(): boolean;\n    setBlank(isBlank: boolean): void;\n    abstract niceTicks(splitNumber?: number, minInterval?: number, maxInterval?: number): void;\n    abstract niceExtent(opt?: {\n        splitNumber?: number;\n        fixMin?: boolean;\n        fixMax?: boolean;\n        minInterval?: number;\n        maxInterval?: number;\n    }): void;\n    abstract getLabel(tick: ScaleTick): string;\n    abstract getTicks(expandToNicedExtent?: boolean): ScaleTick[];\n    abstract getMinorTicks(splitNumber: number): number[][];\n    static registerClass: clazzUtil.ClassManager['registerClass'];\n    static getClass: clazzUtil.ClassManager['getClass'];\n}\nexport default Scale;\n"
  },
  {
    "path": "echarts/types/src/scale/Time.d.ts",
    "code": "import { TimeUnit } from '../util/time';\nimport IntervalScale from './Interval';\nimport { TimeScaleTick } from '../util/types';\nimport { TimeAxisLabelFormatterOption } from '../coord/axisCommonTypes';\nimport { LocaleOption } from '../locale';\nimport Model from '../model/Model';\ninterface TimeScale {\n    constructor(settings?: {\n        locale: Model<LocaleOption>;\n        useUTC: boolean;\n    }): void;\n}\ndeclare class TimeScale extends IntervalScale {\n    static type: string;\n    readonly type = \"time\";\n    _approxInterval: number;\n    _minLevelUnit: TimeUnit;\n    getLabel(tick: TimeScaleTick): string;\n    getFormattedLabel(tick: TimeScaleTick, idx: number, labelFormatter: TimeAxisLabelFormatterOption): string;\n    getTicks(expandToNicedExtent?: boolean): TimeScaleTick[];\n    niceExtent(opt?: {\n        splitNumber?: number;\n        fixMin?: boolean;\n        fixMax?: boolean;\n        minInterval?: number;\n        maxInterval?: number;\n    }): void;\n    niceTicks(approxTickNum: number, minInterval: number, maxInterval: number): void;\n    parse(val: number | string | Date): number;\n    contain(val: number): boolean;\n    normalize(val: number): number;\n    scale(val: number): number;\n}\nexport default TimeScale;\n"
  },
  {
    "path": "echarts/types/src/stream/Scheduler.d.ts",
    "code": "import { HashMap } from 'zrender/esm/core/util';\nimport { Task, TaskContext } from './task';\nimport GlobalModel from '../model/Global';\nimport ExtensionAPI from '../ExtensionAPI';\nimport { StageHandlerInternal, StageHandlerOverallReset, StageHandler, Payload, StageHandlerReset, StageHandlerPlan, StageHandlerProgressExecutor, SeriesLargeOptionMixin, SeriesOption } from '../util/types';\nimport { EChartsType } from '../echarts';\nimport SeriesModel from '../model/Series';\nimport ChartView from '../view/Chart';\nimport List from '../data/List';\nexport declare type GeneralTask = Task<TaskContext>;\nexport declare type SeriesTask = Task<SeriesTaskContext>;\nexport declare type OverallTask = Task<OverallTaskContext> & {\n    agentStubMap?: HashMap<StubTask>;\n};\nexport declare type StubTask = Task<StubTaskContext> & {\n    agent?: OverallTask;\n};\nexport declare type Pipeline = {\n    id: string;\n    head: GeneralTask;\n    tail: GeneralTask;\n    threshold: number;\n    progressiveEnabled: boolean;\n    blockIndex: number;\n    step: number;\n    count: number;\n    currentTask?: GeneralTask;\n    context?: PipelineContext;\n};\nexport declare type PipelineContext = {\n    progressiveRender: boolean;\n    modDataCount: number;\n    large: boolean;\n};\ndeclare type PerformStageTaskOpt = {\n    block?: boolean;\n    setDirty?: boolean;\n    visualType?: StageHandlerInternal['visualType'];\n    dirtyMap?: HashMap<any>;\n};\nexport interface SeriesTaskContext extends TaskContext {\n    model?: SeriesModel;\n    data?: List;\n    view?: ChartView;\n    ecModel?: GlobalModel;\n    api?: ExtensionAPI;\n    useClearVisual?: boolean;\n    plan?: StageHandlerPlan;\n    reset?: StageHandlerReset;\n    scheduler?: Scheduler;\n    payload?: Payload;\n    resetDefines?: StageHandlerProgressExecutor[];\n}\ninterface OverallTaskContext extends TaskContext {\n    ecModel: GlobalModel;\n    api: ExtensionAPI;\n    overallReset: StageHandlerOverallReset;\n    scheduler: Scheduler;\n    payload?: Payload;\n}\ninterface StubTaskContext extends TaskContext {\n    model: SeriesModel;\n    overallProgress: boolean;\n}\ndeclare class Scheduler {\n    readonly ecInstance: EChartsType;\n    readonly api: ExtensionAPI;\n    unfinished: boolean;\n    private _dataProcessorHandlers;\n    private _visualHandlers;\n    private _allHandlers;\n    private _stageTaskMap;\n    private _pipelineMap;\n    constructor(ecInstance: EChartsType, api: ExtensionAPI, dataProcessorHandlers: StageHandlerInternal[], visualHandlers: StageHandlerInternal[]);\n    restoreData(ecModel: GlobalModel, payload: Payload): void;\n    getPerformArgs(task: GeneralTask, isBlock?: boolean): {\n        step: number;\n        modBy: number;\n        modDataCount: number;\n    };\n    getPipeline(pipelineId: string): Pipeline;\n    updateStreamModes(seriesModel: SeriesModel<SeriesOption & SeriesLargeOptionMixin>, view: ChartView): void;\n    restorePipelines(ecModel: GlobalModel): void;\n    prepareStageTasks(): void;\n    prepareView(view: ChartView, model: SeriesModel, ecModel: GlobalModel, api: ExtensionAPI): void;\n    performDataProcessorTasks(ecModel: GlobalModel, payload?: Payload): void;\n    performVisualTasks(ecModel: GlobalModel, payload?: Payload, opt?: PerformStageTaskOpt): void;\n    private _performStageTasks;\n    performSeriesTasks(ecModel: GlobalModel): void;\n    plan(): void;\n    updatePayload(task: Task<SeriesTaskContext | OverallTaskContext>, payload: Payload | 'remain'): void;\n    private _createSeriesStageTask;\n    private _createOverallStageTask;\n    private _pipe;\n    static wrapStageHandler(stageHandler: StageHandler | StageHandlerOverallReset, visualType: StageHandlerInternal['visualType']): StageHandlerInternal;\n}\nexport default Scheduler;\n"
  },
  {
    "path": "echarts/types/src/stream/task.d.ts",
    "code": "import SeriesModel from '../model/Series';\nimport { Pipeline } from './Scheduler';\nimport { Payload } from '../util/types';\nimport List from '../data/List';\nexport interface TaskContext {\n    outputData?: List;\n    data?: List;\n    payload?: Payload;\n    model?: SeriesModel;\n}\nexport declare type TaskResetCallback<Ctx extends TaskContext> = (this: Task<Ctx>, context: Ctx) => TaskResetCallbackReturn<Ctx>;\nexport declare type TaskResetCallbackReturn<Ctx extends TaskContext> = void | (TaskProgressCallback<Ctx> | TaskProgressCallback<Ctx>[]) | {\n    forceFirstProgress?: boolean;\n    progress: TaskProgressCallback<Ctx> | TaskProgressCallback<Ctx>[];\n};\nexport declare type TaskProgressCallback<Ctx extends TaskContext> = (this: Task<Ctx>, params: TaskProgressParams, context: Ctx) => void;\nexport declare type TaskProgressParams = {\n    start: number;\n    end: number;\n    count: number;\n    next?: TaskDataIteratorNext;\n};\nexport declare type TaskPlanCallback<Ctx extends TaskContext> = (this: Task<Ctx>, context: Ctx) => TaskPlanCallbackReturn;\nexport declare type TaskPlanCallbackReturn = 'reset' | false | null | undefined;\nexport declare type TaskCountCallback<Ctx extends TaskContext> = (this: Task<Ctx>, context: Ctx) => number;\nexport declare type TaskOnDirtyCallback<Ctx extends TaskContext> = (this: Task<Ctx>, context: Ctx) => void;\ndeclare type TaskDataIteratorNext = () => number;\ndeclare type TaskDefineParam<Ctx extends TaskContext> = {\n    reset?: TaskResetCallback<Ctx>;\n    plan?: TaskPlanCallback<Ctx>;\n    count?: TaskCountCallback<Ctx>;\n    onDirty?: TaskOnDirtyCallback<Ctx>;\n};\nexport declare type PerformArgs = {\n    step?: number;\n    skip?: boolean;\n    modBy?: number;\n    modDataCount?: number;\n};\nexport declare function createTask<Ctx extends TaskContext>(define: TaskDefineParam<Ctx>): Task<Ctx>;\nexport declare class Task<Ctx extends TaskContext> {\n    private _reset;\n    private _plan;\n    private _count;\n    private _onDirty;\n    private _progress;\n    private _callingProgress;\n    private _dirty;\n    private _modBy;\n    private _modDataCount;\n    private _upstream;\n    private _downstream;\n    private _dueEnd;\n    private _outputDueEnd;\n    private _settedOutputEnd;\n    private _dueIndex;\n    private _disposed;\n    __pipeline: Pipeline;\n    __idxInPipeline: number;\n    __block: boolean;\n    context: Ctx;\n    constructor(define: TaskDefineParam<Ctx>);\n    perform(performArgs?: PerformArgs): boolean;\n    dirty(): void;\n    private _doProgress;\n    private _doReset;\n    unfinished(): boolean;\n    pipe(downTask: Task<Ctx>): void;\n    dispose(): void;\n    getUpstream(): Task<Ctx>;\n    getDownstream(): Task<Ctx>;\n    setOutputEnd(end: number): void;\n}\nexport {};\n"
  },
  {
    "path": "echarts/types/src/theme/dark.d.ts",
    "code": "declare const theme: {\n    darkMode: boolean;\n    color: string[];\n    backgroundColor: string;\n    axisPointer: {\n        lineStyle: {\n            color: string;\n        };\n        crossStyle: {\n            color: string;\n        };\n        label: {\n            color: string;\n        };\n    };\n    legend: {\n        textStyle: {\n            color: string;\n        };\n    };\n    textStyle: {\n        color: string;\n    };\n    title: {\n        textStyle: {\n            color: string;\n        };\n        subtextStyle: {\n            color: string;\n        };\n    };\n    toolbox: {\n        iconStyle: {\n            normal: {\n                borderColor: string;\n            };\n        };\n    };\n    dataZoom: {\n        borderColor: string;\n        textStyle: {\n            color: string;\n        };\n        brushStyle: {\n            color: string;\n        };\n        handleStyle: {\n            color: string;\n            borderColor: string;\n        };\n        moveHandleStyle: {\n            color: string;\n            opacity: number;\n        };\n        fillerColor: string;\n        emphasis: {\n            handleStyle: {\n                borderColor: string;\n                color: string;\n            };\n            moveHandleStyle: {\n                color: string;\n                opacity: number;\n            };\n        };\n        dataBackground: {\n            lineStyle: {\n                color: string;\n                width: number;\n            };\n            areaStyle: {\n                color: string;\n            };\n        };\n        selectedDataBackground: {\n            lineStyle: {\n                color: string;\n            };\n            areaStyle: {\n                color: string;\n            };\n        };\n    };\n    visualMap: {\n        textStyle: {\n            color: string;\n        };\n    };\n    timeline: {\n        lineStyle: {\n            color: string;\n        };\n        label: {\n            textStyle: {\n                color: string;\n            };\n        };\n        controlStyle: {\n            color: string;\n            borderColor: string;\n        };\n    };\n    calendar: {\n        itemStyle: {\n            color: string;\n        };\n        dayLabel: {\n            color: string;\n        };\n        monthLabel: {\n            color: string;\n        };\n        yearLabel: {\n            color: string;\n        };\n    };\n    timeAxis: {\n        axisLine: {\n            lineStyle: {\n                color: string;\n            };\n        };\n        splitLine: {\n            lineStyle: {\n                color: string;\n            };\n        };\n        splitArea: {\n            areaStyle: {\n                color: string[];\n            };\n        };\n        minorSplitLine: {\n            lineStyle: {\n                color: string;\n            };\n        };\n    };\n    logAxis: {\n        axisLine: {\n            lineStyle: {\n                color: string;\n            };\n        };\n        splitLine: {\n            lineStyle: {\n                color: string;\n            };\n        };\n        splitArea: {\n            areaStyle: {\n                color: string[];\n            };\n        };\n        minorSplitLine: {\n            lineStyle: {\n                color: string;\n            };\n        };\n    };\n    valueAxis: {\n        axisLine: {\n            lineStyle: {\n                color: string;\n            };\n        };\n        splitLine: {\n            lineStyle: {\n                color: string;\n            };\n        };\n        splitArea: {\n            areaStyle: {\n                color: string[];\n            };\n        };\n        minorSplitLine: {\n            lineStyle: {\n                color: string;\n            };\n        };\n    };\n    categoryAxis: {\n        axisLine: {\n            lineStyle: {\n                color: string;\n            };\n        };\n        splitLine: {\n            lineStyle: {\n                color: string;\n            };\n        };\n        splitArea: {\n            areaStyle: {\n                color: string[];\n            };\n        };\n        minorSplitLine: {\n            lineStyle: {\n                color: string;\n            };\n        };\n    };\n    line: {\n        symbol: string;\n    };\n    graph: {\n        color: string[];\n    };\n    gauge: {\n        title: {\n            textStyle: {\n                color: string;\n            };\n        };\n    };\n    candlestick: {\n        itemStyle: {\n            normal: {\n                color: string;\n                color0: string;\n                borderColor: string;\n                borderColor0: string;\n            };\n        };\n    };\n};\nexport default theme;\n"
  },
  {
    "path": "echarts/types/src/theme/light.d.ts",
    "code": "declare const _default: {\n    color: string[];\n    colorLayer: string[][];\n};\nexport default _default;\n"
  },
  {
    "path": "echarts/types/src/util/animation.d.ts",
    "code": "import Element, { ElementProps } from 'zrender/esm/Element';\nexport declare function createWrap(): {\n    add: (el: Element<ElementProps>, target: ElementProps, time?: number, delay?: number | \"linear\" | ((percent: number) => number) | \"quadraticIn\" | \"quadraticOut\" | \"quadraticInOut\" | \"cubicIn\" | \"cubicOut\" | \"cubicInOut\" | \"quarticIn\" | \"quarticOut\" | \"quarticInOut\" | \"quinticIn\" | \"quinticOut\" | \"quinticInOut\" | \"sinusoidalIn\" | \"sinusoidalOut\" | \"sinusoidalInOut\" | \"exponentialIn\" | \"exponentialOut\" | \"exponentialInOut\" | \"circularIn\" | \"circularOut\" | \"circularInOut\" | \"elasticIn\" | \"elasticOut\" | \"elasticInOut\" | \"backIn\" | \"backOut\" | \"backInOut\" | \"bounceIn\" | \"bounceOut\" | \"bounceInOut\" | \"spline\", easing?: import(\"zrender/esm/animation/easing\").AnimationEasing) => boolean;\n    done: (callback: () => void) => any;\n    start: () => any;\n};\n"
  },
  {
    "path": "echarts/types/src/util/clazz.d.ts",
    "code": "import { ComponentFullType, ComponentTypeInfo, ComponentMainType, ComponentSubType } from './types';\ndeclare const IS_EXTENDED_CLASS: \"___EC__EXTENDED_CLASS___\";\nexport declare function parseClassType(componentType: ComponentFullType): ComponentTypeInfo;\nexport declare function isExtendedClass(clz: any): boolean;\nexport interface ExtendableConstructor {\n    new (...args: any): any;\n    $constructor?: new (...args: any) => any;\n    extend: (proto: {\n        [name: string]: any;\n    }) => ExtendableConstructor;\n    superCall: (context: any, methodName: string, ...args: any) => any;\n    superApply: (context: any, methodName: string, args: []) => any;\n    superClass?: ExtendableConstructor;\n    [IS_EXTENDED_CLASS]?: boolean;\n}\nexport declare function enableClassExtend(rootClz: ExtendableConstructor, mandatoryMethods?: string[]): void;\nexport declare function mountExtend(SubClz: any, SupperClz: any): void;\nexport interface CheckableConstructor {\n    new (...args: any): any;\n    isInstance: (ins: any) => boolean;\n}\nexport declare function enableClassCheck(target: CheckableConstructor): void;\nexport declare type Constructor = new (...args: any) => any;\nexport interface ClassManager {\n    registerClass: (clz: Constructor) => Constructor;\n    getClass: (componentMainType: ComponentMainType, subType?: ComponentSubType, throwWhenNotFound?: boolean) => Constructor;\n    getClassesByMainType: (componentType: ComponentMainType) => Constructor[];\n    hasClass: (componentType: ComponentFullType) => boolean;\n    getAllClassMainTypes: () => ComponentMainType[];\n    hasSubTypes: (componentType: ComponentFullType) => boolean;\n}\nexport declare function enableClassManagement(target: ClassManager, options?: {\n    registerWhenExtend?: boolean;\n}): void;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/util/component.d.ts",
    "code": "import { ClassManager } from './clazz';\nimport { ComponentOption, ComponentMainType, ComponentSubType } from './types';\nexport declare function getUID(type: string): string;\nexport interface SubTypeDefaulter {\n    (option: ComponentOption): ComponentSubType;\n}\nexport interface SubTypeDefaulterManager {\n    registerSubTypeDefaulter: (componentType: string, defaulter: SubTypeDefaulter) => void;\n    determineSubType: (componentType: string, option: ComponentOption) => string;\n}\nexport declare function enableSubTypeDefaulter(target: SubTypeDefaulterManager & ClassManager): void;\nexport interface TopologicalTravelable<T> {\n    topologicalTravel: (targetNameList: ComponentMainType[], fullNameList: ComponentMainType[], callback: (this: T, mainType: string, dependencies: string[]) => void, context?: T) => void;\n}\nexport declare function enableTopologicalTravel<T>(entity: TopologicalTravelable<T>, dependencyGetter: (name: ComponentMainType) => ComponentMainType[]): void;\nexport declare function inheritDefaultOption<T, K>(superOption: T, subOption: K): K;\n"
  },
  {
    "path": "echarts/types/src/util/conditionalExpression.d.ts",
    "code": "import { OptionDataValue, DimensionLoose, Dictionary } from './types';\nimport { HashMap } from 'zrender/esm/core/util';\ninterface RelationalExpressionOptionByOp {\n    lt?: OptionDataValue;\n    lte?: OptionDataValue;\n    gt?: OptionDataValue;\n    gte?: OptionDataValue;\n    eq?: OptionDataValue;\n    ne?: OptionDataValue;\n    reg?: RegExp | string;\n}\ninterface RelationalExpressionOptionByOpAlias {\n    value?: RelationalExpressionOptionByOp['eq'];\n    '<'?: OptionDataValue;\n    '<='?: OptionDataValue;\n    '>'?: OptionDataValue;\n    '>='?: OptionDataValue;\n    '='?: OptionDataValue;\n    '!='?: OptionDataValue;\n    '<>'?: OptionDataValue;\n}\ninterface RelationalExpressionOption extends RelationalExpressionOptionByOp, RelationalExpressionOptionByOpAlias {\n    dimension?: DimensionLoose;\n    parse?: RelationalExpressionValueParserType;\n}\ndeclare type RelationalExpressionValueParserType = 'time' | 'trim';\ninterface LogicalExpressionOption {\n    and?: LogicalExpressionSubOption[];\n    or?: LogicalExpressionSubOption[];\n    not?: LogicalExpressionSubOption;\n}\ndeclare type LogicalExpressionSubOption = LogicalExpressionOption | RelationalExpressionOption | TrueFalseExpressionOption;\nexport declare type TrueExpressionOption = true;\nexport declare type FalseExpressionOption = false;\nexport declare type TrueFalseExpressionOption = TrueExpressionOption | FalseExpressionOption;\nexport declare type ConditionalExpressionOption = LogicalExpressionOption | RelationalExpressionOption | TrueFalseExpressionOption;\ndeclare type ValueGetterParam = Dictionary<unknown>;\nexport interface ConditionalExpressionValueGetterParamGetter<VGP extends ValueGetterParam = ValueGetterParam> {\n    (relExpOption: RelationalExpressionOption): VGP;\n}\nexport interface ConditionalExpressionValueGetter<VGP extends ValueGetterParam = ValueGetterParam> {\n    (param: VGP): OptionDataValue;\n}\ndeclare class ConditionalExpressionParsed {\n    private _cond;\n    constructor(exprOption: ConditionalExpressionOption, getters: ConditionalGetters);\n    evaluate(): boolean;\n}\ninterface ConditionalGetters<VGP extends ValueGetterParam = ValueGetterParam> {\n    prepareGetValue: ConditionalExpressionValueGetterParamGetter<VGP>;\n    getValue: ConditionalExpressionValueGetter<VGP>;\n    valueGetterAttrMap: HashMap<boolean, string>;\n}\nexport declare function parseConditionalExpression<VGP extends ValueGetterParam = ValueGetterParam>(exprOption: ConditionalExpressionOption, getters: ConditionalGetters<VGP>): ConditionalExpressionParsed;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/util/ecData.d.ts",
    "code": "import Element from 'zrender/esm/Element';\nimport { DataModel, ECEventData, BlurScope, InnerFocus, SeriesDataType } from './types';\nexport interface ECData {\n    dataIndex?: number;\n    dataModel?: DataModel;\n    eventData?: ECEventData;\n    seriesIndex?: number;\n    dataType?: SeriesDataType;\n    focus?: InnerFocus;\n    blurScope?: BlurScope;\n}\nexport declare const getECData: (hostObj: Element<import(\"zrender/esm/Element\").ElementProps>) => ECData;\n"
  },
  {
    "path": "echarts/types/src/util/ECEventProcessor.d.ts",
    "code": "import { EventProcessor, EventQuery } from 'zrender/esm/core/Eventful';\nimport { ECEvent, NormalizedEventQuery } from './types';\nimport ComponentModel from '../model/Component';\nimport ComponentView from '../view/Component';\nimport ChartView from '../view/Chart';\nimport Element from 'zrender/esm/Element';\nexport declare class ECEventProcessor implements EventProcessor {\n    eventInfo: {\n        targetEl: Element;\n        packedEvent: ECEvent;\n        model: ComponentModel;\n        view: ComponentView | ChartView;\n    };\n    normalizeQuery(query: EventQuery): NormalizedEventQuery;\n    filter(eventType: string, query: NormalizedEventQuery): boolean;\n    afterTrigger(): void;\n}\n"
  },
  {
    "path": "echarts/types/src/util/format.d.ts",
    "code": "import * as zrUtil from 'zrender/esm/core/util';\nimport { TooltipRenderMode, ColorString } from './types';\nimport { Dictionary } from 'zrender/esm/core/types';\nexport declare function addCommas(x: string | number): string;\nexport declare function toCamelCase(str: string, upperCaseFirst?: boolean): string;\nexport declare const normalizeCssArray: typeof zrUtil.normalizeCssArray;\nexport declare function encodeHTML(source: string): string;\nexport declare function concatTooltipHtml(html: string, value: unknown, dontEncodeHtml?: boolean): string;\nexport interface TplFormatterParam extends Dictionary<any> {\n    $vars: string[];\n}\nexport declare function formatTpl(tpl: string, paramsList: TplFormatterParam | TplFormatterParam[], encode?: boolean): string;\nexport declare function formatTplSimple(tpl: string, param: Dictionary<any>, encode?: boolean): string;\ninterface RichTextTooltipMarker {\n    renderMode: TooltipRenderMode;\n    content: string;\n    style: {\n        color: ColorString;\n        [key: string]: any;\n    };\n}\nexport declare type TooltipMarker = string | RichTextTooltipMarker;\ninterface GetTooltipMarkerOpt {\n    color?: ColorString;\n    extraCssText?: string;\n    type?: 'item' | 'subItem';\n    renderMode?: TooltipRenderMode;\n    markerId?: string;\n}\nexport declare function getTooltipMarker(color: ColorString, extraCssText?: string): TooltipMarker;\nexport declare function getTooltipMarker(opt: GetTooltipMarkerOpt): TooltipMarker;\nexport declare function formatTime(tpl: string, value: number | string | Date, isUTC?: boolean): string;\nexport declare function capitalFirst(str: string): string;\nexport { truncateText } from 'zrender/esm/graphic/helper/parseText';\nexport declare function windowOpen(link: string, target: string): void;\nexport { getTextRect } from '../legacy/getTextRect';\n"
  },
  {
    "path": "echarts/types/src/util/graphic.d.ts",
    "code": "import * as pathTool from 'zrender/esm/tool/path';\nimport * as matrix from 'zrender/esm/core/matrix';\nimport * as vector from 'zrender/esm/core/vector';\nimport Path from 'zrender/esm/graphic/Path';\nimport Transformable from 'zrender/esm/core/Transformable';\nimport ZRImage from 'zrender/esm/graphic/Image';\nimport Group from 'zrender/esm/graphic/Group';\nimport ZRText from 'zrender/esm/graphic/Text';\nimport Circle from 'zrender/esm/graphic/shape/Circle';\nimport Ellipse from 'zrender/esm/graphic/shape/Ellipse';\nimport Sector from 'zrender/esm/graphic/shape/Sector';\nimport Ring from 'zrender/esm/graphic/shape/Ring';\nimport Polygon from 'zrender/esm/graphic/shape/Polygon';\nimport Polyline from 'zrender/esm/graphic/shape/Polyline';\nimport Rect from 'zrender/esm/graphic/shape/Rect';\nimport Line from 'zrender/esm/graphic/shape/Line';\nimport BezierCurve from 'zrender/esm/graphic/shape/BezierCurve';\nimport Arc from 'zrender/esm/graphic/shape/Arc';\nimport CompoundPath from 'zrender/esm/graphic/CompoundPath';\nimport LinearGradient from 'zrender/esm/graphic/LinearGradient';\nimport RadialGradient from 'zrender/esm/graphic/RadialGradient';\nimport BoundingRect from 'zrender/esm/core/BoundingRect';\nimport OrientedBoundingRect from 'zrender/esm/core/OrientedBoundingRect';\nimport Point from 'zrender/esm/core/Point';\nimport IncrementalDisplayable from 'zrender/esm/graphic/IncrementalDisplayable';\nimport * as subPixelOptimizeUtil from 'zrender/esm/graphic/helper/subPixelOptimize';\nimport { DisplayableProps } from 'zrender/esm/graphic/Displayable';\nimport Element from 'zrender/esm/Element';\nimport Model from '../model/Model';\nimport { AnimationOptionMixin, LabelOption, ZRRectLike, ParsedValue } from './types';\nimport SeriesModel from '../model/Series';\nimport List from '../data/List';\ndeclare type ExtendShapeOpt = Parameters<typeof Path.extend>[0];\ndeclare type ExtendShapeReturn = ReturnType<typeof Path.extend>;\nexport declare function extendShape(opts: ExtendShapeOpt): ExtendShapeReturn;\ndeclare const extendPathFromString: typeof pathTool.extendFromString;\ndeclare type SVGPathOption = Parameters<typeof extendPathFromString>[1];\ndeclare type SVGPathCtor = ReturnType<typeof extendPathFromString>;\ndeclare type SVGPath = InstanceType<SVGPathCtor>;\nexport declare function extendPath(pathData: string, opts: SVGPathOption): SVGPathCtor;\nexport declare function registerShape(name: string, ShapeClass: {\n    new (): Path;\n}): void;\nexport declare function getShapeClass(name: string): {\n    new (): Path;\n};\nexport declare function makePath(pathData: string, opts: SVGPathOption, rect: ZRRectLike, layout?: 'center' | 'cover'): SVGPath;\nexport declare function makeImage(imageUrl: string, rect: ZRRectLike, layout?: 'center' | 'cover'): ZRImage;\nexport declare const mergePath: typeof pathTool.mergePath;\nexport declare function resizePath(path: SVGPath, rect: ZRRectLike): void;\nexport declare function subPixelOptimizeLine(param: {\n    shape: {\n        x1: number;\n        y1: number;\n        x2: number;\n        y2: number;\n    };\n    style: {\n        lineWidth: number;\n    };\n}): {\n    shape: {\n        x1: number;\n        y1: number;\n        x2: number;\n        y2: number;\n    };\n    style: {\n        lineWidth: number;\n    };\n};\nexport declare function subPixelOptimizeRect(param: {\n    shape: {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n    };\n    style: {\n        lineWidth: number;\n    };\n}): {\n    shape: {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n    };\n    style: {\n        lineWidth: number;\n    };\n};\nexport declare const subPixelOptimize: typeof subPixelOptimizeUtil.subPixelOptimize;\ndeclare type AnimateOrSetPropsOption = {\n    dataIndex?: number;\n    cb?: () => void;\n    during?: (percent: number) => void;\n    isFrom?: boolean;\n};\ndeclare function updateProps<Props>(el: Element<Props>, props: Props, animatableModel?: Model<AnimationOptionMixin>, dataIndex?: AnimateOrSetPropsOption['dataIndex'] | AnimateOrSetPropsOption['cb'] | AnimateOrSetPropsOption, cb?: AnimateOrSetPropsOption['cb'] | AnimateOrSetPropsOption['during'], during?: AnimateOrSetPropsOption['during']): void;\nexport { updateProps };\nexport declare function initProps<Props>(el: Element<Props>, props: Props, animatableModel?: Model<AnimationOptionMixin>, dataIndex?: AnimateOrSetPropsOption['dataIndex'] | AnimateOrSetPropsOption['cb'] | AnimateOrSetPropsOption, cb?: AnimateOrSetPropsOption['cb'] | AnimateOrSetPropsOption['during'], during?: AnimateOrSetPropsOption['during']): void;\nexport declare function removeElement<Props>(el: Element<Props>, props: Props, animatableModel?: Model<AnimationOptionMixin>, dataIndex?: AnimateOrSetPropsOption['dataIndex'] | AnimateOrSetPropsOption['cb'] | AnimateOrSetPropsOption, cb?: AnimateOrSetPropsOption['cb'] | AnimateOrSetPropsOption['during'], during?: AnimateOrSetPropsOption['during']): void;\nexport declare function removeElementWithFadeOut(el: Element, animatableModel?: Model<AnimationOptionMixin>, dataIndex?: number): void;\nexport declare function isElementRemoved(el: Element): boolean;\nexport declare function updateLabel<Props>(el: Element<Props>, data: List, dataIndex: number, labelModel: Model<LabelOption>, seriesModel: SeriesModel, animatableModel?: Model<AnimationOptionMixin>, defaultTextGetter?: (value: ParsedValue[] | ParsedValue) => string): void;\nexport declare function initLabel<Props>(el: Element<Props>, data: List, dataIndex: number, labelModel: Model<LabelOption>, seriesModel: SeriesModel, animatableModel?: Model<AnimationOptionMixin>, defaultTextGetter?: (value: ParsedValue[] | ParsedValue) => string): void;\nexport declare function getTransform(target: Transformable, ancestor?: Transformable): matrix.MatrixArray;\nexport declare function applyTransform(target: vector.VectorArray, transform: Transformable | matrix.MatrixArray, invert?: boolean): number[];\nexport declare function transformDirection(direction: 'left' | 'right' | 'top' | 'bottom', transform: matrix.MatrixArray, invert?: boolean): 'left' | 'right' | 'top' | 'bottom';\nexport declare function groupTransition(g1: Group, g2: Group, animatableModel: Model<AnimationOptionMixin>): void;\nexport declare function clipPointsByRect(points: vector.VectorArray[], rect: ZRRectLike): number[][];\nexport declare function clipRectByRect(targetRect: ZRRectLike, rect: ZRRectLike): ZRRectLike;\nexport declare function createIcon(iconStr: string, opt?: Omit<DisplayableProps, 'style'>, rect?: ZRRectLike): SVGPath | ZRImage;\nexport declare function linePolygonIntersect(a1x: number, a1y: number, a2x: number, a2y: number, points: vector.VectorArray[]): boolean;\nexport declare function lineLineIntersect(a1x: number, a1y: number, a2x: number, a2y: number, b1x: number, b1y: number, b2x: number, b2y: number): boolean;\nexport { Group, ZRImage as Image, ZRText as Text, Circle, Ellipse, Sector, Ring, Polygon, Polyline, Rect, Line, BezierCurve, Arc, IncrementalDisplayable, CompoundPath, LinearGradient, RadialGradient, BoundingRect, OrientedBoundingRect, Point, Path };\n"
  },
  {
    "path": "echarts/types/src/util/KDTree.d.ts",
    "code": "import { VectorArray } from 'zrender/esm/core/vector';\ndeclare type KDTreePoint = {\n    array: VectorArray;\n};\ndeclare class KDTreeNode<T> {\n    left: KDTreeNode<T>;\n    right: KDTreeNode<T>;\n    axis: number;\n    data: T;\n    constructor(axis: number, data: T);\n}\ndeclare class KDTree<T extends KDTreePoint> {\n    dimension: number;\n    root: KDTreeNode<T>;\n    private _stack;\n    private _nearstNList;\n    constructor(points: T[], dimension?: number);\n    private _buildTree;\n    nearest(target: T, squaredDistance: (a: T, b: T) => number): T;\n    _addNearest(found: number, dist: number, node: KDTreeNode<T>): void;\n    nearestN(target: T, N: number, squaredDistance: (a: T, b: T) => number, output: T[]): T[];\n}\nexport default KDTree;\n"
  },
  {
    "path": "echarts/types/src/util/layout.d.ts",
    "code": "import BoundingRect from 'zrender/esm/core/BoundingRect';\nimport { BoxLayoutOptionMixin, ComponentLayoutMode } from './types';\nimport { Group } from 'zrender/esm/export';\nimport Element from 'zrender/esm/Element';\nexport interface LayoutRect extends BoundingRect {\n    margin: number[];\n}\nexport interface NewlineElement extends Element {\n    newline: boolean;\n}\nexport declare const LOCATION_PARAMS: readonly [\"left\", \"right\", \"top\", \"bottom\", \"width\", \"height\"];\nexport declare const HV_NAMES: readonly [readonly [\"width\", \"left\", \"right\"], readonly [\"height\", \"top\", \"bottom\"]];\ndeclare function boxLayout(orient: 'horizontal' | 'vertical', group: Group, gap: number, maxWidth?: number, maxHeight?: number): void;\nexport declare const box: typeof boxLayout;\nexport declare const vbox: (group: Group, gap: number, maxWidth?: number, maxHeight?: number) => void;\nexport declare const hbox: (group: Group, gap: number, maxWidth?: number, maxHeight?: number) => void;\nexport declare function getAvailableSize(positionInfo: {\n    left?: number | string;\n    top?: number | string;\n    right?: number | string;\n    bottom?: number | string;\n}, containerRect: {\n    width: number;\n    height: number;\n}, margin?: number[] | number): {\n    width: number;\n    height: number;\n};\nexport declare function getLayoutRect(positionInfo: BoxLayoutOptionMixin & {\n    aspect?: number;\n}, containerRect: {\n    width: number;\n    height: number;\n}, margin?: number | number[]): LayoutRect;\nexport declare function positionElement(el: Element, positionInfo: BoxLayoutOptionMixin, containerRect: {\n    width: number;\n    height: number;\n}, margin?: number[] | number, opt?: {\n    hv: [1 | 0, 1 | 0];\n    boundingMode: 'all' | 'raw';\n}): void;\nexport declare function sizeCalculable(option: BoxLayoutOptionMixin, hvIdx: number): boolean;\nexport declare function fetchLayoutMode(ins: any): ComponentLayoutMode;\nexport declare function mergeLayoutParam<T extends BoxLayoutOptionMixin>(targetOption: T, newOption: T, opt?: ComponentLayoutMode): void;\nexport declare function getLayoutParams(source: BoxLayoutOptionMixin): BoxLayoutOptionMixin;\nexport declare function copyLayoutParams(target: BoxLayoutOptionMixin, source: BoxLayoutOptionMixin): BoxLayoutOptionMixin;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/util/log.d.ts",
    "code": "export declare function log(str: string): void;\nexport declare function warn(str: string): void;\nexport declare function deprecateLog(str: string): void;\nexport declare function deprecateReplaceLog(oldOpt: string, newOpt: string, scope?: string): void;\nexport declare function consoleLog(...args: unknown[]): void;\nexport declare function makePrintable(...hintInfo: unknown[]): string;\nexport declare function throwError(msg?: string): void;\n"
  },
  {
    "path": "echarts/types/src/util/model.d.ts",
    "code": "import { HashMap } from 'zrender/esm/core/util';\nimport GlobalModel from '../model/Global';\nimport ComponentModel, { ComponentModelConstructor } from '../model/Component';\nimport List from '../data/List';\nimport { ComponentOption, ComponentMainType, ComponentSubType, DisplayStateHostOption, OptionDataItem, OptionDataValue, TooltipRenderMode, Payload } from './types';\nimport SeriesModel from '../model/Series';\nimport CartesianAxisModel from '../coord/cartesian/AxisModel';\nimport GridModel from '../coord/cartesian/GridModel';\nexport declare function normalizeToArray<T>(value?: T | T[]): T[];\nexport declare function defaultEmphasis(opt: DisplayStateHostOption, key: string, subOpts: string[]): void;\nexport declare const TEXT_STYLE_OPTIONS: readonly [\"fontStyle\", \"fontWeight\", \"fontSize\", \"fontFamily\", \"rich\", \"tag\", \"color\", \"textBorderColor\", \"textBorderWidth\", \"width\", \"height\", \"lineHeight\", \"align\", \"verticalAlign\", \"baseline\", \"shadowColor\", \"shadowBlur\", \"shadowOffsetX\", \"shadowOffsetY\", \"textShadowColor\", \"textShadowBlur\", \"textShadowOffsetX\", \"textShadowOffsetY\", \"backgroundColor\", \"borderColor\", \"borderWidth\", \"borderRadius\", \"padding\"];\nexport declare function getDataItemValue(dataItem: OptionDataItem): OptionDataValue | OptionDataValue[];\nexport declare function isDataItemOption(dataItem: OptionDataItem): boolean;\nexport interface MappingExistingItem {\n    id?: string | number;\n    name?: string;\n}\ndeclare type MappingResult<T> = MappingResultItem<T>[];\ninterface MappingResultItem<T extends MappingExistingItem = MappingExistingItem> {\n    existing: T;\n    newOption: ComponentOption;\n    brandNew: boolean;\n    keyInfo: {\n        name: string;\n        id: string;\n        mainType: ComponentMainType;\n        subType: ComponentSubType;\n    };\n}\ndeclare type MappingToExistsMode = 'normalMerge' | 'replaceMerge' | 'replaceAll';\nexport declare function mappingToExists<T extends MappingExistingItem>(existings: T[], newCmptOptions: ComponentOption[], mode: MappingToExistsMode): MappingResult<T>;\nexport declare function validateIdOrName(idOrName: unknown): void;\nexport declare function isNameSpecified(componentModel: ComponentModel): boolean;\nexport declare function isComponentIdInternal(cmptOption: MappingExistingItem): boolean;\nexport declare function makeInternalComponentId(idSuffix: string): string;\nexport declare function setComponentTypeToKeyInfo(mappingResult: MappingResult<MappingExistingItem & {\n    subType?: ComponentSubType;\n}>, mainType: ComponentMainType, componentModelCtor: ComponentModelConstructor): void;\ndeclare type BatchItem = {\n    seriesId: string;\n    dataIndex: number[];\n};\nexport declare function compressBatches(batchA: BatchItem[], batchB: BatchItem[]): [BatchItem[], BatchItem[]];\nexport declare function queryDataIndex(data: List, payload: Payload & {\n    dataIndexInside?: number | number[];\n    dataIndex?: number | number[];\n    name?: string | string[];\n}): number | number[];\nexport declare function makeInner<T, Host extends object>(): (hostObj: Host) => T;\nexport declare type ModelFinderIndexQuery = number | number[] | 'all' | 'none' | false;\nexport declare type ModelFinderIdQuery = number | number[] | string | string[];\nexport declare type ModelFinderNameQuery = number | number[] | string | string[];\nexport declare type ModelFinder = string | ModelFinderObject;\nexport declare type ModelFinderObject = {\n    seriesIndex?: ModelFinderIndexQuery;\n    seriesId?: ModelFinderIdQuery;\n    seriesName?: ModelFinderNameQuery;\n    geoIndex?: ModelFinderIndexQuery;\n    geoId?: ModelFinderIdQuery;\n    geoName?: ModelFinderNameQuery;\n    bmapIndex?: ModelFinderIndexQuery;\n    bmapId?: ModelFinderIdQuery;\n    bmapName?: ModelFinderNameQuery;\n    xAxisIndex?: ModelFinderIndexQuery;\n    xAxisId?: ModelFinderIdQuery;\n    xAxisName?: ModelFinderNameQuery;\n    yAxisIndex?: ModelFinderIndexQuery;\n    yAxisId?: ModelFinderIdQuery;\n    yAxisName?: ModelFinderNameQuery;\n    gridIndex?: ModelFinderIndexQuery;\n    gridId?: ModelFinderIdQuery;\n    gridName?: ModelFinderNameQuery;\n    [key: string]: unknown;\n};\ndeclare type ParsedModelFinderKnown = {\n    seriesModels?: SeriesModel[];\n    seriesModel?: SeriesModel;\n    xAxisModels?: CartesianAxisModel[];\n    xAxisModel?: CartesianAxisModel;\n    yAxisModels?: CartesianAxisModel[];\n    yAxisModel?: CartesianAxisModel;\n    gridModels?: GridModel[];\n    gridModel?: GridModel;\n    dataIndex?: number;\n    dataIndexInside?: number;\n};\nexport declare type ParsedModelFinder = ParsedModelFinderKnown & {\n    [key: string]: ComponentModel | ComponentModel[];\n};\nexport declare function parseFinder(ecModel: GlobalModel, finderInput: ModelFinder, opt?: {\n    defaultMainType?: ComponentMainType;\n    includeMainTypes?: ComponentMainType[];\n}): ParsedModelFinder;\nexport declare type QueryReferringUserOption = {\n    index?: ModelFinderIndexQuery;\n    id?: ModelFinderIdQuery;\n    name?: ModelFinderNameQuery;\n};\nexport declare const SINGLE_REFERRING: QueryReferringOpt;\nexport declare const MULTIPLE_REFERRING: QueryReferringOpt;\nexport declare type QueryReferringOpt = {\n    useDefault: boolean;\n    enableAll: boolean;\n    enableNone: boolean;\n};\nexport declare function queryReferringComponents(ecModel: GlobalModel, mainType: ComponentMainType, userOption: QueryReferringUserOption, opt: QueryReferringOpt): {\n    models: ComponentModel[];\n    specified: boolean;\n};\nexport declare function setAttribute(dom: HTMLElement, key: string, value: any): void;\nexport declare function getAttribute(dom: HTMLElement, key: string): any;\nexport declare function getTooltipRenderMode(renderModeOption: TooltipRenderMode | 'auto'): TooltipRenderMode;\nexport declare function groupData<T, R extends string | number>(array: T[], getKey: (item: T) => R): {\n    keys: R[];\n    buckets: HashMap<T[], R>;\n};\nexport {};\n"
  },
  {
    "path": "echarts/types/src/util/number.d.ts",
    "code": "export declare function linearMap(val: number, domain: number[], range: number[], clamp?: boolean): number;\nexport declare function parsePercent(percent: number | string, all: number): number;\nexport declare function round(x: number | string, precision?: number): number;\nexport declare function round(x: number | string, precision: number, returnStr: false): number;\nexport declare function round(x: number | string, precision: number, returnStr: true): string;\nexport declare function asc<T extends number[]>(arr: T): T;\nexport declare function getPrecision(val: string | number): number;\nexport declare function getPrecisionSafe(val: string | number): number;\nexport declare function getPixelPrecision(dataExtent: [number, number], pixelExtent: [number, number]): number;\nexport declare function getPercentWithPrecision(valueList: number[], idx: number, precision: number): number;\nexport declare const MAX_SAFE_INTEGER = 9007199254740991;\nexport declare function remRadian(radian: number): number;\nexport declare function isRadianAroundZero(val: number): boolean;\nexport declare function parseDate(value: unknown): Date;\nexport declare function quantity(val: number): number;\nexport declare function quantityExponent(val: number): number;\nexport declare function nice(val: number, round?: boolean): number;\nexport declare function quantile(ascArr: number[], p: number): number;\ndeclare type IntervalItem = {\n    interval: [number, number];\n    close: [0 | 1, 0 | 1];\n};\nexport declare function reformIntervals(list: IntervalItem[]): IntervalItem[];\nexport declare function isNumeric(v: any): v is number;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/util/quickSelect.d.ts",
    "code": "declare type CompareFunc<T> = (a: T, b: T) => number;\ndeclare function quickSelect<T>(arr: T[], nth: number, compareFunc: CompareFunc<T>): number;\ndeclare function quickSelect<T>(arr: T[], nth: number, left: number, right: number, compareFunc: CompareFunc<T>): number;\nexport default quickSelect;\n"
  },
  {
    "path": "echarts/types/src/util/shape/sausage.d.ts",
    "code": "import { Path } from '../graphic';\nimport { PathProps } from 'zrender/esm/graphic/Path';\ndeclare class SausageShape {\n    cx: number;\n    cy: number;\n    r0: number;\n    r: number;\n    startAngle: number;\n    endAngle: number;\n    clockwise: boolean;\n}\ninterface SausagePathProps extends PathProps {\n    shape?: SausageShape;\n}\ndeclare class SausagePath extends Path<SausagePathProps> {\n    type: string;\n    constructor(opts?: SausagePathProps);\n    getDefaultShape(): SausageShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: SausageShape): void;\n}\nexport default SausagePath;\n"
  },
  {
    "path": "echarts/types/src/util/states.d.ts",
    "code": "import Displayable from 'zrender/esm/graphic/Displayable';\nimport Element, { ElementEvent } from 'zrender/esm/Element';\nimport Model from '../model/Model';\nimport { SeriesDataType, DisplayState, ECElement, BlurScope, InnerFocus, Payload, HighlightPayload, DownplayPayload } from './types';\nimport { EChartsType } from '../echarts';\nimport SeriesModel from '../model/Series';\nimport Path from 'zrender/esm/graphic/Path';\nimport GlobalModel from '../model/Global';\nexport declare const HOVER_STATE_NORMAL: 0;\nexport declare const HOVER_STATE_BLUR: 1;\nexport declare const HOVER_STATE_EMPHASIS: 2;\nexport declare const SPECIAL_STATES: readonly [\"emphasis\", \"blur\", \"select\"];\nexport declare const DISPLAY_STATES: readonly [\"normal\", \"emphasis\", \"blur\", \"select\"];\nexport declare const Z2_EMPHASIS_LIFT = 10;\nexport declare const Z2_SELECT_LIFT = 9;\nexport declare const HIGHLIGHT_ACTION_TYPE = \"highlight\";\nexport declare const DOWNPLAY_ACTION_TYPE = \"downplay\";\nexport declare const SELECT_ACTION_TYPE = \"select\";\nexport declare const UNSELECT_ACTION_TYPE = \"unselect\";\nexport declare const TOGGLE_SELECT_ACTION_TYPE = \"toggleSelect\";\nexport declare function setStatesFlag(el: ECElement, stateName: DisplayState): void;\nexport declare function clearStates(el: Element): void;\nexport declare function setDefaultStateProxy(el: Displayable): void;\nexport declare function enterEmphasisWhenMouseOver(el: Element, e: ElementEvent): void;\nexport declare function leaveEmphasisWhenMouseOut(el: Element, e: ElementEvent): void;\nexport declare function enterEmphasis(el: Element, highlightDigit?: number): void;\nexport declare function leaveEmphasis(el: Element, highlightDigit?: number): void;\nexport declare function enterBlur(el: Element): void;\nexport declare function leaveBlur(el: Element): void;\nexport declare function enterSelect(el: Element): void;\nexport declare function leaveSelect(el: Element): void;\nexport declare function toggleSeriesBlurState(targetSeriesIndex: number, focus: InnerFocus, blurScope: BlurScope, ecIns: EChartsType, isBlur: boolean): void;\nexport declare function toggleSeriesBlurStateFromPayload(seriesModel: SeriesModel, payload: Payload, ecIns: EChartsType): void;\nexport declare function toggleSelectionFromPayload(seriesModel: SeriesModel, payload: Payload, ecIns: EChartsType): void;\nexport declare function updateSeriesElementSelection(seriesModel: SeriesModel): void;\nexport declare function getAllSelectedIndices(ecModel: GlobalModel): {\n    seriesIndex: number;\n    dataType?: SeriesDataType;\n    dataIndex: number[];\n}[];\nexport declare function enableHoverEmphasis(el: Element, focus?: InnerFocus, blurScope?: BlurScope): void;\nexport declare function enableHoverFocus(el: Element, focus: InnerFocus, blurScope: BlurScope): void;\nexport declare function setStatesStylesFromModel(el: Displayable, itemModel: Model<Partial<Record<'emphasis' | 'blur' | 'select', any>>>, styleType?: string, getterType?: 'getItemStyle' | 'getLineStyle' | 'getAreaStyle'): void;\nexport declare function setAsHighDownDispatcher(el: Element, asDispatcher: boolean): void;\nexport declare function isHighDownDispatcher(el: Element): boolean;\nexport declare function getHighlightDigit(highlightKey: number): number;\nexport declare function isSelectChangePayload(payload: Payload): boolean;\nexport declare function isHighDownPayload(payload: Payload): payload is HighlightPayload | DownplayPayload;\nexport declare function savePathStates(el: Path): void;\n"
  },
  {
    "path": "echarts/types/src/util/styleCompat.d.ts",
    "code": "import { ZRStyleProps } from './types';\nimport { ElementTextConfig } from 'zrender/esm/Element';\nimport { TextStyleProps, TextProps } from 'zrender/esm/graphic/Text';\nimport { ItemStyleProps } from '../model/mixin/itemStyle';\nexport interface LegacyStyleProps {\n    legacy?: boolean;\n}\nexport declare function isEC4CompatibleStyle(style: ZRStyleProps & LegacyStyleProps, elType: string, hasOwnTextContentOption: boolean, hasOwnTextConfig: boolean): boolean;\nexport declare function convertFromEC4CompatibleStyle(hostStyle: ZRStyleProps, elType: string, isNormal: boolean): {\n    textContent: TextProps & {\n        type: string;\n    };\n    textConfig: ElementTextConfig;\n};\nexport declare function convertToEC4StyleForCustomSerise(itemStl: ItemStyleProps, txStl: TextStyleProps, txCfg: ElementTextConfig): ZRStyleProps;\nexport declare function warnDeprecated(deprecated: string, insteadApproach: string): void;\n"
  },
  {
    "path": "echarts/types/src/util/symbol.d.ts",
    "code": "import * as graphic from './graphic';\nimport { Dictionary } from 'zrender/esm/core/types';\nimport { ZRColor } from './types';\ndeclare type ECSymbol = graphic.Path & {\n    __isEmptyBrush?: boolean;\n    setColor: (color: ZRColor, innerColor?: string) => void;\n    getColor: () => ZRColor;\n};\nexport declare const symbolBuildProxies: Dictionary<ECSymbol>;\nexport declare function createSymbol(symbolType: string, x: number, y: number, w: number, h: number, color?: ZRColor, keepAspect?: boolean): ECSymbol;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/util/throttle.d.ts",
    "code": "declare type ThrottleFunction = (this: unknown, ...args: unknown[]) => void;\nexport declare type ThrottleType = 'fixRate' | 'debounce';\nexport interface ThrottleController {\n    clear(): void;\n    debounceNextCall(debounceDelay: number): void;\n}\nexport declare function throttle<T extends ThrottleFunction>(fn: T, delay?: number, debounce?: boolean): T & ThrottleController;\nexport declare function createOrUpdate<T, S extends keyof T, P = T[S]>(obj: T, fnAttr: S, rate: number, throttleType: ThrottleType): P extends ThrottleFunction ? P & ThrottleController : never;\nexport declare function clear<T, S extends keyof T>(obj: T, fnAttr: S): void;\nexport {};\n"
  },
  {
    "path": "echarts/types/src/util/time.d.ts",
    "code": "import { TimeAxisLabelFormatterOption } from './../coord/axisCommonTypes';\nimport { TimeScaleTick } from './types';\nimport { LocaleOption } from '../locale';\nimport Model from '../model/Model';\nexport declare const ONE_SECOND = 1000;\nexport declare const ONE_MINUTE: number;\nexport declare const ONE_HOUR: number;\nexport declare const ONE_DAY: number;\nexport declare const ONE_YEAR: number;\nexport declare const defaultLeveledFormatter: {\n    year: string;\n    month: string;\n    day: string;\n    hour: string;\n    minute: string;\n    second: string;\n    millisecond: string;\n    none: string;\n};\nexport declare const fullLeveledFormatter: {\n    year: string;\n    month: string;\n    day: string;\n    hour: string;\n    minute: string;\n    second: string;\n    millisecond: string;\n};\nexport declare type PrimaryTimeUnit = 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'month' | 'year';\nexport declare type TimeUnit = PrimaryTimeUnit | 'half-year' | 'quarter' | 'week' | 'half-week' | 'half-day' | 'quarter-day';\nexport declare const primaryTimeUnits: PrimaryTimeUnit[];\nexport declare const timeUnits: TimeUnit[];\nexport declare function pad(str: string | number, len: number): string;\nexport declare function getPrimaryTimeUnit(timeUnit: TimeUnit): PrimaryTimeUnit;\nexport declare function isPrimaryTimeUnit(timeUnit: TimeUnit): boolean;\nexport declare function getDefaultFormatPrecisionOfInterval(timeUnit: PrimaryTimeUnit): PrimaryTimeUnit;\nexport declare function format(time: Date | number, template: string, lang?: string | Model<LocaleOption>, isUTC?: boolean): string;\nexport declare function leveledFormat(tick: TimeScaleTick, idx: number, formatter: TimeAxisLabelFormatterOption, lang: string | Model<LocaleOption>, isUTC?: boolean): string;\nexport declare function getUnitFromValue(value: number | string | Date, isUTC: boolean): PrimaryTimeUnit;\nexport declare function getUnitValue(value: number | Date, unit?: TimeUnit, isUTC?: boolean): number;\nexport declare function fullYearGetterName(isUTC?: boolean): \"getUTCFullYear\" | \"getFullYear\";\nexport declare function monthGetterName(isUTC?: boolean): \"getUTCMonth\" | \"getMonth\";\nexport declare function dateGetterName(isUTC?: boolean): \"getUTCDate\" | \"getDate\";\nexport declare function hoursGetterName(isUTC?: boolean): \"getUTCHours\" | \"getHours\";\nexport declare function minutesGetterName(isUTC?: boolean): \"getUTCMinutes\" | \"getMinutes\";\nexport declare function secondsGetterName(isUTC?: boolean): \"getUTCSeconds\" | \"getSeconds\";\nexport declare function millisecondsGetterName(isUTC?: boolean): \"getUTCSeconds\" | \"getSeconds\";\nexport declare function fullYearSetterName(isUTC?: boolean): \"setUTCFullYear\" | \"setFullYear\";\nexport declare function monthSetterName(isUTC?: boolean): \"setUTCMonth\" | \"setMonth\";\nexport declare function dateSetterName(isUTC?: boolean): \"setUTCDate\" | \"setDate\";\nexport declare function hoursSetterName(isUTC?: boolean): \"setUTCHours\" | \"setHours\";\nexport declare function minutesSetterName(isUTC?: boolean): \"setUTCMinutes\" | \"setMinutes\";\nexport declare function secondsSetterName(isUTC?: boolean): \"setUTCSeconds\" | \"setSeconds\";\nexport declare function millisecondsSetterName(isUTC?: boolean): \"setUTCSeconds\" | \"setSeconds\";\n"
  },
  {
    "path": "echarts/types/src/util/types.d.ts",
    "code": "import Group from 'zrender/esm/graphic/Group';\nimport Element, { ElementEvent, ElementTextConfig } from 'zrender/esm/Element';\nimport DataFormatMixin from '../model/mixin/dataFormat';\nimport GlobalModel from '../model/Global';\nimport ExtensionAPI from '../ExtensionAPI';\nimport SeriesModel from '../model/Series';\nimport { HashMap } from 'zrender/esm/core/util';\nimport { TaskPlanCallbackReturn, TaskProgressParams } from '../stream/task';\nimport List, { ListDimensionType } from '../data/List';\nimport { Dictionary, ImageLike, TextAlign, TextVerticalAlign } from 'zrender/esm/core/types';\nimport { PatternObject } from 'zrender/esm/graphic/Pattern';\nimport Source from '../data/Source';\nimport { TooltipMarker } from './format';\nimport { AnimationEasing } from 'zrender/esm/animation/easing';\nimport { LinearGradientObject } from 'zrender/esm/graphic/LinearGradient';\nimport { RadialGradientObject } from 'zrender/esm/graphic/RadialGradient';\nimport { RectLike } from 'zrender/esm/core/BoundingRect';\nimport { TSpanStyleProps } from 'zrender/esm/graphic/TSpan';\nimport { PathStyleProps } from 'zrender/esm/graphic/Path';\nimport { ImageStyleProps } from 'zrender/esm/graphic/Image';\nimport ZRText, { TextStyleProps } from 'zrender/esm/graphic/Text';\nexport { Dictionary };\nexport declare type RendererType = 'canvas' | 'svg';\nexport declare type LayoutOrient = 'vertical' | 'horizontal';\nexport declare type HorizontalAlign = 'left' | 'center' | 'right';\nexport declare type VerticalAlign = 'top' | 'middle' | 'bottom';\nexport declare type ColorString = string;\nexport declare type ZRColor = ColorString | LinearGradientObject | RadialGradientObject | PatternObject;\nexport declare type ZRLineType = 'solid' | 'dotted' | 'dashed';\nexport declare type ZRFontStyle = 'normal' | 'italic' | 'oblique';\nexport declare type ZRFontWeight = 'normal' | 'bold' | 'bolder' | 'lighter' | number;\nexport declare type ZREasing = AnimationEasing;\nexport declare type ZRTextAlign = TextAlign;\nexport declare type ZRTextVerticalAlign = TextVerticalAlign;\nexport declare type ZRElementEvent = ElementEvent;\nexport declare type ZRRectLike = RectLike;\nexport declare type ZRStyleProps = PathStyleProps | ImageStyleProps | TSpanStyleProps | TextStyleProps;\nexport declare type ComponentFullType = string;\nexport declare type ComponentMainType = keyof ECUnitOption & string;\nexport declare type ComponentSubType = ComponentOption['type'];\nexport interface ComponentTypeInfo {\n    main: ComponentMainType;\n    sub: ComponentSubType;\n}\nexport interface ECElement extends Element {\n    tooltip?: CommonTooltipOption<unknown> & {\n        content?: string;\n        formatterParams?: unknown;\n    };\n    highDownSilentOnTouch?: boolean;\n    onHoverStateChange?: (toState: DisplayState) => void;\n    hoverState?: 0 | 1 | 2;\n    selected?: boolean;\n    z2EmphasisLift?: number;\n    z2SelectLift?: number;\n    disableLabelAnimation?: boolean;\n    disableLabelLayout?: boolean;\n}\nexport interface DataHost {\n    getData(dataType?: SeriesDataType): List;\n}\nexport interface DataModel extends DataHost, DataFormatMixin {\n}\ninterface PayloadItem {\n    excludeSeriesId?: string | string[];\n    animation?: PayloadAnimationPart;\n    [other: string]: any;\n}\nexport interface Payload extends PayloadItem {\n    type: string;\n    escapeConnect?: boolean;\n    statusChanged?: boolean;\n    batch?: PayloadItem[];\n}\nexport interface HighlightPayload extends Payload {\n    type: 'highlight';\n    notBlur?: boolean;\n}\nexport interface DownplayPayload extends Payload {\n    type: 'downplay';\n    notBlur?: boolean;\n}\nexport interface PayloadAnimationPart {\n    duration?: number;\n    easing?: AnimationEasing;\n    delay?: number;\n}\nexport interface SelectChangedPayload extends Payload {\n    type: 'selectchanged';\n    escapeConnect: boolean;\n    isFromClick: boolean;\n    fromAction: 'select' | 'unselect' | 'toggleSelected';\n    fromActionPayload: Payload;\n    selected: {\n        seriesIndex: number;\n        dataType?: SeriesDataType;\n        dataIndex: number[];\n    }[];\n}\nexport interface ViewRootGroup extends Group {\n    __ecComponentInfo?: {\n        mainType: string;\n        index: number;\n    };\n}\nexport interface ECEvent extends ECEventData {\n    type: string;\n    componentType?: string;\n    componentIndex?: number;\n    seriesIndex?: number;\n    escapeConnect?: boolean;\n    event?: ElementEvent;\n    batch?: ECEventData;\n}\nexport interface ECEventData {\n    [key: string]: any;\n}\nexport interface EventQueryItem {\n    [key: string]: any;\n}\nexport interface NormalizedEventQuery {\n    cptQuery: EventQueryItem;\n    dataQuery: EventQueryItem;\n    otherQuery: EventQueryItem;\n}\nexport interface ActionInfo {\n    type: string;\n    event?: string;\n    update?: string;\n}\nexport interface ActionHandler {\n    (payload: Payload, ecModel: GlobalModel, api: ExtensionAPI): void | ECEventData;\n}\nexport interface OptionPreprocessor {\n    (option: ECUnitOption, isTheme: boolean): void;\n}\nexport interface PostUpdater {\n    (ecModel: GlobalModel, api: ExtensionAPI): void;\n}\nexport interface StageHandlerReset {\n    (seriesModel: SeriesModel, ecModel: GlobalModel, api: ExtensionAPI, payload?: Payload): StageHandlerProgressExecutor | StageHandlerProgressExecutor[] | void;\n}\nexport interface StageHandlerOverallReset {\n    (ecModel: GlobalModel, api: ExtensionAPI, payload?: Payload): void;\n}\nexport interface StageHandler {\n    seriesType?: string;\n    createOnAllSeries?: boolean;\n    performRawSeries?: boolean;\n    plan?: StageHandlerPlan;\n    overallReset?: StageHandlerOverallReset;\n    reset?: StageHandlerReset;\n    getTargetSeries?: (ecModel: GlobalModel, api: ExtensionAPI) => HashMap<SeriesModel>;\n}\nexport interface StageHandlerInternal extends StageHandler {\n    uid: string;\n    visualType?: 'layout' | 'visual';\n    __prio: number;\n    __raw: StageHandler | StageHandlerOverallReset;\n    isVisual?: boolean;\n    isLayout?: boolean;\n}\nexport declare type StageHandlerProgressParams = TaskProgressParams;\nexport interface StageHandlerProgressExecutor {\n    dataEach?: (data: List, idx: number) => void;\n    progress?: (params: StageHandlerProgressParams, data: List) => void;\n}\nexport declare type StageHandlerPlanReturn = TaskPlanCallbackReturn;\nexport interface StageHandlerPlan {\n    (seriesModel: SeriesModel, ecModel: GlobalModel, api: ExtensionAPI, payload?: Payload): StageHandlerPlanReturn;\n}\nexport interface LoadingEffectCreator {\n    (api: ExtensionAPI, cfg: object): LoadingEffect;\n}\nexport interface LoadingEffect extends Element {\n    resize: () => void;\n}\nexport declare type TooltipRenderMode = 'html' | 'richText';\nexport declare type TooltipOrderMode = 'valueAsc' | 'valueDesc' | 'seriesAsc' | 'seriesDesc';\nexport declare type OrdinalRawValue = string | number;\nexport declare type OrdinalNumber = number;\nexport declare type OrdinalSortInfo = {\n    ordinalNumber: OrdinalNumber;\n    beforeSortIndex: number;\n};\nexport declare type ParsedValueNumeric = number | OrdinalNumber;\nexport declare type ParsedValue = ParsedValueNumeric | OrdinalRawValue;\nexport declare type ScaleDataValue = ParsedValue | Date;\nexport interface ScaleTick {\n    value: number;\n}\nexport interface TimeScaleTick extends ScaleTick {\n    level?: number;\n}\nexport interface OrdinalScaleTick extends ScaleTick {\n    value: OrdinalNumber;\n}\nexport declare type DimensionIndex = number;\nexport declare type DimensionIndexLoose = DimensionIndex | string;\nexport declare type DimensionName = string;\nexport declare type DimensionLoose = DimensionName | DimensionIndexLoose;\nexport declare type DimensionType = ListDimensionType;\nexport declare const VISUAL_DIMENSIONS: HashMap<number, \"label\" | \"tooltip\" | \"itemName\" | \"itemId\" | \"seriesName\">;\nexport interface DataVisualDimensions {\n    tooltip?: DimensionIndex | false;\n    label?: DimensionIndex;\n    itemName?: DimensionIndex;\n    itemId?: DimensionIndex;\n    seriesName?: DimensionIndex;\n}\nexport declare type DimensionDefinition = {\n    type?: ListDimensionType;\n    name: DimensionName;\n    displayName?: string;\n};\nexport declare type DimensionDefinitionLoose = DimensionDefinition['name'] | DimensionDefinition;\nexport declare const SOURCE_FORMAT_ORIGINAL: \"original\";\nexport declare const SOURCE_FORMAT_ARRAY_ROWS: \"arrayRows\";\nexport declare const SOURCE_FORMAT_OBJECT_ROWS: \"objectRows\";\nexport declare const SOURCE_FORMAT_KEYED_COLUMNS: \"keyedColumns\";\nexport declare const SOURCE_FORMAT_TYPED_ARRAY: \"typedArray\";\nexport declare const SOURCE_FORMAT_UNKNOWN: \"unknown\";\nexport declare type SourceFormat = typeof SOURCE_FORMAT_ORIGINAL | typeof SOURCE_FORMAT_ARRAY_ROWS | typeof SOURCE_FORMAT_OBJECT_ROWS | typeof SOURCE_FORMAT_KEYED_COLUMNS | typeof SOURCE_FORMAT_TYPED_ARRAY | typeof SOURCE_FORMAT_UNKNOWN;\nexport declare const SERIES_LAYOUT_BY_COLUMN: \"column\";\nexport declare const SERIES_LAYOUT_BY_ROW: \"row\";\nexport declare type SeriesLayoutBy = typeof SERIES_LAYOUT_BY_COLUMN | typeof SERIES_LAYOUT_BY_ROW;\nexport declare type OptionSourceHeader = boolean | 'auto' | number;\nexport declare type SeriesDataType = 'main' | 'node' | 'edge';\nexport declare type ECUnitOption = {\n    baseOption?: unknown;\n    options?: unknown;\n    media?: unknown;\n    timeline?: ComponentOption | ComponentOption[];\n    backgroundColor?: ZRColor;\n    darkMode?: boolean | 'auto';\n    textStyle?: Pick<LabelOption, 'color' | 'fontStyle' | 'fontWeight' | 'fontSize' | 'fontFamily'>;\n    [key: string]: ComponentOption | ComponentOption[] | Dictionary<unknown> | unknown;\n} & AnimationOptionMixin & ColorPaletteOptionMixin;\nexport interface ECOption extends ECUnitOption {\n    baseOption?: ECUnitOption;\n    timeline?: ComponentOption;\n    options?: ECUnitOption[];\n    media?: MediaUnit[];\n}\nexport declare type OptionSourceData<VAL extends OptionDataValue = OptionDataValue, ORIITEM extends OptionDataItemOriginal<VAL> = OptionDataItemOriginal<VAL>> = OptionSourceDataOriginal<VAL, ORIITEM> | OptionSourceDataObjectRows<VAL> | OptionSourceDataArrayRows<VAL> | OptionSourceDataKeyedColumns<VAL> | OptionSourceDataTypedArray;\nexport declare type OptionDataItemOriginal<VAL extends OptionDataValue = OptionDataValue> = VAL | VAL[] | OptionDataItemObject<VAL>;\nexport declare type OptionSourceDataOriginal<VAL extends OptionDataValue = OptionDataValue, ORIITEM extends OptionDataItemOriginal<VAL> = OptionDataItemOriginal<VAL>> = ArrayLike<ORIITEM>;\nexport declare type OptionSourceDataObjectRows<VAL extends OptionDataValue = OptionDataValue> = ArrayLike<Dictionary<VAL>>;\nexport declare type OptionSourceDataArrayRows<VAL extends OptionDataValue = OptionDataValue> = ArrayLike<ArrayLike<VAL>>;\nexport declare type OptionSourceDataKeyedColumns<VAL extends OptionDataValue = OptionDataValue> = Dictionary<ArrayLike<VAL>>;\nexport declare type OptionSourceDataTypedArray = ArrayLike<number>;\nexport declare type OptionDataItem = OptionDataValue | Dictionary<OptionDataValue> | OptionDataValue[] | OptionDataItemObject<OptionDataValue>;\nexport declare type OptionDataItemObject<T> = {\n    id?: string | number;\n    name?: string;\n    value?: T[] | T;\n    selected?: boolean;\n};\nexport interface GraphEdgeItemObject<VAL extends OptionDataValue> extends OptionDataItemObject<VAL> {\n    source?: string | number;\n    target?: string | number;\n}\nexport declare type OptionDataValue = string | number | Date;\nexport declare type OptionDataValueNumeric = number | '-';\nexport declare type OptionDataValueCategory = string;\nexport declare type OptionDataValueDate = Date | string | number;\nexport declare type ModelOption = any;\nexport declare type ThemeOption = Dictionary<any>;\nexport declare type DisplayState = 'normal' | 'emphasis' | 'blur' | 'select';\nexport declare type DisplayStateNonNormal = Exclude<DisplayState, 'normal'>;\nexport declare type DisplayStateHostOption = {\n    emphasis?: Dictionary<any>;\n    [key: string]: any;\n};\nexport interface OptionEncodeVisualDimensions {\n    tooltip?: OptionEncodeValue;\n    label?: OptionEncodeValue;\n    itemName?: OptionEncodeValue;\n    itemId?: OptionEncodeValue;\n    seriesName?: OptionEncodeValue;\n}\nexport interface OptionEncode extends OptionEncodeVisualDimensions {\n    [coordDim: string]: OptionEncodeValue;\n}\nexport declare type OptionEncodeValue = DimensionLoose | DimensionLoose[];\nexport declare type EncodeDefaulter = (source: Source, dimCount: number) => OptionEncode;\nexport interface CallbackDataParams {\n    componentType: string;\n    componentSubType: string;\n    componentIndex: number;\n    seriesType?: string;\n    seriesIndex?: number;\n    seriesId?: string;\n    seriesName?: string;\n    name: string;\n    dataIndex: number;\n    data: any;\n    dataType?: SeriesDataType;\n    value: any;\n    color?: ZRColor;\n    borderColor?: string;\n    dimensionNames?: DimensionName[];\n    encode?: DimensionUserOuputEncode;\n    marker?: TooltipMarker;\n    status?: DisplayState;\n    dimensionIndex?: number;\n    percent?: number;\n    $vars: string[];\n}\nexport declare type DimensionUserOuputEncode = {\n    [coordOrVisualDimName: string]: DimensionIndex[];\n};\nexport declare type DimensionUserOuput = {\n    dimensionNames: DimensionName[];\n    encode: DimensionUserOuputEncode;\n};\nexport interface MediaQuery {\n    minWidth?: number;\n    maxWidth?: number;\n    minHeight?: number;\n    maxHeight?: number;\n    minAspectRatio?: number;\n    maxAspectRatio?: number;\n}\nexport declare type MediaUnit = {\n    query: MediaQuery;\n    option: ECUnitOption;\n};\nexport declare type ComponentLayoutMode = {\n    type: 'box';\n    ignoreSize?: boolean | boolean[];\n};\nexport interface ColorPaletteOptionMixin {\n    color?: ZRColor | ZRColor[];\n    colorLayer?: ZRColor[][];\n}\nexport interface BoxLayoutOptionMixin {\n    width?: number | string;\n    height?: number | string;\n    top?: number | string;\n    right?: number | string;\n    bottom?: number | string;\n    left?: number | string;\n}\nexport interface CircleLayoutOptionMixin {\n    center?: (number | string)[];\n    radius?: (number | string)[] | number | string;\n}\nexport interface ShadowOptionMixin {\n    shadowBlur?: number;\n    shadowColor?: ColorString;\n    shadowOffsetX?: number;\n    shadowOffsetY?: number;\n}\nexport interface BorderOptionMixin {\n    borderColor?: string;\n    borderWidth?: number;\n    borderType?: ZRLineType;\n}\nexport declare type AnimationDelayCallbackParam = {\n    count: number;\n    index: number;\n};\nexport declare type AnimationDurationCallback = (idx: number) => number;\nexport declare type AnimationDelayCallback = (idx: number, params?: AnimationDelayCallbackParam) => number;\nexport interface AnimationOption {\n    duration?: number;\n    easing?: AnimationEasing;\n    delay?: number;\n}\nexport interface AnimationOptionMixin {\n    animation?: boolean;\n    animationThreshold?: number;\n    animationDuration?: number | AnimationDurationCallback;\n    animationEasing?: AnimationEasing;\n    animationDelay?: AnimationDelayCallback;\n    animationDurationUpdate?: number | AnimationDurationCallback;\n    animationEasingUpdate?: AnimationEasing;\n    animationDelayUpdate?: number | AnimationDelayCallback;\n}\nexport interface RoamOptionMixin {\n    roam?: boolean | 'pan' | 'move' | 'zoom' | 'scale';\n    center?: number[];\n    zoom?: number;\n    scaleLimit?: {\n        min?: number;\n        max?: number;\n    };\n}\nexport declare type SymbolSizeCallback<T> = (rawValue: any, params: T) => number | number[];\nexport declare type SymbolCallback<T> = (rawValue: any, params: T) => string;\nexport declare type SymbolRotateCallback<T> = (rawValue: any, params: T) => number;\nexport interface SymbolOptionMixin<T = unknown> {\n    symbol?: string | (unknown extends T ? never : SymbolCallback<T>);\n    symbolSize?: number | number[] | (unknown extends T ? never : SymbolSizeCallback<T>);\n    symbolRotate?: number | (unknown extends T ? never : SymbolRotateCallback<T>);\n    symbolKeepAspect?: boolean;\n    symbolOffset?: number[];\n}\nexport interface ItemStyleOption extends ShadowOptionMixin, BorderOptionMixin {\n    color?: ZRColor;\n    opacity?: number;\n}\nexport interface LineStyleOption<Clr = ZRColor> extends ShadowOptionMixin {\n    width?: number;\n    color?: Clr;\n    opacity?: number;\n    type?: ZRLineType;\n}\nexport interface AreaStyleOption<Clr = ZRColor> extends ShadowOptionMixin {\n    color?: Clr;\n    opacity?: number;\n}\ndeclare type Arrayable<T extends Dictionary<any>> = {\n    [key in keyof T]: T[key] | T[key][];\n};\ndeclare type Dictionaryable<T extends Dictionary<any>> = {\n    [key in keyof T]: T[key] | Dictionary<T[key]>;\n};\nexport interface VisualOptionUnit {\n    symbol?: string;\n    symbolSize?: number;\n    color?: ColorString;\n    colorAlpha?: number;\n    opacity?: number;\n    colorLightness?: number;\n    colorSaturation?: number;\n    colorHue?: number;\n    liftZ?: number;\n}\nexport declare type VisualOptionFixed = VisualOptionUnit;\nexport declare type VisualOptionPiecewise = VisualOptionUnit;\nexport declare type VisualOptionLinear = Arrayable<VisualOptionUnit>;\nexport declare type VisualOptionCategory = Arrayable<VisualOptionUnit> | Dictionaryable<VisualOptionUnit>;\nexport declare type BuiltinVisualProperty = keyof VisualOptionUnit;\nexport interface TextCommonOption extends ShadowOptionMixin {\n    color?: string;\n    fontStyle?: ZRFontStyle;\n    fontWeight?: ZRFontWeight;\n    fontFamily?: string;\n    fontSize?: number | string;\n    align?: HorizontalAlign;\n    verticalAlign?: VerticalAlign;\n    baseline?: VerticalAlign;\n    opacity?: number;\n    lineHeight?: number;\n    backgroundColor?: ColorString | {\n        image: ImageLike;\n    };\n    borderColor?: string;\n    borderWidth?: number;\n    borderRadius?: number | number[];\n    padding?: number | number[];\n    width?: number | string;\n    height?: number;\n    textBorderColor?: string;\n    textBorderWidth?: number;\n    textShadowBlur?: number;\n    textShadowColor?: string;\n    textShadowOffsetX?: number;\n    textShadowOffsetY?: number;\n    tag?: string;\n}\nexport interface LabelFormatterCallback<T = CallbackDataParams> {\n    (params: T): string;\n}\nexport interface LabelOption extends TextCommonOption {\n    show?: boolean;\n    position?: ElementTextConfig['position'];\n    distance?: number;\n    rotate?: number;\n    offset?: number[];\n    minMargin?: number;\n    overflow?: TextStyleProps['overflow'];\n    silent?: boolean;\n    precision?: number | 'auto';\n    valueAnimation?: boolean;\n    rich?: Dictionary<TextCommonOption>;\n}\nexport interface LineLabelOption extends Omit<LabelOption, 'distance' | 'position'> {\n    position?: 'start' | 'middle' | 'end' | 'insideStart' | 'insideStartTop' | 'insideStartBottom' | 'insideMiddle' | 'insideMiddleTop' | 'insideMiddleBottom' | 'insideEnd' | 'insideEndTop' | 'insideEndBottom' | 'insideMiddleBottom';\n    distance?: number | number[];\n}\nexport interface LabelLineOption {\n    show?: boolean;\n    length?: number;\n    length2?: number;\n    smooth?: boolean | number;\n    minTurnAngle?: number;\n    lineStyle?: LineStyleOption;\n}\nexport interface LabelLayoutOptionCallbackParams {\n    dataIndex: number;\n    dataType: SeriesDataType;\n    seriesIndex: number;\n    text: string;\n    align: ZRTextAlign;\n    verticalAlign: ZRTextVerticalAlign;\n    rect: RectLike;\n    labelRect: RectLike;\n    labelLinePoints?: number[][];\n}\nexport interface LabelLayoutOption {\n    moveOverlap?: 'shift-x' | 'shift-y' | 'shuffle-x' | 'shuffle-y';\n    hideOverlap?: boolean;\n    draggable?: boolean;\n    x?: number | string;\n    y?: number | string;\n    dx?: number;\n    dy?: number;\n    rotate?: number;\n    align?: ZRTextAlign;\n    verticalAlign?: ZRTextVerticalAlign;\n    width?: number;\n    height?: number;\n    fontSize?: number;\n    labelLinePoints?: number[][];\n}\nexport declare type LabelLayoutOptionCallback = (params: LabelLayoutOptionCallbackParams) => LabelLayoutOption;\ninterface TooltipFormatterCallback<T> {\n    (params: T, asyncTicket: string): string;\n    (params: T, asyncTicket: string, callback: (cbTicket: string, html: string) => void): string;\n}\ndeclare type TooltipBuiltinPosition = 'inside' | 'top' | 'left' | 'right' | 'bottom';\ndeclare type TooltipBoxLayoutOption = Pick<BoxLayoutOptionMixin, 'top' | 'left' | 'right' | 'bottom'>;\ninterface PositionCallback {\n    (point: [number, number], params: CallbackDataParams | CallbackDataParams[], el: HTMLDivElement | ZRText | null, rect: RectLike | null, size: {\n        contentSize: [number, number];\n        viewSize: [number, number];\n    }): number[] | string[] | TooltipBuiltinPosition | TooltipBoxLayoutOption;\n}\nexport interface CommonTooltipOption<FormatterParams> {\n    show?: boolean;\n    triggerOn?: 'mousemove' | 'click' | 'none' | 'mousemove|click';\n    alwaysShowContent?: boolean;\n    formatter?: string | TooltipFormatterCallback<FormatterParams>;\n    position?: (number | string)[] | TooltipBuiltinPosition | PositionCallback | TooltipBoxLayoutOption;\n    confine?: boolean;\n    align?: HorizontalAlign;\n    verticalAlign?: VerticalAlign;\n    showDelay?: number;\n    hideDelay?: number;\n    transitionDuration?: number;\n    enterable?: boolean;\n    backgroundColor?: ColorString;\n    borderColor?: ColorString;\n    borderRadius?: number;\n    borderWidth?: number;\n    shadowBlur?: number;\n    shadowColor?: string;\n    shadowOffsetX?: number;\n    shadowOffsetY?: number;\n    padding?: number | number[];\n    extraCssText?: string;\n    textStyle?: Pick<LabelOption, 'color' | 'fontStyle' | 'fontWeight' | 'fontFamily' | 'fontSize' | 'lineHeight' | 'width' | 'height' | 'textBorderColor' | 'textBorderWidth' | 'textShadowColor' | 'textShadowBlur' | 'textShadowOffsetX' | 'textShadowOffsetY' | 'align'> & {\n        decoration?: string;\n    };\n}\nexport declare type SeriesTooltipOption = CommonTooltipOption<CallbackDataParams> & {\n    trigger?: 'item' | 'axis' | boolean | 'none';\n};\ndeclare type LabelFormatterParams = {\n    value: ScaleDataValue;\n    axisDimension: string;\n    axisIndex: number;\n    seriesData: CallbackDataParams[];\n};\nexport interface CommonAxisPointerOption {\n    show?: boolean | 'auto';\n    z?: number;\n    zlevel?: number;\n    triggerOn?: 'click' | 'mousemove' | 'none' | 'mousemove|click';\n    type?: 'line' | 'shadow' | 'none';\n    snap?: boolean;\n    triggerTooltip?: boolean;\n    value?: ScaleDataValue;\n    status?: 'show' | 'hide';\n    label?: LabelOption & {\n        precision?: 'auto' | number;\n        margin?: number;\n        formatter?: string | ((params: LabelFormatterParams) => string);\n    };\n    animation?: boolean | 'auto';\n    animationDurationUpdate?: number;\n    animationEasingUpdate?: ZREasing;\n    lineStyle?: LineStyleOption;\n    shadowStyle?: AreaStyleOption;\n    handle?: {\n        show?: boolean;\n        icon?: string;\n        size?: number | number[];\n        margin?: number;\n        color?: ColorString;\n        throttle?: number;\n    } & ShadowOptionMixin;\n    seriesDataIndices?: {\n        seriesIndex: number;\n        dataIndex: number;\n        dataIndexInside: number;\n    }[];\n}\nexport interface ComponentOption {\n    type?: string;\n    id?: string;\n    name?: string;\n    z?: number;\n    zlevel?: number;\n}\nexport declare type BlurScope = 'coordinateSystem' | 'series' | 'global';\nexport declare type InnerFocus = string | ArrayLike<number> | Dictionary<ArrayLike<number>>;\nexport interface StatesOptionMixin<StateOption = unknown, ExtraStateOpts extends {\n    emphasis?: any;\n    select?: any;\n    blur?: any;\n} = unknown> {\n    emphasis?: StateOption & {\n        focus?: 'none' | 'self' | 'series' | (unknown extends ExtraStateOpts['emphasis']['focus'] ? never : ExtraStateOpts['emphasis']['focus']);\n        blurScope?: BlurScope;\n    } & Omit<ExtraStateOpts['emphasis'], 'focus'>;\n    select?: StateOption & ExtraStateOpts['select'];\n    blur?: StateOption & ExtraStateOpts['blur'];\n}\nexport interface SeriesOption<StateOption = any, ExtraStateOpts extends {\n    emphasis?: any;\n    select?: any;\n    blur?: any;\n} = unknown> extends ComponentOption, AnimationOptionMixin, ColorPaletteOptionMixin, StatesOptionMixin<StateOption, ExtraStateOpts> {\n    name?: string;\n    silent?: boolean;\n    blendMode?: string;\n    cursor?: string;\n    data?: unknown;\n    legendHoverLink?: boolean;\n    progressive?: number | false;\n    progressiveThreshold?: number;\n    progressiveChunkMode?: 'mod';\n    coordinateSystem?: string;\n    hoverLayerThreshold?: number;\n    seriesLayoutBy?: 'column' | 'row';\n    labelLine?: LabelLineOption;\n    labelLayout?: LabelLayoutOption | LabelLayoutOptionCallback;\n    stateAnimation?: AnimationOption;\n    selectedMap?: Dictionary<boolean>;\n    selectedMode?: 'single' | 'multiple' | boolean;\n}\nexport interface SeriesOnCartesianOptionMixin {\n    xAxisIndex?: number;\n    yAxisIndex?: number;\n    xAxisId?: string;\n    yAxisId?: string;\n}\nexport interface SeriesOnPolarOptionMixin {\n    radiusAxisIndex?: number;\n    angleAxisIndex?: number;\n    radiusAxisId?: string;\n    angleAxisId?: string;\n}\nexport interface SeriesOnSingleOptionMixin {\n    singleAxisIndex?: number;\n    singleAxisId?: string;\n}\nexport interface SeriesOnGeoOptionMixin {\n    geoIndex?: number;\n    geoId?: string;\n}\nexport interface SeriesOnCalendarOptionMixin {\n    calendarIndex?: number;\n    calendarId?: string;\n}\nexport interface SeriesLargeOptionMixin {\n    large?: boolean;\n    largeThreshold?: number;\n}\nexport interface SeriesStackOptionMixin {\n    stack?: string;\n}\ndeclare type SamplingFunc = (frame: ArrayLike<number>) => number;\nexport interface SeriesSamplingOptionMixin {\n    sampling?: 'none' | 'average' | 'min' | 'max' | 'sum' | SamplingFunc;\n}\nexport interface SeriesEncodeOptionMixin {\n    datasetIndex?: number;\n    datasetId?: string | number;\n    seriesLayoutBy?: SeriesLayoutBy;\n    sourceHeader?: OptionSourceHeader;\n    dimensions?: DimensionDefinitionLoose[];\n    encode?: OptionEncode;\n}\nexport declare type SeriesEncodableModel = SeriesModel<SeriesOption & SeriesEncodeOptionMixin>;\n"
  },
  {
    "path": "echarts/types/src/view/Chart.d.ts",
    "code": "import * as clazzUtil from '../util/clazz';\nimport SeriesModel from '../model/Series';\nimport GlobalModel from '../model/Global';\nimport ExtensionAPI from '../ExtensionAPI';\nimport Element from 'zrender/esm/Element';\nimport { Payload, ViewRootGroup, ECEvent, EventQueryItem, StageHandlerProgressParams } from '../util/types';\nimport { SeriesTask } from '../stream/Scheduler';\ninterface ChartView {\n    incrementalPrepareRender(seriesModel: SeriesModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    incrementalRender(params: StageHandlerProgressParams, seriesModel: SeriesModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    updateTransform(seriesModel: SeriesModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void | {\n        update: true;\n    };\n    containPoint(point: number[], seriesModel: SeriesModel): boolean;\n    filterForExposedEvent(eventType: string, query: EventQueryItem, targetEl: Element, packedEvent: ECEvent): boolean;\n}\ndeclare class ChartView {\n    type: string;\n    readonly group: ViewRootGroup;\n    readonly uid: string;\n    readonly renderTask: SeriesTask;\n    ignoreLabelLineUpdate: boolean;\n    __alive: boolean;\n    __model: SeriesModel;\n    __id: string;\n    static protoInitialize: void;\n    constructor();\n    init(ecModel: GlobalModel, api: ExtensionAPI): void;\n    render(seriesModel: SeriesModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    highlight(seriesModel: SeriesModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    downplay(seriesModel: SeriesModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    remove(ecModel: GlobalModel, api: ExtensionAPI): void;\n    dispose(ecModel: GlobalModel, api: ExtensionAPI): void;\n    updateView(seriesModel: SeriesModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    updateLayout(seriesModel: SeriesModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    updateVisual(seriesModel: SeriesModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    static markUpdateMethod(payload: Payload, methodName: keyof ChartView): void;\n    static registerClass: clazzUtil.ClassManager['registerClass'];\n}\nexport declare type ChartViewConstructor = typeof ChartView & clazzUtil.ExtendableConstructor & clazzUtil.ClassManager;\nexport default ChartView;\n"
  },
  {
    "path": "echarts/types/src/view/Component.d.ts",
    "code": "import * as clazzUtil from '../util/clazz';\nimport ComponentModel from '../model/Component';\nimport GlobalModel from '../model/Global';\nimport ExtensionAPI from '../ExtensionAPI';\nimport { Payload, ViewRootGroup, ECEvent, EventQueryItem } from '../util/types';\nimport Element from 'zrender/esm/Element';\nimport SeriesModel from '../model/Series';\ninterface ComponentView {\n    updateTransform?(seriesModel: ComponentModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void | {\n        update: true;\n    };\n    filterForExposedEvent(eventType: string, query: EventQueryItem, targetEl: Element, packedEvent: ECEvent): boolean;\n}\ndeclare class ComponentView {\n    readonly group: ViewRootGroup;\n    readonly uid: string;\n    __model: ComponentModel;\n    __alive: boolean;\n    __id: string;\n    constructor();\n    init(ecModel: GlobalModel, api: ExtensionAPI): void;\n    render(model: ComponentModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    dispose(ecModel: GlobalModel, api: ExtensionAPI): void;\n    updateView(model: ComponentModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    updateLayout(model: ComponentModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    updateVisual(model: ComponentModel, ecModel: GlobalModel, api: ExtensionAPI, payload: Payload): void;\n    blurSeries(seriesModels: SeriesModel[], ecModel: GlobalModel): void;\n    static registerClass: clazzUtil.ClassManager['registerClass'];\n}\nexport declare type ComponentViewConstructor = typeof ComponentView & clazzUtil.ExtendableConstructor & clazzUtil.ClassManager;\nexport default ComponentView;\n"
  },
  {
    "path": "echarts/types/src/visual/aria.d.ts",
    "code": "export default function (dom: any, ecModel: any): void;\n"
  },
  {
    "path": "echarts/types/src/visual/commonVisualTypes.d.ts",
    "code": "import { DefaultDataVisual } from '../data/List';\nexport interface LineDataVisual extends DefaultDataVisual {\n    fromSymbol: string;\n    toSymbol: string;\n    fromSymbolSize: number;\n    toSymbolSize: number;\n}\n"
  },
  {
    "path": "echarts/types/src/visual/helper.d.ts",
    "code": "import List from '../data/List';\nexport declare function getItemVisualFromData(data: List, dataIndex: number, key: string): string | number | number[] | import(\"zrender/esm/graphic/Pattern\").PatternObject | import(\"zrender/esm/graphic/LinearGradient\").LinearGradientObject | import(\"zrender/esm/graphic/RadialGradient\").RadialGradientObject;\nexport declare function getVisualFromData(data: List, key: string): string | number | number[] | import(\"zrender/esm/graphic/Pattern\").PatternObject | import(\"zrender/esm/graphic/LinearGradient\").LinearGradientObject | import(\"zrender/esm/graphic/RadialGradient\").RadialGradientObject;\nexport declare function setItemVisualFromData(data: List, dataIndex: number, key: string, value: any): void;\n"
  },
  {
    "path": "echarts/types/src/visual/LegendVisualProvider.d.ts",
    "code": "import List from '../data/List';\ndeclare class LegendVisualProvider {\n    private _getDataWithEncodedVisual;\n    private _getRawData;\n    constructor(getDataWithEncodedVisual: () => List, getRawData: () => List);\n    getAllNames(): string[];\n    containName(name: string): boolean;\n    indexOfName(name: string): number;\n    getItemVisual(dataIndex: number, key: string): any;\n}\nexport default LegendVisualProvider;\n"
  },
  {
    "path": "echarts/types/src/visual/style.d.ts",
    "code": "import { StageHandler } from '../util/types';\ndeclare const seriesStyleTask: StageHandler;\ndeclare const dataStyleTask: StageHandler;\ndeclare const dataColorPaletteTask: StageHandler;\nexport { seriesStyleTask, dataStyleTask, dataColorPaletteTask };\n"
  },
  {
    "path": "echarts/types/src/visual/symbol.d.ts",
    "code": "import { StageHandler } from '../util/types';\ndeclare const seriesSymbolTask: StageHandler;\ndeclare const dataSymbolTask: StageHandler;\nexport { seriesSymbolTask, dataSymbolTask };\n"
  },
  {
    "path": "echarts/types/src/visual/visualDefault.d.ts",
    "code": "declare const visualDefault: {\n    get: (visualType: string, key: \"active\" | \"inactive\", isCategory?: boolean) => string | number | string[] | number[];\n};\nexport default visualDefault;\n"
  },
  {
    "path": "echarts/types/src/visual/VisualMapping.d.ts",
    "code": "import * as zrUtil from 'zrender/esm/core/util';\nimport { AllPropTypes, Dictionary } from 'zrender/esm/core/types';\nimport { ColorString, BuiltinVisualProperty, VisualOptionPiecewise, VisualOptionCategory, VisualOptionLinear, VisualOptionUnit, ParsedValue } from '../util/types';\ndeclare type RawValue = ParsedValue;\ndeclare type VisualValue = AllPropTypes<VisualOptionUnit>;\ndeclare type NormalizedValue = number;\ndeclare type MappingMethod = 'linear' | 'piecewise' | 'category' | 'fixed';\ninterface Normalizer {\n    (this: VisualMapping, value?: RawValue): NormalizedValue;\n}\ninterface ColorMapper {\n    (this: VisualMapping, value: RawValue | NormalizedValue, isNormalized?: boolean, out?: number[]): ColorString | number[];\n}\ninterface DoMap {\n    (this: VisualMapping, normalzied?: NormalizedValue, value?: RawValue): VisualValue;\n}\ninterface VisualValueGetter {\n    (key: string): VisualValue;\n}\ninterface VisualValueSetter {\n    (key: string, value: VisualValue): void;\n}\ninterface VisualHandler {\n    applyVisual(this: VisualMapping, value: RawValue, getter: VisualValueGetter, setter: VisualValueSetter): void;\n    _normalizedToVisual: {\n        linear(this: VisualMapping, normalized: NormalizedValue): VisualValue;\n        category(this: VisualMapping, normalized: NormalizedValue): VisualValue;\n        piecewise(this: VisualMapping, normalzied: NormalizedValue, value: RawValue): VisualValue;\n        fixed(this: VisualMapping): VisualValue;\n    };\n    getColorMapper?: (this: VisualMapping) => ColorMapper;\n}\ninterface VisualMappingPiece {\n    index?: number;\n    value?: number | string;\n    interval?: [number, number];\n    close?: [0 | 1, 0 | 1];\n    text?: string;\n    visual?: VisualOptionPiecewise;\n}\nexport interface VisualMappingOption {\n    type?: BuiltinVisualProperty;\n    mappingMethod?: MappingMethod;\n    dataExtent?: [number, number];\n    pieceList?: VisualMappingPiece[];\n    categories?: (string | number)[];\n    loop?: boolean;\n    visual?: VisualValue[] | Dictionary<VisualValue> | VisualValue;\n}\ninterface VisualMappingInnerPiece extends VisualMappingPiece {\n    originIndex: number;\n}\ninterface VisualMappingInnerOption extends VisualMappingOption {\n    hasSpecialVisual: boolean;\n    pieceList: VisualMappingInnerPiece[];\n    categoryMap: Dictionary<number>;\n    parsedVisual: number[][];\n    visual?: VisualValue[] | Dictionary<VisualValue>;\n}\ndeclare class VisualMapping<VisualOption extends VisualOptionPiecewise | VisualOptionCategory | VisualOptionUnit | VisualOptionLinear = {}> {\n    option: VisualMappingInnerOption;\n    type: BuiltinVisualProperty;\n    mappingMethod: MappingMethod;\n    applyVisual: VisualHandler['applyVisual'];\n    getColorMapper: VisualHandler['getColorMapper'];\n    _normalizeData: Normalizer;\n    _normalizedToVisual: DoMap;\n    constructor(option: VisualMappingOption);\n    mapValueToVisual(value: RawValue): VisualValue;\n    getNormalizer(): zrUtil.Bind1<Normalizer, this>;\n    static visualHandlers: {\n        [key in BuiltinVisualProperty]: VisualHandler;\n    };\n    static listVisualTypes(): (\"symbol\" | \"opacity\" | \"symbolSize\" | \"liftZ\" | \"color\" | \"colorAlpha\" | \"colorLightness\" | \"colorSaturation\" | \"colorHue\")[];\n    static isValidType(visualType: string): boolean;\n    static eachVisual<Ctx, T>(visual: T | T[] | Dictionary<T>, callback: (visual: T, key?: string | number) => void, context?: Ctx): void;\n    static mapVisual<Ctx, T>(visual: T, callback: (visual: T, key?: string | number) => T, context?: Ctx): T;\n    static mapVisual<Ctx, T>(visual: T[], callback: (visual: T, key?: string | number) => T[], context?: Ctx): T[];\n    static mapVisual<Ctx, T>(visual: Dictionary<T>, callback: (visual: T, key?: string | number) => Dictionary<T>, context?: Ctx): Dictionary<T>;\n    static retrieveVisuals(obj: Dictionary<any>): VisualOptionPiecewise;\n    static prepareVisualTypes(visualTypes: {\n        [key in BuiltinVisualProperty]?: any;\n    } | BuiltinVisualProperty[]): (\"symbol\" | \"opacity\" | \"symbolSize\" | \"liftZ\" | \"color\" | \"colorAlpha\" | \"colorLightness\" | \"colorSaturation\" | \"colorHue\")[];\n    static dependsOn(visualType1: BuiltinVisualProperty, visualType2: BuiltinVisualProperty): boolean;\n    static findPieceIndex(value: number, pieceList: VisualMappingPiece[], findClosestWhenOutside?: boolean): number;\n}\nexport default VisualMapping;\n"
  },
  {
    "path": "echarts/types/src/visual/visualSolution.d.ts",
    "code": "import VisualMapping, { VisualMappingOption } from './VisualMapping';\nimport { BuiltinVisualProperty, ParsedValue, DimensionLoose, StageHandlerProgressExecutor } from '../util/types';\nimport List from '../data/List';\ndeclare type VisualMappingCollection<VisualState extends string> = {\n    [key in VisualState]?: {\n        [key in BuiltinVisualProperty]?: VisualMapping;\n    } & {\n        __alphaForOpacity?: VisualMapping;\n    };\n};\ndeclare type VisualOption = {\n    [key in BuiltinVisualProperty]?: any;\n};\nexport declare function createVisualMappings<VisualState extends string>(option: Partial<Record<VisualState, VisualOption>>, stateList: readonly VisualState[], supplementVisualOption: (mappingOption: VisualMappingOption, state: string) => void): VisualMappingCollection<VisualState>;\nexport declare function replaceVisualOption<T extends string>(thisOption: Partial<Record<T, any>>, newOption: Partial<Record<T, any>>, keys: readonly T[]): void;\nexport declare function applyVisual<VisualState extends string, Scope>(stateList: readonly VisualState[], visualMappings: VisualMappingCollection<VisualState>, data: List, getValueState: (this: Scope, valueOrIndex: ParsedValue | number) => VisualState, scope?: Scope, dimension?: DimensionLoose): void;\nexport declare function incrementalApplyVisual<VisualState extends string>(stateList: readonly VisualState[], visualMappings: VisualMappingCollection<VisualState>, getValueState: (valueOrIndex: ParsedValue | number) => VisualState, dim?: DimensionLoose): StageHandlerProgressExecutor;\nexport {};\n"
  },
  {
    "path": "zrender/esm/animation/Animation.d.ts",
    "code": "import Eventful from '../core/Eventful';\nimport Animator from './Animator';\nimport Clip from './Clip';\ninterface Stage {\n    update?: () => void;\n}\ndeclare type OnframeCallback = (deltaTime: number) => void;\ninterface AnimationOption {\n    stage?: Stage;\n    onframe?: OnframeCallback;\n}\nexport default class Animation extends Eventful {\n    stage: Stage;\n    onframe: OnframeCallback;\n    private _clipsHead;\n    private _clipsTail;\n    private _running;\n    private _time;\n    private _pausedTime;\n    private _pauseStart;\n    private _paused;\n    constructor(opts: AnimationOption);\n    addClip(clip: Clip): void;\n    addAnimator(animator: Animator<any>): void;\n    removeClip(clip: Clip): void;\n    removeAnimator(animator: Animator<any>): void;\n    update(): void;\n    _startLoop(): void;\n    start(): void;\n    stop(): void;\n    pause(): void;\n    resume(): void;\n    clear(): void;\n    isFinished(): boolean;\n    animate<T>(target: T, options: {\n        loop?: boolean;\n    }): Animator<T>;\n}\nexport {};\n"
  },
  {
    "path": "zrender/esm/animation/Animator.d.ts",
    "code": "import Clip from './Clip';\nimport { ArrayLike, Dictionary } from '../core/types';\nimport { AnimationEasing } from './easing';\nimport Animation from './Animation';\ndeclare type NumberArray = ArrayLike<number>;\ndeclare type InterpolatableType = string | number | NumberArray | NumberArray[];\nexport declare function interpolateNumber(p0: number, p1: number, percent: number): number;\nexport declare function step(p0: any, p1: any, percent: number): any;\nexport declare function interpolate1DArray(out: NumberArray, p0: NumberArray, p1: NumberArray, percent: number): void;\nexport declare function interpolate2DArray(out: NumberArray[], p0: NumberArray[], p1: NumberArray[], percent: number): void;\nexport declare function cloneValue(value: InterpolatableType): number | any[];\ndeclare type Keyframe = {\n    time: number;\n    value: unknown;\n    percent: number;\n    additiveValue?: unknown;\n};\ndeclare class Track {\n    keyframes: Keyframe[];\n    maxTime: number;\n    propName: string;\n    useSpline: boolean;\n    arrDim: number;\n    isValueColor: boolean;\n    interpolable: boolean;\n    private _finished;\n    private _needsSort;\n    private _isAllValueEqual;\n    private _additiveTrack;\n    private _additiveValue;\n    private _lastFrame;\n    private _lastFramePercent;\n    constructor(propName: string);\n    isFinished(): boolean;\n    setFinished(): void;\n    needsAnimate(): boolean;\n    getAdditiveTrack(): Track;\n    addKeyframe(time: number, value: unknown): {\n        time: number;\n        value: unknown;\n        percent: number;\n    };\n    prepare(additiveTrack?: Track): void;\n    step(target: any, percent: number): void;\n    private _addToTarget;\n}\ndeclare type DoneCallback = () => void;\nexport declare type OnframeCallback<T> = (target: T, percent: number) => void;\nexport declare type AnimationPropGetter<T> = (target: T, key: string) => InterpolatableType;\nexport declare type AnimationPropSetter<T> = (target: T, key: string, value: InterpolatableType) => void;\nexport default class Animator<T> {\n    animation?: Animation;\n    targetName?: string;\n    scope?: string;\n    __fromStateTransition?: string;\n    private _tracks;\n    private _trackKeys;\n    private _target;\n    private _loop;\n    private _delay;\n    private _maxTime;\n    private _paused;\n    private _started;\n    private _additiveAnimator;\n    private _doneList;\n    private _onframeList;\n    private _clip;\n    constructor(target: T, loop: boolean, additiveTo?: Animator<any>);\n    getTarget(): T;\n    changeTarget(target: T): void;\n    when(time: number, props: Dictionary<any>): this;\n    whenWithKeys(time: number, props: Dictionary<any>, propNames: string[]): this;\n    during(callback: OnframeCallback<T>): this;\n    pause(): void;\n    resume(): void;\n    isPaused(): boolean;\n    _doneCallback(): void;\n    start(easing?: AnimationEasing, forceAnimate?: boolean): this;\n    stop(forwardToLast?: boolean): void;\n    delay(time: number): this;\n    done(cb: DoneCallback): this;\n    getClip(): Clip;\n    getTrack(propName: string): Track;\n    stopTracks(propNames: string[], forwardToLast?: boolean): boolean;\n    saveFinalToTarget(target: T, trackKeys?: readonly string[]): void;\n    __changeFinalValue(finalProps: Dictionary<any>, trackKeys?: readonly string[]): void;\n}\nexport {};\n"
  },
  {
    "path": "zrender/esm/animation/Clip.d.ts",
    "code": "import { AnimationEasing } from './easing';\nimport type Animation from './Animation';\ndeclare type OnframeCallback = (percent: number) => void;\ndeclare type ondestroyCallback = () => void;\ndeclare type onrestartCallback = () => void;\nexport declare type DeferredEventTypes = 'destroy' | 'restart';\nexport interface ClipProps {\n    life?: number;\n    delay?: number;\n    loop?: boolean;\n    gap?: number;\n    easing?: AnimationEasing;\n    onframe?: OnframeCallback;\n    ondestroy?: ondestroyCallback;\n    onrestart?: onrestartCallback;\n}\nexport default class Clip {\n    private _life;\n    private _delay;\n    private _initialized;\n    private _startTime;\n    private _pausedTime;\n    private _paused;\n    animation: Animation;\n    loop: boolean;\n    gap: number;\n    easing: AnimationEasing;\n    next: Clip;\n    prev: Clip;\n    onframe: OnframeCallback;\n    ondestroy: ondestroyCallback;\n    onrestart: onrestartCallback;\n    constructor(opts: ClipProps);\n    step(globalTime: number, deltaTime: number): boolean;\n    private _restart;\n    pause(): void;\n    resume(): void;\n}\nexport {};\n"
  },
  {
    "path": "zrender/esm/animation/easing.d.ts",
    "code": "declare type easingFunc = (percent: number) => number;\nexport declare type AnimationEasing = keyof typeof easing | easingFunc | 'spline';\ndeclare const easing: {\n    linear(k: number): number;\n    quadraticIn(k: number): number;\n    quadraticOut(k: number): number;\n    quadraticInOut(k: number): number;\n    cubicIn(k: number): number;\n    cubicOut(k: number): number;\n    cubicInOut(k: number): number;\n    quarticIn(k: number): number;\n    quarticOut(k: number): number;\n    quarticInOut(k: number): number;\n    quinticIn(k: number): number;\n    quinticOut(k: number): number;\n    quinticInOut(k: number): number;\n    sinusoidalIn(k: number): number;\n    sinusoidalOut(k: number): number;\n    sinusoidalInOut(k: number): number;\n    exponentialIn(k: number): number;\n    exponentialOut(k: number): number;\n    exponentialInOut(k: number): number;\n    circularIn(k: number): number;\n    circularOut(k: number): number;\n    circularInOut(k: number): number;\n    elasticIn(k: number): number;\n    elasticOut(k: number): number;\n    elasticInOut(k: number): number;\n    backIn(k: number): number;\n    backOut(k: number): number;\n    backInOut(k: number): number;\n    bounceIn(k: number): number;\n    bounceOut(k: number): number;\n    bounceInOut(k: number): number;\n};\nexport default easing;\n"
  },
  {
    "path": "zrender/esm/animation/requestAnimationFrame.d.ts",
    "code": "declare type RequestAnimationFrameType = typeof window.requestAnimationFrame;\ndeclare let requestAnimationFrame: RequestAnimationFrameType;\nexport default requestAnimationFrame;\n"
  },
  {
    "path": "zrender/esm/canvas/canvas.d.ts",
    "code": "import './graphic';\n"
  },
  {
    "path": "zrender/esm/canvas/graphic.d.ts",
    "code": "import Displayable from '../graphic/Displayable';\nimport { PatternObject } from '../graphic/Pattern';\nimport Path from '../graphic/Path';\nexport declare function createCanvasPattern(this: void, ctx: CanvasRenderingContext2D, pattern: PatternObject, el: {\n    dirty: () => void;\n}): CanvasPattern;\nexport declare type BrushScope = {\n    inHover: boolean;\n    viewWidth: number;\n    viewHeight: number;\n    prevElClipPaths?: Path[];\n    prevEl?: Displayable;\n    allClipped?: boolean;\n    batchFill?: string;\n    batchStroke?: string;\n    lastDrawType?: number;\n};\nexport declare function brush(ctx: CanvasRenderingContext2D, el: Displayable, scope: BrushScope, isLast: boolean): void;\n"
  },
  {
    "path": "zrender/esm/canvas/helper.d.ts",
    "code": "import { LinearGradientObject } from '../graphic/LinearGradient';\nimport { RadialGradientObject } from '../graphic/RadialGradient';\nimport { GradientObject } from '../graphic/Gradient';\nimport { RectLike } from '../core/BoundingRect';\nexport declare function createLinearGradient(this: void, ctx: CanvasRenderingContext2D, obj: LinearGradientObject, rect: RectLike): CanvasGradient;\nexport declare function createRadialGradient(this: void, ctx: CanvasRenderingContext2D, obj: RadialGradientObject, rect: RectLike): CanvasGradient;\nexport declare function getCanvasGradient(this: void, ctx: CanvasRenderingContext2D, obj: GradientObject, rect: RectLike): CanvasGradient;\n"
  },
  {
    "path": "zrender/esm/canvas/Layer.d.ts",
    "code": "import { PatternObject } from '../graphic/Pattern';\nimport CanvasPainter from './Painter';\nimport { GradientObject } from '../graphic/Gradient';\nimport Eventful from '../core/Eventful';\nimport { ElementEventCallback } from '../Element';\nexport interface LayerConfig {\n    clearColor?: string | GradientObject | PatternObject;\n    motionBlur?: boolean;\n    lastFrameAlpha?: number;\n}\nexport default class Layer extends Eventful {\n    id: string;\n    dom: HTMLCanvasElement;\n    domBack: HTMLCanvasElement;\n    ctx: CanvasRenderingContext2D;\n    ctxBack: CanvasRenderingContext2D;\n    painter: CanvasPainter;\n    clearColor: string | GradientObject | PatternObject;\n    motionBlur: boolean;\n    lastFrameAlpha: number;\n    dpr: number;\n    virtual: boolean;\n    config: {};\n    incremental: boolean;\n    zlevel: number;\n    __painter: CanvasPainter;\n    __dirty: boolean;\n    __used: boolean;\n    __drawIndex: number;\n    __startIndex: number;\n    __endIndex: number;\n    __builtin__: boolean;\n    constructor(id: string | HTMLCanvasElement, painter: CanvasPainter, dpr?: number);\n    getElementCount(): number;\n    initContext(): void;\n    createBackBuffer(): void;\n    resize(width: number, height: number): void;\n    clear(clearAll?: boolean, clearColor?: string | GradientObject | PatternObject): void;\n    refresh: (clearColor?: string | GradientObject | PatternObject) => void;\n    renderToCanvas: (ctx: CanvasRenderingContext2D) => void;\n    onclick: ElementEventCallback<unknown, this>;\n    ondblclick: ElementEventCallback<unknown, this>;\n    onmouseover: ElementEventCallback<unknown, this>;\n    onmouseout: ElementEventCallback<unknown, this>;\n    onmousemove: ElementEventCallback<unknown, this>;\n    onmousewheel: ElementEventCallback<unknown, this>;\n    onmousedown: ElementEventCallback<unknown, this>;\n    onmouseup: ElementEventCallback<unknown, this>;\n    oncontextmenu: ElementEventCallback<unknown, this>;\n    ondrag: ElementEventCallback<unknown, this>;\n    ondragstart: ElementEventCallback<unknown, this>;\n    ondragend: ElementEventCallback<unknown, this>;\n    ondragenter: ElementEventCallback<unknown, this>;\n    ondragleave: ElementEventCallback<unknown, this>;\n    ondragover: ElementEventCallback<unknown, this>;\n    ondrop: ElementEventCallback<unknown, this>;\n}\n"
  },
  {
    "path": "zrender/esm/canvas/Painter.d.ts",
    "code": "import Layer, { LayerConfig } from './Layer';\nimport ZRImage from '../graphic/Image';\nimport { Path } from '../export';\nimport Displayable from '../graphic/Displayable';\nimport { GradientObject } from '../graphic/Gradient';\nimport { PatternObject } from '../graphic/Pattern';\nimport Storage from '../Storage';\nimport { PainterBase } from '../PainterBase';\ninterface CanvasPainterOption {\n    devicePixelRatio?: number;\n    width?: number | string;\n    height?: number | string;\n}\nexport default class CanvasPainter implements PainterBase {\n    type: string;\n    root: HTMLElement;\n    dpr: number;\n    storage: Storage;\n    private _singleCanvas;\n    private _opts;\n    private _zlevelList;\n    private _layers;\n    private _layerConfig;\n    private _needsManuallyCompositing;\n    private _width;\n    private _height;\n    private _domRoot;\n    private _hoverlayer;\n    private _redrawId;\n    private _backgroundColor;\n    constructor(root: HTMLElement, storage: Storage, opts: CanvasPainterOption, id: number);\n    getType(): string;\n    isSingleCanvas(): boolean;\n    getViewportRoot(): HTMLElement;\n    getViewportRootOffset(): {\n        offsetLeft: number;\n        offsetTop: number;\n    };\n    refresh(paintAll?: boolean): this;\n    refreshHover(): void;\n    private _paintHoverList;\n    getHoverLayer(): Layer;\n    private _paintList;\n    private _compositeManually;\n    private _doPaintList;\n    getLayer(zlevel: number, virtual?: boolean): Layer;\n    insertLayer(zlevel: number, layer: Layer): void;\n    eachLayer<T>(cb: (this: T, layer: Layer, z: number) => void, context?: T): void;\n    eachBuiltinLayer<T>(cb: (this: T, layer: Layer, z: number) => void, context?: T): void;\n    eachOtherLayer<T>(cb: (this: T, layer: Layer, z: number) => void, context?: T): void;\n    getLayers(): {\n        [key: number]: Layer;\n    };\n    _updateLayerStatus(list: Displayable[]): void;\n    clear(): this;\n    _clearLayer(layer: Layer): void;\n    setBackgroundColor(backgroundColor: string | GradientObject | PatternObject): void;\n    configLayer(zlevel: number, config: LayerConfig): void;\n    delLayer(zlevel: number): void;\n    resize(width?: number | string, height?: number | string): this;\n    clearLayer(zlevel: number): void;\n    dispose(): void;\n    getRenderedCanvas(opts?: {\n        backgroundColor?: string | GradientObject | PatternObject;\n        pixelRatio?: number;\n    }): HTMLCanvasElement;\n    getWidth(): number;\n    getHeight(): number;\n    _getSize(whIdx: number): number;\n    pathToImage(path: Path, dpr?: number): ZRImage;\n}\nexport {};\n"
  },
  {
    "path": "zrender/esm/config.d.ts",
    "code": "export declare const debugMode = 0;\nexport declare const devicePixelRatio: number;\nexport declare const DARK_MODE_THRESHOLD = 0.4;\nexport declare const DARK_LABEL_COLOR = \"#333\";\nexport declare const LIGHT_LABEL_COLOR = \"#ccc\";\nexport declare const LIGHTER_LABEL_COLOR = \"#eee\";\n"
  },
  {
    "path": "zrender/esm/contain/arc.d.ts",
    "code": "export declare function containStroke(cx: number, cy: number, r: number, startAngle: number, endAngle: number, anticlockwise: boolean, lineWidth: number, x: number, y: number): boolean;\n"
  },
  {
    "path": "zrender/esm/contain/cubic.d.ts",
    "code": "export declare function containStroke(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, lineWidth: number, x: number, y: number): boolean;\n"
  },
  {
    "path": "zrender/esm/contain/line.d.ts",
    "code": "export declare function containStroke(x0: number, y0: number, x1: number, y1: number, lineWidth: number, x: number, y: number): boolean;\n"
  },
  {
    "path": "zrender/esm/contain/path.d.ts",
    "code": "declare type PathData = Float32Array | number[];\nexport declare function contain(pathData: PathData, x: number, y: number): boolean;\nexport declare function containStroke(pathData: PathData, lineWidth: number, x: number, y: number): boolean;\nexport {};\n"
  },
  {
    "path": "zrender/esm/contain/polygon.d.ts",
    "code": "import { VectorArray } from '../core/vector';\nexport declare function contain(points: VectorArray[], x: number, y: number): boolean;\n"
  },
  {
    "path": "zrender/esm/contain/quadratic.d.ts",
    "code": "export declare function containStroke(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, lineWidth: number, x: number, y: number): boolean;\n"
  },
  {
    "path": "zrender/esm/contain/text.d.ts",
    "code": "import BoundingRect, { RectLike } from '../core/BoundingRect';\nimport { PropType, TextAlign, TextVerticalAlign, BuiltinTextPosition } from '../core/types';\nexport declare const DEFAULT_FONT = \"12px sans-serif\";\ndeclare let methods: {\n    measureText: (text: string, font?: string) => {\n        width: number;\n    };\n};\nexport declare function $override(name: keyof typeof methods, fn: PropType<typeof methods, keyof typeof methods>): void;\nexport declare function getWidth(text: string, font: string): number;\nexport declare function innerGetBoundingRect(text: string, font: string, textAlign?: TextAlign, textBaseline?: TextVerticalAlign): BoundingRect;\nexport declare function getBoundingRect(text: string, font: string, textAlign?: TextAlign, textBaseline?: TextVerticalAlign): BoundingRect;\nexport declare function adjustTextX(x: number, width: number, textAlign: TextAlign): number;\nexport declare function adjustTextY(y: number, height: number, verticalAlign: TextVerticalAlign): number;\nexport declare function getLineHeight(font?: string): number;\nexport declare function measureText(text: string, font?: string): {\n    width: number;\n};\nexport declare function parsePercent(value: number | string, maxValue: number): number;\nexport interface TextPositionCalculationResult {\n    x: number;\n    y: number;\n    align: TextAlign;\n    verticalAlign: TextVerticalAlign;\n}\nexport declare function calculateTextPosition(out: TextPositionCalculationResult, opts: {\n    position?: BuiltinTextPosition | (number | string)[];\n    distance?: number;\n    global?: boolean;\n}, rect: RectLike): TextPositionCalculationResult;\nexport {};\n"
  },
  {
    "path": "zrender/esm/contain/util.d.ts",
    "code": "export declare function normalizeRadian(angle: number): number;\n"
  },
  {
    "path": "zrender/esm/contain/windingLine.d.ts",
    "code": "export default function windingLine(x0: number, y0: number, x1: number, y1: number, x: number, y: number): number;\n"
  },
  {
    "path": "zrender/esm/core/arrayDiff.d.ts",
    "code": "declare type EqualFunc<T> = (a: T, b: T) => boolean;\ndeclare type DiffComponent = {\n    count: number;\n    added: boolean;\n    removed: boolean;\n    indices: number[];\n};\nexport default function <T>(oldArr: T[], newArr: T[], equal?: EqualFunc<T>): DiffComponent[];\nexport {};\n"
  },
  {
    "path": "zrender/esm/core/bbox.d.ts",
    "code": "import * as vec2 from './vector';\nexport declare function fromPoints(points: ArrayLike<number>[], min: vec2.VectorArray, max: vec2.VectorArray): void;\nexport declare function fromLine(x0: number, y0: number, x1: number, y1: number, min: vec2.VectorArray, max: vec2.VectorArray): void;\nexport declare function fromCubic(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, min: vec2.VectorArray, max: vec2.VectorArray): void;\nexport declare function fromQuadratic(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, min: vec2.VectorArray, max: vec2.VectorArray): void;\nexport declare function fromArc(x: number, y: number, rx: number, ry: number, startAngle: number, endAngle: number, anticlockwise: boolean, min: vec2.VectorArray, max: vec2.VectorArray): void;\n"
  },
  {
    "path": "zrender/esm/core/BoundingRect.d.ts",
    "code": "import * as matrix from './matrix';\nimport { PointLike } from './Point';\ndeclare class BoundingRect {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    constructor(x: number, y: number, width: number, height: number);\n    union(other: BoundingRect): void;\n    applyTransform(m: matrix.MatrixArray): void;\n    calculateTransform(b: RectLike): matrix.MatrixArray;\n    intersect(b: RectLike, mtv?: PointLike): boolean;\n    contain(x: number, y: number): boolean;\n    clone(): BoundingRect;\n    copy(other: RectLike): void;\n    plain(): RectLike;\n    static create(rect: RectLike): BoundingRect;\n    static copy(target: RectLike, source: RectLike): void;\n    static applyTransform(target: RectLike, source: RectLike, m: matrix.MatrixArray): void;\n}\nexport declare type RectLike = {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n};\nexport default BoundingRect;\n"
  },
  {
    "path": "zrender/esm/core/curve.d.ts",
    "code": "import { VectorArray } from './vector';\nexport declare function cubicAt(p0: number, p1: number, p2: number, p3: number, t: number): number;\nexport declare function cubicDerivativeAt(p0: number, p1: number, p2: number, p3: number, t: number): number;\nexport declare function cubicRootAt(p0: number, p1: number, p2: number, p3: number, val: number, roots: number[]): number;\nexport declare function cubicExtrema(p0: number, p1: number, p2: number, p3: number, extrema: number[]): number;\nexport declare function cubicSubdivide(p0: number, p1: number, p2: number, p3: number, t: number, out: number[]): void;\nexport declare function cubicProjectPoint(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x: number, y: number, out: VectorArray): number;\nexport declare function cubicLength(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, iteration: number): number;\nexport declare function quadraticAt(p0: number, p1: number, p2: number, t: number): number;\nexport declare function quadraticDerivativeAt(p0: number, p1: number, p2: number, t: number): number;\nexport declare function quadraticRootAt(p0: number, p1: number, p2: number, val: number, roots: number[]): number;\nexport declare function quadraticExtremum(p0: number, p1: number, p2: number): number;\nexport declare function quadraticSubdivide(p0: number, p1: number, p2: number, t: number, out: number[]): void;\nexport declare function quadraticProjectPoint(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x: number, y: number, out: VectorArray): number;\nexport declare function quadraticLength(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, iteration: number): number;\n"
  },
  {
    "path": "zrender/esm/core/dom.d.ts",
    "code": "export declare function transformLocalCoord(out: number[], elFrom: HTMLElement, elTarget: HTMLElement, inX: number, inY: number): boolean;\nexport declare function transformCoordWithViewport(out: number[], el: HTMLElement, inX: number, inY: number, inverse?: boolean): boolean;\nexport declare function isCanvasEl(el: HTMLElement): el is HTMLCanvasElement;\n"
  },
  {
    "path": "zrender/esm/core/env.d.ts",
    "code": "declare class Browser {\n    firefox: boolean;\n    ie: boolean;\n    edge: boolean;\n    weChat: boolean;\n    version: string | number;\n}\ndeclare class Env {\n    browser: Browser;\n    node: boolean;\n    wxa: boolean;\n    worker: boolean;\n    canvasSupported: boolean;\n    svgSupported: boolean;\n    touchEventsSupported: boolean;\n    pointerEventsSupported: boolean;\n    domSupported: boolean;\n}\ndeclare const env: Env;\nexport default env;\n"
  },
  {
    "path": "zrender/esm/core/event.d.ts",
    "code": "import Eventful from './Eventful';\nimport { ZRRawEvent } from './types';\ndeclare type FirefoxMouseEvent = {\n    layerX: number;\n    layerY: number;\n};\nexport declare function clientToLocal(el: HTMLElement, e: ZRRawEvent | FirefoxMouseEvent | Touch, out: {\n    zrX?: number;\n    zrY?: number;\n}, calculate?: boolean): {\n    zrX?: number;\n    zrY?: number;\n};\nexport declare function getNativeEvent(e: ZRRawEvent): ZRRawEvent;\nexport declare function normalizeEvent(el: HTMLElement, e: ZRRawEvent, calculate?: boolean): ZRRawEvent;\ndeclare type AddEventListenerParams = Parameters<typeof HTMLElement.prototype.addEventListener>;\ndeclare type RemoveEventListenerParams = Parameters<typeof HTMLElement.prototype.removeEventListener>;\nexport declare function addEventListener(el: HTMLElement | HTMLDocument, name: AddEventListenerParams[0], handler: AddEventListenerParams[1], opt?: AddEventListenerParams[2]): void;\nexport declare function removeEventListener(el: HTMLElement | HTMLDocument, name: RemoveEventListenerParams[0], handler: RemoveEventListenerParams[1], opt: RemoveEventListenerParams[2]): void;\nexport declare const stop: (e: MouseEvent | PointerEvent | TouchEvent) => void;\nexport declare function isMiddleOrRightButtonOnMouseUpDown(e: {\n    which: number;\n}): boolean;\nexport declare function notLeftMouse(e: MouseEvent): boolean;\nexport { Eventful as Dispatcher };\n"
  },
  {
    "path": "zrender/esm/core/Eventful.d.ts",
    "code": "export declare type EventCallback<Ctx, Impl, EvtParam = unknown> = (this: CbThis<Ctx, Impl>, eventParam?: EvtParam, ...args: unknown[]) => boolean | void;\nexport declare type EventQuery = string | Object;\ndeclare type CbThis<Ctx, Impl> = unknown extends Ctx ? Impl : Ctx;\ndeclare type DefaultEventDefinition = {\n    [eventName: string]: unknown;\n};\nexport interface EventProcessor<EvtDef = DefaultEventDefinition> {\n    normalizeQuery?: (query: EventQuery) => EventQuery;\n    filter?: (eventType: keyof EvtDef, query: EventQuery) => boolean;\n    afterTrigger?: (eventType: keyof EvtDef) => void;\n}\nexport default class Eventful<EvtDef = DefaultEventDefinition> {\n    private _$handlers;\n    protected _$eventProcessor: EventProcessor<EvtDef>;\n    constructor(eventProcessors?: EventProcessor<EvtDef>);\n    on<Ctx, EvtNm extends keyof EvtDef>(event: EvtNm, handler: EventCallback<Ctx, this, EvtDef[EvtNm]>, context?: Ctx): this;\n    on<Ctx, EvtNm extends keyof EvtDef>(event: EvtNm, query: EventQuery, handler: EventCallback<Ctx, this, EvtDef[EvtNm]>, context?: Ctx): this;\n    isSilent(eventName: keyof EvtDef): boolean;\n    off(eventType?: keyof EvtDef, handler?: Function): this;\n    trigger(eventType: keyof EvtDef, eventParam?: EvtDef[keyof EvtDef], ...args: any[]): this;\n    triggerWithContext(type: keyof EvtDef): this;\n}\nexport {};\n"
  },
  {
    "path": "zrender/esm/core/fourPointsTransform.d.ts",
    "code": "export declare function buildTransformer(src: number[], dest: number[]): (out: number[], srcPointX: number, srcPointY: number) => void;\n"
  },
  {
    "path": "zrender/esm/core/GestureMgr.d.ts",
    "code": "import { ZRRawTouchEvent } from './types';\nimport Displayable from '../graphic/Displayable';\nexport declare class GestureMgr {\n    private _track;\n    constructor();\n    recognize(event: ZRRawTouchEvent, target: Displayable, root: HTMLElement): {\n        type: string;\n        target: Displayable<import(\"../graphic/Displayable\").DisplayableProps>;\n        event: ZRRawTouchEvent;\n    };\n    clear(): this;\n    _doTrack(event: ZRRawTouchEvent, target: Displayable, root: HTMLElement): void;\n    _recognize(event: ZRRawTouchEvent): {\n        type: string;\n        target: Displayable<import(\"../graphic/Displayable\").DisplayableProps>;\n        event: ZRRawTouchEvent;\n    };\n}\n"
  },
  {
    "path": "zrender/esm/core/LRU.d.ts",
    "code": "export declare class Entry<T> {\n    value: T;\n    key: string | number;\n    next: Entry<T>;\n    prev: Entry<T>;\n    constructor(val: T);\n}\nexport declare class LinkedList<T> {\n    head: Entry<T>;\n    tail: Entry<T>;\n    private _len;\n    insert(val: T): Entry<T>;\n    insertEntry(entry: Entry<T>): void;\n    remove(entry: Entry<T>): void;\n    len(): number;\n    clear(): void;\n}\nexport default class LRU<T> {\n    private _list;\n    private _maxSize;\n    private _lastRemovedEntry;\n    private _map;\n    constructor(maxSize: number);\n    put(key: string | number, value: T): T;\n    get(key: string | number): T;\n    clear(): void;\n    len(): number;\n}\n"
  },
  {
    "path": "zrender/esm/core/matrix.d.ts",
    "code": "import { VectorArray } from './vector';\nexport declare type MatrixArray = number[];\nexport declare function create(): MatrixArray;\nexport declare function identity(out: MatrixArray): MatrixArray;\nexport declare function copy(out: MatrixArray, m: MatrixArray): MatrixArray;\nexport declare function mul(out: MatrixArray, m1: MatrixArray, m2: MatrixArray): MatrixArray;\nexport declare function translate(out: MatrixArray, a: MatrixArray, v: VectorArray): MatrixArray;\nexport declare function rotate(out: MatrixArray, a: MatrixArray, rad: number): MatrixArray;\nexport declare function scale(out: MatrixArray, a: MatrixArray, v: VectorArray): MatrixArray;\nexport declare function invert(out: MatrixArray, a: MatrixArray): MatrixArray;\nexport declare function clone(a: MatrixArray): MatrixArray;\n"
  },
  {
    "path": "zrender/esm/core/OrientedBoundingRect.d.ts",
    "code": "import { PointLike } from './Point';\nimport BoundingRect from './BoundingRect';\nimport { MatrixArray } from './matrix';\ndeclare class OrientedBoundingRect {\n    private _corners;\n    private _axes;\n    private _origin;\n    constructor(rect?: BoundingRect, transform?: MatrixArray);\n    fromBoundingRect(rect: BoundingRect, transform?: MatrixArray): void;\n    intersect(other: OrientedBoundingRect, mtv?: PointLike): boolean;\n    private _intersectCheckOneSide;\n    private _getProjMinMaxOnAxis;\n}\nexport default OrientedBoundingRect;\n"
  },
  {
    "path": "zrender/esm/core/PathProxy.d.ts",
    "code": "import BoundingRect from './BoundingRect';\ninterface ExtendedCanvasRenderingContext2D extends CanvasRenderingContext2D {\n    dpr?: number;\n}\nexport default class PathProxy {\n    dpr: number;\n    data: number[] | Float32Array;\n    private _saveData;\n    private _ctx;\n    private _xi;\n    private _yi;\n    private _x0;\n    private _y0;\n    private _len;\n    private _pathSegLen;\n    private _pathLen;\n    private _ux;\n    private _uy;\n    private _lineDash;\n    private _needsDash;\n    private _dashOffset;\n    private _dashIdx;\n    private _dashSum;\n    static CMD: {\n        M: number;\n        L: number;\n        C: number;\n        Q: number;\n        A: number;\n        Z: number;\n        R: number;\n    };\n    constructor(notSaveData?: boolean);\n    setScale(sx: number, sy: number, segmentIgnoreThreshold?: number): void;\n    setDPR(dpr: number): void;\n    setContext(ctx: ExtendedCanvasRenderingContext2D): void;\n    getContext(): ExtendedCanvasRenderingContext2D;\n    beginPath(): this;\n    reset(): void;\n    moveTo(x: number, y: number): this;\n    lineTo(x: number, y: number): this;\n    bezierCurveTo(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): this;\n    quadraticCurveTo(x1: number, y1: number, x2: number, y2: number): this;\n    arc(cx: number, cy: number, r: number, startAngle: number, endAngle: number, anticlockwise?: boolean): this;\n    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    rect(x: number, y: number, w: number, h: number): this;\n    closePath(): this;\n    fill(ctx: CanvasRenderingContext2D): void;\n    stroke(ctx: CanvasRenderingContext2D): void;\n    setLineDash(lineDash: number[] | false): this;\n    setLineDashOffset(offset: number): this;\n    len(): number;\n    setData(data: Float32Array | number[]): void;\n    appendPath(path: PathProxy | PathProxy[]): void;\n    addData(cmd: number, a?: number, b?: number, c?: number, d?: number, e?: number, f?: number, g?: number, h?: number): void;\n    _expandData(): void;\n    _dashedLineTo(x1: number, y1: number): void;\n    _dashedBezierTo(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void;\n    _dashedQuadraticTo(x1: number, y1: number, x2: number, y2: number): void;\n    toStatic(): void;\n    getBoundingRect(): BoundingRect;\n    private _calculateLength;\n    rebuildPath(ctx: CanvasRenderingContext2D, percent: number): void;\n    private static initDefaultProps;\n}\nexport {};\n"
  },
  {
    "path": "zrender/esm/core/Point.d.ts",
    "code": "import { MatrixArray } from \"./matrix\";\nexport interface PointLike {\n    x: number;\n    y: number;\n}\nexport default class Point {\n    x: number;\n    y: number;\n    constructor(x?: number, y?: number);\n    copy(other: PointLike): this;\n    clone(): Point;\n    set(x: number, y: number): this;\n    equal(other: PointLike): boolean;\n    add(other: PointLike): this;\n    scale(scalar: number): void;\n    scaleAndAdd(other: PointLike, scalar: number): void;\n    sub(other: PointLike): this;\n    dot(other: PointLike): number;\n    len(): number;\n    lenSquare(): number;\n    normalize(): this;\n    distance(other: PointLike): number;\n    distanceSquare(other: Point): number;\n    negate(): this;\n    transform(m: MatrixArray): this;\n    toArray(out: number[]): number[];\n    fromArray(input: number[]): void;\n    static set(p: PointLike, x: number, y: number): void;\n    static copy(p: PointLike, p2: PointLike): void;\n    static len(p: PointLike): number;\n    static lenSquare(p: PointLike): number;\n    static dot(p0: PointLike, p1: PointLike): number;\n    static add(out: PointLike, p0: PointLike, p1: PointLike): void;\n    static sub(out: PointLike, p0: PointLike, p1: PointLike): void;\n    static scale(out: PointLike, p0: PointLike, scalar: number): void;\n    static scaleAndAdd(out: PointLike, p0: PointLike, p1: PointLike, scalar: number): void;\n    static lerp(out: PointLike, p0: PointLike, p1: PointLike, t: number): void;\n}\n"
  },
  {
    "path": "zrender/esm/core/timsort.d.ts",
    "code": "declare type CompareFunc<T> = (a: T, b: T) => number;\nexport default function sort<T>(array: T[], compare: CompareFunc<T>, lo?: number, hi?: number): void;\nexport {};\n"
  },
  {
    "path": "zrender/esm/core/Transformable.d.ts",
    "code": "import * as matrix from './matrix';\nimport * as vector from './vector';\ndeclare class Transformable {\n    parent: Transformable;\n    x: number;\n    y: number;\n    scaleX: number;\n    scaleY: number;\n    rotation: number;\n    originX: number;\n    originY: number;\n    globalScaleRatio: number;\n    transform: matrix.MatrixArray;\n    invTransform: matrix.MatrixArray;\n    setPosition(arr: number[]): void;\n    setScale(arr: number[]): void;\n    setOrigin(arr: number[]): void;\n    needLocalTransform(): boolean;\n    updateTransform(): void;\n    private _resolveGlobalScaleRatio;\n    getLocalTransform(m?: matrix.MatrixArray): matrix.MatrixArray;\n    getComputedTransform(): matrix.MatrixArray;\n    setLocalTransform(m: vector.VectorArray): void;\n    decomposeTransform(): void;\n    getGlobalScale(out?: vector.VectorArray): vector.VectorArray;\n    transformCoordToLocal(x: number, y: number): number[];\n    transformCoordToGlobal(x: number, y: number): number[];\n    getLineScale(): number;\n    static getLocalTransform(target: Transformable, m?: matrix.MatrixArray): matrix.MatrixArray;\n    private static initDefaultProps;\n}\nexport default Transformable;\n"
  },
  {
    "path": "zrender/esm/core/types.d.ts",
    "code": "export declare type Dictionary<T> = {\n    [key: string]: T;\n};\nexport declare type ArrayLike<T> = {\n    [key: number]: T;\n    length: number;\n};\nexport declare type ImageLike = HTMLImageElement | HTMLCanvasElement | HTMLVideoElement;\nexport declare type TextVerticalAlign = 'top' | 'middle' | 'bottom';\nexport declare type TextAlign = 'left' | 'center' | 'right';\nexport declare type BuiltinTextPosition = 'left' | 'right' | 'top' | 'bottom' | 'inside' | 'insideLeft' | 'insideRight' | 'insideTop' | 'insideBottom' | 'insideTopLeft' | 'insideTopRight' | 'insideBottomLeft' | 'insideBottomRight';\nexport declare type WXCanvasRenderingContext = CanvasRenderingContext2D & {\n    draw: () => void;\n};\nexport declare type ZRCanvasRenderingContext = CanvasRenderingContext2D & {\n    dpr: number;\n    __attrCachedBy: boolean | number;\n};\ndeclare type ZREventProperties = {\n    zrX: number;\n    zrY: number;\n    zrDelta: number;\n    zrEventControl: 'no_globalout' | 'only_globalout';\n    zrIsToLocalDOM: boolean;\n    zrByTouch: boolean;\n};\nexport declare type ZRRawMouseEvent = MouseEvent & ZREventProperties;\nexport declare type ZRRawTouchEvent = TouchEvent & ZREventProperties;\nexport declare type ZRRawPointerEvent = TouchEvent & ZREventProperties;\nexport declare type ZRRawEvent = ZRRawMouseEvent | ZRRawTouchEvent | ZRRawPointerEvent;\nexport declare type ZRPinchEvent = ZRRawEvent & {\n    pinchScale: number;\n    pinchX: number;\n    pinchY: number;\n    gestureEvent: string;\n};\nexport declare type ElementEventName = 'click' | 'dblclick' | 'mousewheel' | 'mouseout' | 'mouseover' | 'mouseup' | 'mousedown' | 'mousemove' | 'contextmenu' | 'drag' | 'dragstart' | 'dragend' | 'dragenter' | 'dragleave' | 'dragover' | 'drop';\nexport declare type ElementEventNameWithOn = 'onclick' | 'ondblclick' | 'onmousewheel' | 'onmouseout' | 'onmouseup' | 'onmousedown' | 'onmousemove' | 'oncontextmenu' | 'ondrag' | 'ondragstart' | 'ondragend' | 'ondragenter' | 'ondragleave' | 'ondragover' | 'ondrop';\nexport declare type PropType<TObj, TProp extends keyof TObj> = TObj[TProp];\nexport declare type AllPropTypes<T> = PropType<T, keyof T>;\nexport declare type FunctionPropertyNames<T> = {\n    [K in keyof T]: T[K] extends Function ? K : never;\n}[keyof T];\nexport declare type MapToType<T extends Dictionary<any>, S> = {\n    [P in keyof T]: T[P] extends Dictionary<any> ? MapToType<T[P], S> : S;\n};\nexport declare type KeyOfDistributive<T> = T extends unknown ? keyof T : never;\nexport {};\n"
  },
  {
    "path": "zrender/esm/core/util.d.ts",
    "code": "import { Dictionary, ArrayLike, KeyOfDistributive } from './types';\nimport { GradientObject } from '../graphic/Gradient';\nimport { PatternObject } from '../graphic/Pattern';\ndeclare const nativeSlice: (start?: number, end?: number) => any[];\nexport declare function $override(name: string, fn: Function): void;\nexport declare function guid(): number;\nexport declare function logError(...args: string[]): void;\nexport declare function clone<T extends any>(source: T): T;\nexport declare function merge<T extends Dictionary<any>, S extends Dictionary<any>>(target: T, source: S, overwrite?: boolean): T & S;\nexport declare function merge<T extends any, S extends any>(target: T, source: S, overwrite?: boolean): T | S;\nexport declare function mergeAll(targetAndSources: any[], overwrite?: boolean): any;\nexport declare function extend<T extends Dictionary<any>, S extends Dictionary<any>>(target: T, source: S): T & S;\nexport declare function defaults<T extends Dictionary<any>, S extends Dictionary<any>>(target: T, source: S, overlay?: boolean): T & S;\nexport declare const createCanvas: () => HTMLCanvasElement;\nexport declare function indexOf<T>(array: T[] | readonly T[] | ArrayLike<T>, value: T): number;\nexport declare function inherits(clazz: Function, baseClazz: Function): void;\nexport declare function mixin<T, S>(target: T | Function, source: S | Function, override?: boolean): void;\nexport declare function isArrayLike(data: any): data is ArrayLike<any>;\nexport declare function each<I extends Dictionary<any> | any[] | readonly any[] | ArrayLike<any>, Context>(arr: I, cb: (this: Context, value: I extends (infer T)[] | readonly (infer T)[] | ArrayLike<infer T> ? T : I extends Dictionary<any> ? I extends Record<infer K, infer T> ? T : unknown : unknown, index?: I extends any[] | readonly any[] | ArrayLike<any> ? number : keyof I & string, arr?: I) => void, context?: Context): void;\nexport declare function map<T, R, Context>(arr: readonly T[], cb: (this: Context, val: T, index?: number, arr?: readonly T[]) => R, context?: Context): R[];\nexport declare function reduce<T, S, Context>(arr: readonly T[], cb: (this: Context, previousValue: S, currentValue: T, currentIndex?: number, arr?: readonly T[]) => S, memo?: S, context?: Context): S;\nexport declare function filter<T, Context>(arr: readonly T[], cb: (this: Context, value: T, index: number, arr: readonly T[]) => boolean, context?: Context): T[];\nexport declare function find<T, Context>(arr: readonly T[], cb: (this: Context, value: T, index?: number, arr?: readonly T[]) => boolean, context?: Context): T;\nexport declare function keys<T extends object>(obj: T): (KeyOfDistributive<T> & string)[];\nexport declare type Bind1<F, Ctx> = F extends (this: Ctx, ...args: infer A) => infer R ? (...args: A) => R : unknown;\nexport declare type Bind2<F, Ctx, T1> = F extends (this: Ctx, a: T1, ...args: infer A) => infer R ? (...args: A) => R : unknown;\nexport declare type Bind3<F, Ctx, T1, T2> = F extends (this: Ctx, a: T1, b: T2, ...args: infer A) => infer R ? (...args: A) => R : unknown;\nexport declare type Bind4<F, Ctx, T1, T2, T3> = F extends (this: Ctx, a: T1, b: T2, c: T3, ...args: infer A) => infer R ? (...args: A) => R : unknown;\nexport declare type Bind5<F, Ctx, T1, T2, T3, T4> = F extends (this: Ctx, a: T1, b: T2, c: T3, d: T4, ...args: infer A) => infer R ? (...args: A) => R : unknown;\ndeclare type BindFunc<Ctx> = (this: Ctx, ...arg: any[]) => any;\ninterface FunctionBind {\n    <F extends BindFunc<Ctx>, Ctx>(func: F, ctx: Ctx): Bind1<F, Ctx>;\n    <F extends BindFunc<Ctx>, Ctx, T1 extends Parameters<F>[0]>(func: F, ctx: Ctx, a: T1): Bind2<F, Ctx, T1>;\n    <F extends BindFunc<Ctx>, Ctx, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1]>(func: F, ctx: Ctx, a: T1, b: T2): Bind3<F, Ctx, T1, T2>;\n    <F extends BindFunc<Ctx>, Ctx, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1], T3 extends Parameters<F>[2]>(func: F, ctx: Ctx, a: T1, b: T2, c: T3): Bind4<F, Ctx, T1, T2, T3>;\n    <F extends BindFunc<Ctx>, Ctx, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1], T3 extends Parameters<F>[2], T4 extends Parameters<F>[3]>(func: F, ctx: Ctx, a: T1, b: T2, c: T3, d: T4): Bind5<F, Ctx, T1, T2, T3, T4>;\n}\nexport declare const bind: FunctionBind;\nexport declare type Curry1<F, T1> = F extends (a: T1, ...args: infer A) => infer R ? (...args: A) => R : unknown;\nexport declare type Curry2<F, T1, T2> = F extends (a: T1, b: T2, ...args: infer A) => infer R ? (...args: A) => R : unknown;\nexport declare type Curry3<F, T1, T2, T3> = F extends (a: T1, b: T2, c: T3, ...args: infer A) => infer R ? (...args: A) => R : unknown;\nexport declare type Curry4<F, T1, T2, T3, T4> = F extends (a: T1, b: T2, c: T3, d: T4, ...args: infer A) => infer R ? (...args: A) => R : unknown;\ndeclare type CurryFunc = (...arg: any[]) => any;\ndeclare function curry<F extends CurryFunc, T1 extends Parameters<F>[0]>(func: F, a: T1): Curry1<F, T1>;\ndeclare function curry<F extends CurryFunc, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1]>(func: F, a: T1, b: T2): Curry2<F, T1, T2>;\ndeclare function curry<F extends CurryFunc, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1], T3 extends Parameters<F>[2]>(func: F, a: T1, b: T2, c: T3): Curry3<F, T1, T2, T3>;\ndeclare function curry<F extends CurryFunc, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1], T3 extends Parameters<F>[2], T4 extends Parameters<F>[3]>(func: F, a: T1, b: T2, c: T3, d: T4): Curry4<F, T1, T2, T3, T4>;\nexport { curry };\nexport declare function isArray(value: any): value is any[];\nexport declare function isFunction(value: any): value is Function;\nexport declare function isString(value: any): value is string;\nexport declare function isStringSafe(value: any): value is string;\nexport declare function isNumber(value: any): value is number;\nexport declare function isObject<T = unknown>(value: T): value is (object & T);\nexport declare function isBuiltInObject(value: any): boolean;\nexport declare function isTypedArray(value: any): boolean;\nexport declare function isDom(value: any): value is HTMLElement;\nexport declare function isGradientObject(value: any): value is GradientObject;\nexport declare function isPatternObject(value: any): value is PatternObject;\nexport declare function isRegExp(value: unknown): value is RegExp;\nexport declare function eqNaN(value: any): boolean;\nexport declare function retrieve<T>(...args: T[]): T;\nexport declare function retrieve2<T, R>(value0: T, value1: R): T | R;\nexport declare function retrieve3<T, R, W>(value0: T, value1: R, value2: W): T | R | W;\ndeclare type SliceParams = Parameters<typeof nativeSlice>;\nexport declare function slice<T>(arr: ArrayLike<T>, ...args: SliceParams): T[];\nexport declare function normalizeCssArray(val: number | number[]): number[];\nexport declare function assert(condition: any, message?: string): void;\nexport declare function trim(str: string): string;\nexport declare function setAsPrimitive(obj: any): void;\nexport declare function isPrimitive(obj: any): boolean;\nexport declare class HashMap<T, KEY extends string | number = string | number> {\n    data: {\n        [key in KEY]: T;\n    };\n    constructor(obj?: HashMap<T, KEY> | Dictionary<T> | any[]);\n    get(key: KEY): T;\n    set(key: KEY, value: T): T;\n    each<Context>(cb: (this: Context, value?: T, key?: KEY) => void, context?: Context): void;\n    keys(): KEY[];\n    removeKey(key: KEY): void;\n}\nexport declare function createHashMap<T, KEY extends string | number = string | number>(obj?: HashMap<T, KEY> | Dictionary<T> | any[]): HashMap<T, KEY>;\nexport declare function concatArray<T, R>(a: ArrayLike<T>, b: ArrayLike<R>): ArrayLike<T | R>;\nexport declare function createObject<T>(proto?: object, properties?: T): T;\nexport declare function hasOwn(own: object, prop: string): boolean;\nexport declare function noop(): void;\n"
  },
  {
    "path": "zrender/esm/core/vector.d.ts",
    "code": "import { MatrixArray } from './matrix';\nexport declare type VectorArray = number[];\nexport declare function create(x?: number, y?: number): VectorArray;\nexport declare function copy<T extends VectorArray>(out: T, v: VectorArray): T;\nexport declare function clone(v: VectorArray): VectorArray;\nexport declare function set<T extends VectorArray>(out: T, a: number, b: number): T;\nexport declare function add<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;\nexport declare function scaleAndAdd<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray, a: number): T;\nexport declare function sub<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;\nexport declare function len(v: VectorArray): number;\nexport declare const length: typeof len;\nexport declare function lenSquare(v: VectorArray): number;\nexport declare const lengthSquare: typeof lenSquare;\nexport declare function mul<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;\nexport declare function div<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;\nexport declare function dot(v1: VectorArray, v2: VectorArray): number;\nexport declare function scale<T extends VectorArray>(out: T, v: VectorArray, s: number): T;\nexport declare function normalize<T extends VectorArray>(out: T, v: VectorArray): T;\nexport declare function distance(v1: VectorArray, v2: VectorArray): number;\nexport declare const dist: typeof distance;\nexport declare function distanceSquare(v1: VectorArray, v2: VectorArray): number;\nexport declare const distSquare: typeof distanceSquare;\nexport declare function negate<T extends VectorArray>(out: T, v: VectorArray): T;\nexport declare function lerp<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray, t: number): T;\nexport declare function applyTransform<T extends VectorArray>(out: T, v: VectorArray, m: MatrixArray): T;\nexport declare function min<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;\nexport declare function max<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;\n"
  },
  {
    "path": "zrender/esm/dom/HandlerProxy.d.ts",
    "code": "import Eventful from '../core/Eventful';\nimport { VectorArray } from '../core/vector';\nimport Handler from '../Handler';\nexport default class HandlerDomProxy extends Eventful {\n    dom: HTMLElement;\n    painterRoot: HTMLElement;\n    handler: Handler;\n    private _localHandlerScope;\n    private _globalHandlerScope;\n    __lastTouchMoment: Date;\n    __pointerCapturing: boolean;\n    __mayPointerCapture: VectorArray;\n    constructor(dom: HTMLElement, painterRoot: HTMLElement);\n    dispose(): void;\n    setCursor(cursorStyle: string): void;\n    __togglePointerCapture(isPointerCapturing?: boolean): void;\n}\nexport interface HandlerProxyInterface extends Eventful {\n    handler: Handler;\n    dispose: () => void;\n    setCursor: (cursorStyle?: string) => void;\n}\n"
  },
  {
    "path": "zrender/esm/Element.d.ts",
    "code": "import Transformable from './core/Transformable';\nimport { AnimationEasing } from './animation/easing';\nimport Animator from './animation/Animator';\nimport { ZRenderType } from './zrender';\nimport { Dictionary, ElementEventName, ZRRawEvent, BuiltinTextPosition, MapToType } from './core/types';\nimport Path from './graphic/Path';\nimport BoundingRect, { RectLike } from './core/BoundingRect';\nimport Eventful, { EventQuery, EventCallback } from './core/Eventful';\nimport ZRText from './graphic/Text';\nimport { TextPositionCalculationResult } from './contain/text';\nimport Polyline from './graphic/shape/Polyline';\nimport Group from './graphic/Group';\nimport Point from './core/Point';\nexport interface ElementAnimateConfig {\n    duration?: number;\n    delay?: number;\n    easing?: AnimationEasing;\n    done?: Function;\n    during?: (percent: number) => void;\n    scope?: string;\n    force?: boolean;\n    additive?: boolean;\n    setToFinal?: boolean;\n}\nexport interface ElementTextConfig {\n    position?: BuiltinTextPosition | (number | string)[];\n    rotation?: number;\n    layoutRect?: RectLike;\n    offset?: number[];\n    origin?: (number | string)[] | 'center';\n    distance?: number;\n    local?: boolean;\n    insideFill?: string;\n    insideStroke?: string;\n    outsideFill?: string;\n    outsideStroke?: string;\n    inside?: boolean;\n}\nexport interface ElementTextGuideLineConfig {\n    anchor?: Point;\n    candidates?: ('left' | 'top' | 'right' | 'bottom')[];\n}\nexport interface ElementEvent {\n    type: ElementEventName;\n    event: ZRRawEvent;\n    target: Element;\n    topTarget: Element;\n    cancelBubble: boolean;\n    offsetX: number;\n    offsetY: number;\n    gestureEvent: string;\n    pinchX: number;\n    pinchY: number;\n    pinchScale: number;\n    wheelDelta: number;\n    zrByTouch: boolean;\n    which: number;\n    stop: (this: ElementEvent) => void;\n}\nexport declare type ElementEventCallback<Ctx, Impl> = (this: CbThis<Ctx, Impl>, e: ElementEvent) => boolean | void;\ndeclare type CbThis<Ctx, Impl> = unknown extends Ctx ? Impl : Ctx;\ninterface ElementEventHandlerProps {\n    onclick: ElementEventCallback<unknown, unknown>;\n    ondblclick: ElementEventCallback<unknown, unknown>;\n    onmouseover: ElementEventCallback<unknown, unknown>;\n    onmouseout: ElementEventCallback<unknown, unknown>;\n    onmousemove: ElementEventCallback<unknown, unknown>;\n    onmousewheel: ElementEventCallback<unknown, unknown>;\n    onmousedown: ElementEventCallback<unknown, unknown>;\n    onmouseup: ElementEventCallback<unknown, unknown>;\n    oncontextmenu: ElementEventCallback<unknown, unknown>;\n    ondrag: ElementEventCallback<unknown, unknown>;\n    ondragstart: ElementEventCallback<unknown, unknown>;\n    ondragend: ElementEventCallback<unknown, unknown>;\n    ondragenter: ElementEventCallback<unknown, unknown>;\n    ondragleave: ElementEventCallback<unknown, unknown>;\n    ondragover: ElementEventCallback<unknown, unknown>;\n    ondrop: ElementEventCallback<unknown, unknown>;\n}\nexport interface ElementProps extends Partial<ElementEventHandlerProps> {\n    name?: string;\n    ignore?: boolean;\n    isGroup?: boolean;\n    draggable?: boolean;\n    silent?: boolean;\n    x?: number;\n    y?: number;\n    scaleX?: number;\n    scaleY?: number;\n    originX?: number;\n    originY?: number;\n    rotation?: number;\n    globalScaleRatio?: number;\n    textConfig?: ElementTextConfig;\n    textContent?: ZRText;\n    clipPath?: Path;\n    drift?: Element['drift'];\n    extra?: Dictionary<unknown>;\n    anid?: string;\n}\nexport declare const PRESERVED_NORMAL_STATE = \"__zr_normal__\";\ndeclare const PRIMARY_STATES_KEYS: readonly [\"x\", \"y\", \"scaleX\", \"scaleY\", \"originX\", \"originY\", \"rotation\", \"ignore\"];\nexport declare type ElementStatePropNames = (typeof PRIMARY_STATES_KEYS)[number] | 'textConfig';\nexport declare type ElementState = Pick<ElementProps, ElementStatePropNames> & ElementCommonState;\nexport declare type ElementCommonState = {\n    hoverLayer?: boolean;\n};\ninterface Element<Props extends ElementProps = ElementProps> extends Transformable, Eventful, ElementEventHandlerProps {\n    on<Ctx>(event: ElementEventName, handler: ElementEventCallback<Ctx, this>, context?: Ctx): this;\n    on<Ctx>(event: string, handler: EventCallback<Ctx, this>, context?: Ctx): this;\n    on<Ctx>(event: ElementEventName, query: EventQuery, handler: ElementEventCallback<Ctx, this>, context?: Ctx): this;\n    on<Ctx>(event: string, query: EventQuery, handler: EventCallback<Ctx, this>, context?: Ctx): this;\n}\ndeclare class Element<Props extends ElementProps = ElementProps> {\n    id: number;\n    type: string;\n    name: string;\n    ignore: boolean;\n    silent: boolean;\n    isGroup: boolean;\n    draggable: boolean | string;\n    dragging: boolean;\n    parent: Group;\n    animators: Animator<any>[];\n    __hostTarget: Element;\n    __zr: ZRenderType;\n    __dirty: number;\n    __inHover: boolean;\n    private _clipPath?;\n    private _textContent?;\n    private _textGuide?;\n    textConfig?: ElementTextConfig;\n    textGuideLineConfig?: ElementTextGuideLineConfig;\n    anid: string;\n    extra: Dictionary<unknown>;\n    currentStates?: string[];\n    prevStates?: string[];\n    states: Dictionary<ElementState>;\n    stateTransition: ElementAnimateConfig;\n    stateProxy?: (stateName: string, targetStates?: string[]) => ElementState;\n    protected _normalState: ElementState;\n    private _innerTextDefaultStyle;\n    constructor(props?: Props);\n    protected _init(props?: Props): void;\n    drift(dx: number, dy: number, e?: ElementEvent): void;\n    beforeUpdate(): void;\n    afterUpdate(): void;\n    update(): void;\n    updateInnerText(forceUpdate?: boolean): void;\n    protected canBeInsideText(): boolean;\n    protected getInsideTextFill(): string;\n    protected getInsideTextStroke(textFill: string): string;\n    protected getOutsideFill(): \"#333\" | \"#ccc\";\n    protected getOutsideStroke(textFill: string): string;\n    traverse<Context>(cb: (this: Context, el: Element<Props>) => void, context?: Context): void;\n    protected attrKV(key: string, value: unknown): void;\n    hide(): void;\n    show(): void;\n    attr(keyOrObj: Props): this;\n    attr<T extends keyof Props>(keyOrObj: T, value: Props[T]): this;\n    saveCurrentToNormalState(toState: ElementState): void;\n    protected _innerSaveToNormal(toState: ElementState): void;\n    protected _savePrimaryToNormal(toState: Dictionary<any>, normalState: Dictionary<any>, primaryKeys: readonly string[]): void;\n    hasState(): boolean;\n    getState(name: string): ElementState;\n    ensureState(name: string): ElementState;\n    clearStates(): void;\n    useState(stateName: string, keepCurrentStates?: boolean): ElementState;\n    useStates(states: string[]): void;\n    private _updateAnimationTargets;\n    removeState(state: string): void;\n    replaceState(oldState: string, newState: string, forceAdd: boolean): void;\n    toggleState(state: string, enable: boolean): void;\n    protected _mergeStates(states: ElementState[]): ElementState;\n    protected _applyStateObj(stateName: string, state: ElementState, normalState: ElementState, keepCurrentStates: boolean, transition: boolean, animationCfg: ElementAnimateConfig): void;\n    private _attachComponent;\n    private _detachComponent;\n    getClipPath(): Path<import(\"./graphic/Path\").PathProps>;\n    setClipPath(clipPath: Path): void;\n    removeClipPath(): void;\n    getTextContent(): ZRText;\n    setTextContent(textEl: ZRText): void;\n    setTextConfig(cfg: ElementTextConfig): void;\n    removeTextContent(): void;\n    getTextGuideLine(): Polyline;\n    setTextGuideLine(guideLine: Polyline): void;\n    removeTextGuideLine(): void;\n    markRedraw(): void;\n    dirty(): void;\n    private _toggleHoverLayerFlag;\n    addSelfToZr(zr: ZRenderType): void;\n    removeSelfFromZr(zr: ZRenderType): void;\n    animate(key?: string, loop?: boolean): Animator<any>;\n    addAnimator(animator: Animator<any>, key: string): void;\n    updateDuringAnimation(key: string): void;\n    stopAnimation(scope?: string, forwardToLast?: boolean): this;\n    animateTo(target: Props, cfg?: ElementAnimateConfig, animationProps?: MapToType<Props, boolean>): void;\n    animateFrom(target: Props, cfg: Omit<ElementAnimateConfig, 'setToFinal'>, animationProps?: MapToType<Props, boolean>): void;\n    protected _transitionState(stateName: string, target: Props, cfg?: ElementAnimateConfig, animationProps?: MapToType<Props, boolean>): void;\n    getBoundingRect(): BoundingRect;\n    calculateTextPosition: (out: TextPositionCalculationResult, style: ElementTextConfig, rect: RectLike) => TextPositionCalculationResult;\n    static REDARAW_BIT: number;\n    protected static initDefaultProps: void;\n}\nexport default Element;\n"
  },
  {
    "path": "zrender/esm/export.d.ts",
    "code": "import * as zrUtil from './core/util';\nimport * as matrix from './core/matrix';\nimport * as vector from './core/vector';\nimport * as colorTool from './tool/color';\nimport * as pathTool from './tool/path';\nimport { parseSVG } from './tool/parseSVG';\nexport { default as Point } from './core/Point';\nexport { default as Element } from './Element';\nexport { default as Group } from './graphic/Group';\nexport { default as Path } from './graphic/Path';\nexport { default as Image } from './graphic/Image';\nexport { default as CompoundPath } from './graphic/CompoundPath';\nexport { default as TSpan } from './graphic/TSpan';\nexport { default as IncrementalDisplayable } from './graphic/IncrementalDisplayable';\nexport { default as Text } from './graphic/Text';\nexport { default as Arc } from './graphic/shape/Arc';\nexport { default as BezierCurve } from './graphic/shape/BezierCurve';\nexport { default as Circle } from './graphic/shape/Circle';\nexport { default as Droplet } from './graphic/shape/Droplet';\nexport { default as Ellipse } from './graphic/shape/Ellipse';\nexport { default as Heart } from './graphic/shape/Heart';\nexport { default as Isogon } from './graphic/shape/Isogon';\nexport { default as Line } from './graphic/shape/Line';\nexport { default as Polygon } from './graphic/shape/Polygon';\nexport { default as Polyline } from './graphic/shape/Polyline';\nexport { default as Rect } from './graphic/shape/Rect';\nexport { default as Ring } from './graphic/shape/Ring';\nexport { default as Rose } from './graphic/shape/Rose';\nexport { default as Sector } from './graphic/shape/Sector';\nexport { default as Star } from './graphic/shape/Star';\nexport { default as Trochoid } from './graphic/shape/Trochoid';\nexport { default as LinearGradient } from './graphic/LinearGradient';\nexport { default as RadialGradient } from './graphic/RadialGradient';\nexport { default as Pattern } from './graphic/Pattern';\nexport { default as BoundingRect } from './core/BoundingRect';\nexport { default as OrientedBoundingRect } from './core/OrientedBoundingRect';\nexport { matrix };\nexport { vector };\nexport { colorTool as color };\nexport { pathTool as path };\nexport { zrUtil as util };\nexport { parseSVG };\n"
  },
  {
    "path": "zrender/esm/graphic/CompoundPath.d.ts",
    "code": "import Path from './Path';\ninterface CompoundPathShape {\n    paths: Path[];\n}\nexport default class CompoundPath extends Path {\n    type: string;\n    shape: CompoundPathShape;\n    private _updatePathDirty;\n    beforeBrush(): void;\n    buildPath(ctx: CanvasRenderingContext2D, shape: CompoundPathShape): void;\n    afterBrush(): void;\n    getBoundingRect(): import(\"../core/BoundingRect\").default;\n}\nexport {};\n"
  },
  {
    "path": "zrender/esm/graphic/Displayable.d.ts",
    "code": "import Element, { ElementProps, ElementStatePropNames, ElementAnimateConfig, ElementCommonState } from '../Element';\nimport BoundingRect from '../core/BoundingRect';\nimport { PropType, Dictionary, MapToType } from '../core/types';\nimport Path from './Path';\nimport Animator from '../animation/Animator';\nexport interface CommonStyleProps {\n    shadowBlur?: number;\n    shadowOffsetX?: number;\n    shadowOffsetY?: number;\n    shadowColor?: string;\n    opacity?: number;\n    blend?: string;\n}\nexport declare const DEFAULT_COMMON_STYLE: CommonStyleProps;\nexport declare const DEFAULT_COMMON_ANIMATION_PROPS: MapToType<DisplayableProps, boolean>;\nexport interface DisplayableProps extends ElementProps {\n    style?: Dictionary<any>;\n    zlevel?: number;\n    z?: number;\n    z2?: number;\n    culling?: boolean;\n    cursor?: string;\n    rectHover?: boolean;\n    progressive?: boolean;\n    incremental?: boolean;\n    batch?: boolean;\n    invisible?: boolean;\n}\ndeclare type DisplayableKey = keyof DisplayableProps;\ndeclare type DisplayablePropertyType = PropType<DisplayableProps, DisplayableKey>;\nexport declare type DisplayableStatePropNames = ElementStatePropNames | 'style' | 'z' | 'z2' | 'invisible';\nexport declare type DisplayableState = Pick<DisplayableProps, DisplayableStatePropNames> & ElementCommonState;\ninterface Displayable<Props extends DisplayableProps = DisplayableProps> {\n    animate(key?: '', loop?: boolean): Animator<this>;\n    animate(key: 'style', loop?: boolean): Animator<this['style']>;\n    getState(stateName: string): DisplayableState;\n    ensureState(stateName: string): DisplayableState;\n    states: Dictionary<DisplayableState>;\n    stateProxy: (stateName: string) => DisplayableState;\n}\ndeclare class Displayable<Props extends DisplayableProps = DisplayableProps> extends Element<Props> {\n    invisible: boolean;\n    z: number;\n    z2: number;\n    zlevel: number;\n    culling: boolean;\n    cursor: string;\n    rectHover: boolean;\n    incremental: boolean;\n    style: Dictionary<any>;\n    protected _normalState: DisplayableState;\n    protected _rect: BoundingRect;\n    useHoverLayer?: boolean;\n    __hoverStyle?: CommonStyleProps;\n    __clipPaths?: Path[];\n    __canvasFillGradient: CanvasGradient;\n    __canvasStrokeGradient: CanvasGradient;\n    __canvasFillPattern: CanvasPattern;\n    __canvasStrokePattern: CanvasPattern;\n    __svgEl: SVGElement;\n    constructor(props?: Props);\n    protected _init(props?: Props): void;\n    beforeBrush(): void;\n    afterBrush(): void;\n    innerBeforeBrush(): void;\n    innerAfterBrush(): void;\n    contain(x: number, y: number): boolean;\n    traverse<Context>(cb: (this: Context, el: this) => void, context?: Context): void;\n    rectContain(x: number, y: number): boolean;\n    animateStyle(loop: boolean): Animator<this[\"style\"]>;\n    updateDuringAnimation(targetKey: string): void;\n    attrKV(key: DisplayableKey, value: DisplayablePropertyType): void;\n    setStyle(obj: Props['style']): this;\n    setStyle<T extends keyof Props['style']>(obj: T, value: Props['style'][T]): this;\n    dirtyStyle(): void;\n    dirty(): void;\n    styleChanged(): boolean;\n    styleUpdated(): void;\n    createStyle(obj?: Props['style']): Props[\"style\"];\n    useStyle(obj: Props['style']): void;\n    isStyleObject(obj: Props['style']): any;\n    protected _innerSaveToNormal(toState: DisplayableState): void;\n    protected _applyStateObj(stateName: string, state: DisplayableState, normalState: DisplayableState, keepCurrentStates: boolean, transition: boolean, animationCfg: ElementAnimateConfig): void;\n    protected _mergeStates(states: DisplayableState[]): DisplayableState;\n    protected _mergeStyle(targetStyle: CommonStyleProps, sourceStyle: CommonStyleProps): CommonStyleProps;\n    protected _getAnimationStyleProps(): MapToType<DisplayableProps, boolean>;\n    static STYLE_CHANGED_BIT: number;\n    protected static initDefaultProps: void;\n}\nexport default Displayable;\n"
  },
  {
    "path": "zrender/esm/graphic/Gradient.d.ts",
    "code": "export interface GradientObject {\n    id?: number;\n    type: string;\n    colorStops: GradientColorStop[];\n    __canvasGradient: CanvasGradient;\n}\nexport interface GradientColorStop {\n    offset: number;\n    color: string;\n}\nexport default class Gradient {\n    id?: number;\n    type: string;\n    colorStops: GradientColorStop[];\n    __canvasGradient: CanvasGradient;\n    constructor(colorStops: GradientColorStop[]);\n    addColorStop(offset: number, color: string): void;\n}\n"
  },
  {
    "path": "zrender/esm/graphic/Group.d.ts",
    "code": "import Element, { ElementProps } from '../Element';\nimport BoundingRect from '../core/BoundingRect';\nimport { ZRenderType } from '../zrender';\nexport interface GroupProps extends ElementProps {\n}\ndeclare class Group extends Element<GroupProps> {\n    readonly isGroup = true;\n    private _children;\n    constructor(opts?: GroupProps);\n    childrenRef(): Element<ElementProps>[];\n    children(): Element<ElementProps>[];\n    childAt(idx: number): Element;\n    childOfName(name: string): Element;\n    childCount(): number;\n    add(child: Element): Group;\n    addBefore(child: Element, nextSibling: Element): this;\n    replaceAt(child: Element, index: number): this;\n    _doAdd(child: Element): void;\n    remove(child: Element): this;\n    removeAll(): this;\n    eachChild<Context>(cb: (this: Context, el: Element, index?: number) => void, context?: Context): this;\n    traverse<T>(cb: (this: T, el: Element) => boolean | void, context?: T): this;\n    addSelfToZr(zr: ZRenderType): void;\n    removeSelfFromZr(zr: ZRenderType): void;\n    getBoundingRect(includeChildren?: Element[]): BoundingRect;\n}\nexport default Group;\n"
  },
  {
    "path": "zrender/esm/graphic/helper/image.d.ts",
    "code": "import { ImageLike } from '../../core/types';\nexport declare function findExistImage(newImageOrSrc: string | ImageLike): ImageLike;\nexport declare function createOrUpdateImage<T>(newImageOrSrc: string | ImageLike, image: ImageLike, hostEl: {\n    dirty: () => void;\n}, cb?: (image: ImageLike, payload: T) => void, cbPayload?: T): ImageLike;\nexport declare function isImageReady(image: ImageLike): number;\n"
  },
  {
    "path": "zrender/esm/graphic/helper/parseText.d.ts",
    "code": "import { TextAlign, TextVerticalAlign } from '../../core/types';\nimport { TextStyleProps } from '../Text';\ninterface InnerTruncateOption {\n    maxIteration?: number;\n    minChar?: number;\n    placeholder?: string;\n    maxIterations?: number;\n}\nexport declare function truncateText(text: string, containerWidth: number, font: string, ellipsis: string, options: InnerTruncateOption): string;\nexport interface PlainTextContentBlock {\n    lineHeight: number;\n    contentHeight: number;\n    calculatedLineHeight: number;\n    height: number;\n    outerHeight: number;\n    width: number;\n    lines: string[];\n}\nexport declare function parsePlainText(text: string, style?: TextStyleProps): PlainTextContentBlock;\ndeclare class RichTextToken {\n    styleName: string;\n    text: string;\n    width: number;\n    height: number;\n    contentHeight: number;\n    contentWidth: number;\n    lineHeight: number;\n    font: string;\n    align: TextAlign;\n    verticalAlign: TextVerticalAlign;\n    textPadding: number[];\n    percentWidth?: string;\n    isLineHolder: boolean;\n}\ndeclare class RichTextLine {\n    lineHeight: number;\n    width: number;\n    tokens: RichTextToken[];\n    constructor(tokens?: RichTextToken[]);\n}\nexport declare class RichTextContentBlock {\n    width: number;\n    height: number;\n    contentWidth: number;\n    contentHeight: number;\n    outerWidth: number;\n    outerHeight: number;\n    lines: RichTextLine[];\n}\nexport declare function parseRichText(text: string, style: TextStyleProps): RichTextContentBlock;\nexport {};\n"
  },
  {
    "path": "zrender/esm/graphic/helper/poly.d.ts",
    "code": "import { VectorArray } from '../../core/vector';\nimport PathProxy from '../../core/PathProxy';\nexport declare function buildPath(ctx: CanvasRenderingContext2D | PathProxy, shape: {\n    points: VectorArray[];\n    smooth?: number | 'spline';\n    smoothConstraint?: VectorArray[];\n}, closePath: boolean): void;\n"
  },
  {
    "path": "zrender/esm/graphic/helper/roundRect.d.ts",
    "code": "import PathProxy from '../../core/PathProxy';\nexport declare function buildPath(ctx: CanvasRenderingContext2D | PathProxy, shape: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    r?: number | number[];\n}): void;\n"
  },
  {
    "path": "zrender/esm/graphic/helper/smoothBezier.d.ts",
    "code": "import { VectorArray } from '../../core/vector';\nexport default function (points: VectorArray[], smooth?: number, isLoop?: boolean, constraint?: VectorArray[]): any[][];\n"
  },
  {
    "path": "zrender/esm/graphic/helper/smoothSpline.d.ts",
    "code": "import { VectorArray } from '../../core/vector';\nexport default function (points: VectorArray[], isLoop?: boolean): VectorArray[];\n"
  },
  {
    "path": "zrender/esm/graphic/helper/subPixelOptimize.d.ts",
    "code": "import { PathStyleProps } from '../Path';\ndeclare type LineShape = {\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n};\ndeclare type RectShape = {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    r?: number | number[];\n};\nexport declare function subPixelOptimizeLine(outputShape: Partial<LineShape>, inputShape: LineShape, style: Pick<PathStyleProps, 'lineWidth'>): LineShape;\nexport declare function subPixelOptimizeRect(outputShape: Partial<RectShape>, inputShape: RectShape, style: Pick<PathStyleProps, 'lineWidth'>): RectShape;\nexport declare function subPixelOptimize(position: number, lineWidth?: number, positiveOrNegative?: boolean): number;\nexport {};\n"
  },
  {
    "path": "zrender/esm/graphic/Image.d.ts",
    "code": "import Displayable, { DisplayableProps, CommonStyleProps, DisplayableStatePropNames } from './Displayable';\nimport BoundingRect from '../core/BoundingRect';\nimport { ImageLike, MapToType } from '../core/types';\nimport { ElementCommonState } from '../Element';\nexport interface ImageStyleProps extends CommonStyleProps {\n    image?: string | ImageLike;\n    x?: number;\n    y?: number;\n    width?: number;\n    height?: number;\n    sx?: number;\n    sy?: number;\n    sWidth?: number;\n    sHeight?: number;\n}\nexport declare const DEFAULT_IMAGE_STYLE: CommonStyleProps;\nexport declare const DEFAULT_IMAGE_ANIMATION_PROPS: MapToType<ImageProps, boolean>;\ninterface ImageProps extends DisplayableProps {\n    style?: ImageStyleProps;\n    onload?: (image: ImageLike) => void;\n}\nexport declare type ImageState = Pick<ImageProps, DisplayableStatePropNames> & ElementCommonState;\ndeclare class ZRImage extends Displayable<ImageProps> {\n    style: ImageStyleProps;\n    __image: ImageLike;\n    __imageSrc: string;\n    onload: (image: ImageLike) => void;\n    createStyle(obj?: ImageStyleProps): ImageStyleProps;\n    protected _getAnimationStyleProps(): MapToType<ImageProps, boolean>;\n    getBoundingRect(): BoundingRect;\n}\nexport default ZRImage;\n"
  },
  {
    "path": "zrender/esm/graphic/IncrementalDisplayable.d.ts",
    "code": "import Displayble from './Displayable';\nimport BoundingRect from '../core/BoundingRect';\nexport default class IncrementalDisplayble extends Displayble {\n    notClear: boolean;\n    incremental: boolean;\n    private _displayables;\n    private _temporaryDisplayables;\n    private _cursor;\n    traverse<T>(cb: (this: T, el: this) => void, context: T): void;\n    useStyle(): void;\n    getCursor(): number;\n    innerAfterBrush(): void;\n    clearDisplaybles(): void;\n    clearTemporalDisplayables(): void;\n    addDisplayable(displayable: Displayble, notPersistent?: boolean): void;\n    addDisplayables(displayables: Displayble[], notPersistent?: boolean): void;\n    getDisplayables(): Displayble[];\n    getTemporalDisplayables(): Displayble[];\n    eachPendingDisplayable(cb: (displayable: Displayble) => void): void;\n    update(): void;\n    getBoundingRect(): BoundingRect;\n    contain(x: number, y: number): boolean;\n}\n"
  },
  {
    "path": "zrender/esm/graphic/LinearGradient.d.ts",
    "code": "import Gradient, { GradientObject, GradientColorStop } from './Gradient';\nexport interface LinearGradientObject extends GradientObject {\n    type: 'linear';\n    x: number;\n    y: number;\n    x2: number;\n    y2: number;\n    global: boolean;\n}\nexport default class LinearGradient extends Gradient {\n    type: 'linear';\n    x: number;\n    y: number;\n    x2: number;\n    y2: number;\n    global: boolean;\n    constructor(x: number, y: number, x2: number, y2: number, colorStops?: GradientColorStop[], globalCoord?: boolean);\n}\n"
  },
  {
    "path": "zrender/esm/graphic/Path.d.ts",
    "code": "import Displayable, { DisplayableProps, CommonStyleProps, DisplayableStatePropNames } from './Displayable';\nimport Element, { ElementAnimateConfig } from '../Element';\nimport PathProxy from '../core/PathProxy';\nimport { PatternObject } from './Pattern';\nimport { Dictionary, PropType, MapToType } from '../core/types';\nimport BoundingRect from '../core/BoundingRect';\nimport { LinearGradientObject } from './LinearGradient';\nimport { RadialGradientObject } from './RadialGradient';\nimport Animator from '../animation/Animator';\nexport interface PathStyleProps extends CommonStyleProps {\n    fill?: string | PatternObject | LinearGradientObject | RadialGradientObject;\n    stroke?: string | PatternObject | LinearGradientObject | RadialGradientObject;\n    strokePercent?: number;\n    strokeNoScale?: boolean;\n    fillOpacity?: number;\n    strokeOpacity?: number;\n    lineDash?: false | number[];\n    lineDashOffset?: number;\n    lineWidth?: number;\n    lineCap?: CanvasLineCap;\n    lineJoin?: CanvasLineJoin;\n    miterLimit?: number;\n    strokeFirst?: boolean;\n}\nexport declare const DEFAULT_PATH_STYLE: PathStyleProps;\nexport declare const DEFAULT_PATH_ANIMATION_PROPS: MapToType<PathProps, boolean>;\nexport interface PathProps extends DisplayableProps {\n    strokeContainThreshold?: number;\n    segmentIgnoreThreshold?: number;\n    subPixelOptimize?: boolean;\n    style?: PathStyleProps;\n    shape?: Dictionary<any>;\n    autoBatch?: boolean;\n    __value?: (string | number)[] | (string | number);\n    buildPath?: (ctx: PathProxy | CanvasRenderingContext2D, shapeCfg: Dictionary<any>, inBundle?: boolean) => void;\n}\ndeclare type PathKey = keyof PathProps;\ndeclare type PathPropertyType = PropType<PathProps, PathKey>;\ninterface Path<Props extends PathProps = PathProps> {\n    animate(key?: '', loop?: boolean): Animator<this>;\n    animate(key: 'style', loop?: boolean): Animator<this['style']>;\n    animate(key: 'shape', loop?: boolean): Animator<this['shape']>;\n    getState(stateName: string): PathState;\n    ensureState(stateName: string): PathState;\n    states: Dictionary<PathState>;\n    stateProxy: (stateName: string) => PathState;\n}\nexport declare type PathStatePropNames = DisplayableStatePropNames | 'shape';\nexport declare type PathState = Pick<PathProps, PathStatePropNames> & {\n    hoverLayer?: boolean;\n};\ndeclare class Path<Props extends PathProps = PathProps> extends Displayable<Props> {\n    path: PathProxy;\n    strokeContainThreshold: number;\n    segmentIgnoreThreshold: number;\n    subPixelOptimize: boolean;\n    style: PathStyleProps;\n    autoBatch: boolean;\n    private _rectWithStroke;\n    protected _normalState: PathState;\n    shape: Dictionary<any>;\n    constructor(opts?: Props);\n    protected _init(props?: Props): void;\n    protected getDefaultStyle(): Props['style'];\n    protected getDefaultShape(): {};\n    protected canBeInsideText(): boolean;\n    protected getInsideTextFill(): \"#333\" | \"#ccc\" | \"#eee\";\n    protected getInsideTextStroke(textFill?: string): string;\n    buildPath(ctx: PathProxy | CanvasRenderingContext2D, shapeCfg: Dictionary<any>, inBundle?: boolean): void;\n    pathUpdated(): void;\n    createPathProxy(): void;\n    hasStroke(): boolean;\n    hasFill(): boolean;\n    getBoundingRect(): BoundingRect;\n    contain(x: number, y: number): boolean;\n    dirtyShape(): void;\n    dirty(): void;\n    animateShape(loop: boolean): Animator<this[\"shape\"]>;\n    updateDuringAnimation(targetKey: string): void;\n    attrKV(key: PathKey, value: PathPropertyType): void;\n    setShape(obj: Props['shape']): this;\n    setShape<T extends keyof Props['shape']>(obj: T, value: Props['shape'][T]): this;\n    shapeChanged(): boolean;\n    createStyle(obj?: Props['style']): Props[\"style\"];\n    protected _innerSaveToNormal(toState: PathState): void;\n    protected _applyStateObj(stateName: string, state: PathState, normalState: PathState, keepCurrentStates: boolean, transition: boolean, animationCfg: ElementAnimateConfig): void;\n    protected _mergeStates(states: PathState[]): PathState;\n    protected _getAnimationStyleProps(): MapToType<PathProps, boolean>;\n    isZeroArea(): boolean;\n    static extend<Shape extends Dictionary<any>>(defaultProps: {\n        type?: string;\n        shape?: Shape;\n        style?: PathStyleProps;\n        beforeBrush?: Displayable['beforeBrush'];\n        afterBrush?: Displayable['afterBrush'];\n        getBoundingRect?: Displayable['getBoundingRect'];\n        calculateTextPosition?: Element['calculateTextPosition'];\n        buildPath(this: Path, ctx: CanvasRenderingContext2D | PathProxy, shape: Shape, inBundle?: boolean): void;\n        init?(this: Path, opts: PathProps): void;\n    }): {\n        new (opts?: PathProps & {\n            shape: Shape;\n        }): Path;\n    };\n    static SHAPE_CHANGED_BIT: number;\n    protected static initDefaultProps: void;\n}\nexport default Path;\n"
  },
  {
    "path": "zrender/esm/graphic/Pattern.d.ts",
    "code": "import { ImageLike } from '../core/types';\ndeclare type CanvasPatternRepeat = 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';\nexport interface PatternObject {\n    type: 'pattern';\n    image: ImageLike | string;\n    repeat: CanvasPatternRepeat;\n    __image: ImageLike;\n}\ndeclare class Pattern {\n    type: 'pattern';\n    image: ImageLike | string;\n    repeat: CanvasPatternRepeat;\n    constructor(image: ImageLike | string, repeat: CanvasPatternRepeat);\n}\nexport default Pattern;\n"
  },
  {
    "path": "zrender/esm/graphic/RadialGradient.d.ts",
    "code": "import Gradient, { GradientColorStop, GradientObject } from './Gradient';\nexport interface RadialGradientObject extends GradientObject {\n    type: 'radial';\n    x: number;\n    y: number;\n    r: number;\n    global: boolean;\n}\ndeclare class RadialGradient extends Gradient {\n    type: 'radial';\n    x: number;\n    y: number;\n    r: number;\n    global: boolean;\n    constructor(x: number, y: number, r: number, colorStops?: GradientColorStop[], globalCoord?: boolean);\n}\nexport default RadialGradient;\n"
  },
  {
    "path": "zrender/esm/graphic/shape/Arc.d.ts",
    "code": "import Path, { PathProps } from '../Path';\ndeclare class ArcShape {\n    cx: number;\n    cy: number;\n    r: number;\n    startAngle: number;\n    endAngle: number;\n    clockwise?: boolean;\n}\ninterface ArcProps extends PathProps {\n    shape?: Partial<ArcShape>;\n}\ndeclare class Arc extends Path<ArcProps> {\n    shape: ArcShape;\n    constructor(opts?: ArcProps);\n    getDefaultStyle(): {\n        stroke: string;\n        fill: string;\n    };\n    getDefaultShape(): ArcShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: ArcShape): void;\n}\nexport default Arc;\n"
  },
  {
    "path": "zrender/esm/graphic/shape/BezierCurve.d.ts",
    "code": "import Path, { PathProps } from '../Path';\ndeclare class BezierCurveShape {\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    cpx1: number;\n    cpy1: number;\n    cpx2?: number;\n    cpy2?: number;\n    percent: number;\n}\ninterface BezierCurveProps extends PathProps {\n    shape?: Partial<BezierCurveShape>;\n}\ndeclare class BezierCurve extends Path<BezierCurveProps> {\n    shape: BezierCurveShape;\n    constructor(opts?: BezierCurveProps);\n    getDefaultStyle(): {\n        stroke: string;\n        fill: string;\n    };\n    getDefaultShape(): BezierCurveShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: BezierCurveShape): void;\n    pointAt(t: number): number[];\n    tangentAt(t: number): number[];\n}\nexport default BezierCurve;\n"
  },
  {
    "path": "zrender/esm/graphic/shape/Circle.d.ts",
    "code": "import Path, { PathProps } from '../Path';\ndeclare class CircleShape {\n    cx: number;\n    cy: number;\n    r: number;\n}\ninterface CircleProps extends PathProps {\n    shape?: Partial<CircleShape>;\n}\ndeclare class Circle extends Path<CircleProps> {\n    shape: CircleShape;\n    constructor(opts?: CircleProps);\n    getDefaultShape(): CircleShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: CircleShape, inBundle: boolean): void;\n}\nexport default Circle;\n"
  },
  {
    "path": "zrender/esm/graphic/shape/Droplet.d.ts",
    "code": "import Path, { PathProps } from '../Path';\ndeclare class DropletShape {\n    cx: number;\n    cy: number;\n    width: number;\n    height: number;\n}\ninterface DropletProps extends PathProps {\n    shape?: Partial<DropletShape>;\n}\ndeclare class Droplet extends Path<DropletProps> {\n    shape: DropletShape;\n    constructor(opts?: DropletProps);\n    getDefaultShape(): DropletShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: DropletShape): void;\n}\nexport default Droplet;\n"
  },
  {
    "path": "zrender/esm/graphic/shape/Ellipse.d.ts",
    "code": "import Path, { PathProps } from '../Path';\ndeclare class EllipseShape {\n    cx: number;\n    cy: number;\n    rx: number;\n    ry: number;\n}\ninterface EllipseProps extends PathProps {\n    shape?: Partial<EllipseShape>;\n}\ndeclare class Ellipse extends Path<EllipseProps> {\n    shape: EllipseShape;\n    constructor(opts?: EllipseProps);\n    getDefaultShape(): EllipseShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: EllipseShape): void;\n}\nexport default Ellipse;\n"
  },
  {
    "path": "zrender/esm/graphic/shape/Heart.d.ts",
    "code": "import Path, { PathProps } from '../Path';\ndeclare class HeartShape {\n    cx: number;\n    cy: number;\n    width: number;\n    height: number;\n}\ninterface HeartProps extends PathProps {\n    shape?: Partial<HeartShape>;\n}\ndeclare class Heart extends Path<HeartProps> {\n    shape: HeartShape;\n    constructor(opts?: HeartProps);\n    getDefaultShape(): HeartShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: HeartShape): void;\n}\nexport default Heart;\n"
  },
  {
    "path": "zrender/esm/graphic/shape/Isogon.d.ts",
    "code": "import Path, { PathProps } from '../Path';\ndeclare class IsogonShape {\n    x: number;\n    y: number;\n    r: number;\n    n: number;\n}\ninterface IsogonProps extends PathProps {\n    shape?: Partial<IsogonShape>;\n}\ndeclare class Isogon extends Path<IsogonProps> {\n    shape: IsogonShape;\n    constructor(opts?: IsogonProps);\n    getDefaultShape(): IsogonShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: IsogonShape): void;\n}\nexport default Isogon;\n"
  },
  {
    "path": "zrender/esm/graphic/shape/Line.d.ts",
    "code": "import Path, { PathProps } from '../Path';\nimport { VectorArray } from '../../core/vector';\ndeclare class LineShape {\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    percent: number;\n}\ninterface LineProps extends PathProps {\n    shape?: Partial<LineShape>;\n}\ndeclare class Line extends Path<LineProps> {\n    shape: LineShape;\n    constructor(opts?: LineProps);\n    getDefaultStyle(): {\n        stroke: string;\n        fill: string;\n    };\n    getDefaultShape(): LineShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: LineShape): void;\n    pointAt(p: number): VectorArray;\n}\nexport default Line;\n"
  },
  {
    "path": "zrender/esm/graphic/shape/Polygon.d.ts",
    "code": "import Path, { PathProps } from '../Path';\nimport { VectorArray } from '../../core/vector';\ndeclare class PolygonShape {\n    points: VectorArray[];\n    smooth?: number | 'spline';\n    smoothConstraint?: VectorArray[];\n}\ninterface PolygonProps extends PathProps {\n    shape?: Partial<PolygonShape>;\n}\ndeclare class Polygon extends Path<PolygonProps> {\n    shape: PolygonShape;\n    constructor(opts?: PolygonProps);\n    getDefaultShape(): PolygonShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: PolygonShape): void;\n}\nexport default Polygon;\n"
  },
  {
    "path": "zrender/esm/graphic/shape/Polyline.d.ts",
    "code": "import Path, { PathProps } from '../Path';\nimport { VectorArray } from '../../core/vector';\ndeclare class PolylineShape {\n    points: VectorArray[];\n    percent?: number;\n    smooth?: number | 'spline';\n    smoothConstraint?: VectorArray[];\n}\ninterface PolylineProps extends PathProps {\n    shape?: Partial<PolylineShape>;\n}\ndeclare class Polyline extends Path<PolylineProps> {\n    shape: PolylineShape;\n    constructor(opts?: PolylineProps);\n    getDefaultStyle(): {\n        stroke: string;\n        fill: string;\n    };\n    getDefaultShape(): PolylineShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: PolylineShape): void;\n}\nexport default Polyline;\n"
  },
  {
    "path": "zrender/esm/graphic/shape/Rect.d.ts",
    "code": "import Path, { PathProps } from '../Path';\ndeclare class RectShape {\n    r?: number | number[];\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\ninterface RectProps extends PathProps {\n    shape?: Partial<RectShape>;\n}\ndeclare class Rect extends Path<RectProps> {\n    shape: RectShape;\n    constructor(opts?: RectProps);\n    getDefaultShape(): RectShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: RectShape): void;\n    isZeroArea(): boolean;\n}\nexport default Rect;\n"
  },
  {
    "path": "zrender/esm/graphic/shape/Ring.d.ts",
    "code": "import Path, { PathProps } from '../Path';\ndeclare class RingShape {\n    cx: number;\n    cy: number;\n    r: number;\n    r0: number;\n}\ninterface RingProps extends PathProps {\n    shape?: Partial<RingShape>;\n}\ndeclare class Ring extends Path<RingProps> {\n    shape: RingShape;\n    constructor(opts?: RingProps);\n    getDefaultShape(): RingShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: RingShape): void;\n}\nexport default Ring;\n"
  },
  {
    "path": "zrender/esm/graphic/shape/Rose.d.ts",
    "code": "import Path, { PathProps } from '../Path';\ndeclare class RoseShape {\n    cx: number;\n    cy: number;\n    r: number[];\n    k: number;\n    n: number;\n}\ninterface RoseProps extends PathProps {\n    shape?: Partial<RoseShape>;\n}\ndeclare class Rose extends Path<RoseProps> {\n    shape: RoseShape;\n    constructor(opts?: RoseProps);\n    getDefaultStyle(): {\n        stroke: string;\n        fill: string;\n    };\n    getDefaultShape(): RoseShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: RoseShape): void;\n}\nexport default Rose;\n"
  },
  {
    "path": "zrender/esm/graphic/shape/Sector.d.ts",
    "code": "import Path, { PathProps } from '../Path';\ndeclare class SectorShape {\n    cx: number;\n    cy: number;\n    r0: number;\n    r: number;\n    startAngle: number;\n    endAngle: number;\n    clockwise: boolean;\n}\ninterface SectorProps extends PathProps {\n    shape?: Partial<SectorShape>;\n}\ndeclare class Sector extends Path<SectorProps> {\n    shape: SectorShape;\n    constructor(opts?: SectorProps);\n    getDefaultShape(): SectorShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: SectorShape): void;\n    isZeroArea(): boolean;\n}\nexport default Sector;\n"
  },
  {
    "path": "zrender/esm/graphic/shape/Star.d.ts",
    "code": "import Path, { PathProps } from '../Path';\ndeclare class StarShape {\n    cx: number;\n    cy: number;\n    n: number;\n    r0: number;\n    r: number;\n}\ninterface StarProps extends PathProps {\n    shape?: Partial<StarShape>;\n}\ndeclare class Star extends Path<StarProps> {\n    shape: StarShape;\n    constructor(opts?: StarProps);\n    getDefaultShape(): StarShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: StarShape): void;\n}\nexport default Star;\n"
  },
  {
    "path": "zrender/esm/graphic/shape/Trochoid.d.ts",
    "code": "import Path, { PathProps } from '../Path';\ndeclare class TrochoidShape {\n    cx: number;\n    cy: number;\n    r: number;\n    r0: number;\n    d: number;\n    location: string;\n}\ninterface TrochoidProps extends PathProps {\n    shape?: Partial<TrochoidShape>;\n}\ndeclare class Trochoid extends Path<TrochoidProps> {\n    shape: TrochoidShape;\n    constructor(opts?: TrochoidProps);\n    getDefaultStyle(): {\n        stroke: string;\n        fill: string;\n    };\n    getDefaultShape(): TrochoidShape;\n    buildPath(ctx: CanvasRenderingContext2D, shape: TrochoidShape): void;\n}\nexport default Trochoid;\n"
  },
  {
    "path": "zrender/esm/graphic/Text.d.ts",
    "code": "import { TextAlign, TextVerticalAlign, ImageLike, Dictionary, MapToType } from '../core/types';\nimport TSpan from './TSpan';\nimport ZRImage from './Image';\nimport Rect from './shape/Rect';\nimport BoundingRect from '../core/BoundingRect';\nimport { MatrixArray } from '../core/matrix';\nimport Displayable, { DisplayableStatePropNames, DisplayableProps } from './Displayable';\nimport { ZRenderType } from '../zrender';\nimport Animator from '../animation/Animator';\nimport Transformable from '../core/Transformable';\nimport { ElementCommonState } from '../Element';\nexport interface TextStylePropsPart {\n    text?: string;\n    fill?: string;\n    stroke?: string;\n    opacity?: number;\n    fillOpacity?: number;\n    strokeOpacity?: number;\n    lineWidth?: number;\n    lineDash?: false | number[];\n    lineDashOffset?: number;\n    borderDash?: false | number[];\n    borderDashOffset?: number;\n    font?: string;\n    textFont?: string;\n    fontStyle?: 'normal' | 'italic' | 'oblique';\n    fontWeight?: 'normal' | 'bold' | 'bolder' | 'lighter' | number;\n    fontFamily?: string;\n    fontSize?: number | string;\n    align?: TextAlign;\n    verticalAlign?: TextVerticalAlign;\n    lineHeight?: number;\n    width?: number | string;\n    height?: number;\n    tag?: string;\n    textShadowColor?: string;\n    textShadowBlur?: number;\n    textShadowOffsetX?: number;\n    textShadowOffsetY?: number;\n    backgroundColor?: string | {\n        image: ImageLike | string;\n    };\n    padding?: number | number[];\n    margin?: number;\n    borderColor?: string;\n    borderWidth?: number;\n    borderRadius?: number | number[];\n    shadowColor?: string;\n    shadowBlur?: number;\n    shadowOffsetX?: number;\n    shadowOffsetY?: number;\n}\nexport interface TextStyleProps extends TextStylePropsPart {\n    text?: string;\n    x?: number;\n    y?: number;\n    width?: number;\n    rich?: Dictionary<TextStylePropsPart>;\n    overflow?: 'break' | 'breakAll' | 'truncate';\n    lineOverflow?: 'truncate';\n    ellipsis?: string;\n    placeholder?: string;\n    truncateMinChar?: number;\n}\nexport interface TextProps extends DisplayableProps {\n    style?: TextStyleProps;\n    zlevel?: number;\n    z?: number;\n    z2?: number;\n    culling?: boolean;\n    cursor?: string;\n}\nexport declare type TextState = Pick<TextProps, DisplayableStatePropNames> & ElementCommonState;\nexport declare type DefaultTextStyle = Pick<TextStyleProps, 'fill' | 'stroke' | 'align' | 'verticalAlign'> & {\n    autoStroke?: boolean;\n};\nexport declare const DEFAULT_TEXT_ANIMATION_PROPS: MapToType<TextProps, boolean>;\ninterface ZRText {\n    animate(key?: '', loop?: boolean): Animator<this>;\n    animate(key: 'style', loop?: boolean): Animator<this['style']>;\n    getState(stateName: string): TextState;\n    ensureState(stateName: string): TextState;\n    states: Dictionary<TextState>;\n    stateProxy: (stateName: string) => TextState;\n}\ndeclare class ZRText extends Displayable<TextProps> {\n    type: string;\n    style: TextStyleProps;\n    overlap: 'hidden' | 'show' | 'blur';\n    attachedTransform: Transformable;\n    private _children;\n    private _childCursor;\n    private _defaultStyle;\n    constructor(opts?: TextProps);\n    childrenRef(): (TSpan | ZRImage | Rect)[];\n    update(): void;\n    getComputedTransform(): MatrixArray;\n    private _updateSubTexts;\n    addSelfToZr(zr: ZRenderType): void;\n    removeSelfFromZr(zr: ZRenderType): void;\n    getBoundingRect(): BoundingRect;\n    setDefaultTextStyle(defaultTextStyle: DefaultTextStyle): void;\n    setTextContent(textContent: never): void;\n    protected _mergeStyle(targetStyle: TextStyleProps, sourceStyle: TextStyleProps): TextStyleProps;\n    private _mergeRich;\n    protected _getAnimationStyleProps(): MapToType<TextProps, boolean>;\n    private _getOrCreateChild;\n    private _updatePlainTexts;\n    private _updateRichTexts;\n    private _placeToken;\n    private _renderBackground;\n    static makeFont(style: TextStylePropsPart): string;\n}\nexport declare function normalizeTextStyle(style: TextStyleProps): TextStyleProps;\nexport default ZRText;\n"
  },
  {
    "path": "zrender/esm/graphic/TSpan.d.ts",
    "code": "import Displayable, { DisplayableProps, DisplayableStatePropNames } from './Displayable';\nimport BoundingRect from '../core/BoundingRect';\nimport { PathStyleProps } from './Path';\nexport interface TSpanStyleProps extends PathStyleProps {\n    x?: number;\n    y?: number;\n    text?: string;\n    font?: string;\n    textAlign?: CanvasTextAlign;\n    textBaseline?: CanvasTextBaseline;\n}\nexport declare const DEFAULT_TSPAN_STYLE: TSpanStyleProps;\ninterface TSpanProps extends DisplayableProps {\n    style?: TSpanStyleProps;\n}\nexport declare type TSpanState = Pick<TSpanProps, DisplayableStatePropNames>;\ndeclare class TSpan extends Displayable<TSpanProps> {\n    style: TSpanStyleProps;\n    hasStroke(): boolean;\n    hasFill(): boolean;\n    createStyle(obj?: TSpanStyleProps): TSpanStyleProps;\n    setBoundingRect(rect: BoundingRect): void;\n    getBoundingRect(): BoundingRect;\n}\nexport default TSpan;\n"
  },
  {
    "path": "zrender/esm/Handler.d.ts",
    "code": "import Eventful from './core/Eventful';\nimport Displayable from './graphic/Displayable';\nimport { PainterBase } from './PainterBase';\nimport { HandlerProxyInterface } from './dom/HandlerProxy';\nimport { ZRRawEvent, ElementEventName } from './core/types';\nimport Storage from './Storage';\nimport Element from './Element';\ndeclare class HoveredResult {\n    x: number;\n    y: number;\n    target: Displayable;\n    topTarget: Displayable;\n    constructor(x?: number, y?: number);\n}\ndeclare type HandlerName = 'click' | 'dblclick' | 'mousewheel' | 'mouseout' | 'mouseup' | 'mousedown' | 'mousemove' | 'contextmenu';\ndeclare class Handler extends Eventful {\n    storage: Storage;\n    painter: PainterBase;\n    painterRoot: HTMLElement;\n    proxy: HandlerProxyInterface;\n    private _hovered;\n    private _gestureMgr;\n    private _draggingMgr;\n    _downEl: Element;\n    _upEl: Element;\n    _downPoint: [number, number];\n    constructor(storage: Storage, painter: PainterBase, proxy: HandlerProxyInterface, painterRoot: HTMLElement);\n    setHandlerProxy(proxy: HandlerProxyInterface): void;\n    mousemove(event: ZRRawEvent): void;\n    mouseout(event: ZRRawEvent): void;\n    resize(): void;\n    dispatch(eventName: HandlerName, eventArgs?: any): void;\n    dispose(): void;\n    setCursorStyle(cursorStyle: string): void;\n    dispatchToElement(targetInfo: {\n        target?: Element;\n        topTarget?: Element;\n    }, eventName: ElementEventName, event: ZRRawEvent): void;\n    findHover(x: number, y: number, exclude?: Displayable): HoveredResult;\n    processGesture(event: ZRRawEvent, stage?: 'start' | 'end' | 'change'): void;\n    click: (event: ZRRawEvent) => void;\n    mousedown: (event: ZRRawEvent) => void;\n    mouseup: (event: ZRRawEvent) => void;\n    mousewheel: (event: ZRRawEvent) => void;\n    dblclick: (event: ZRRawEvent) => void;\n    contextmenu: (event: ZRRawEvent) => void;\n}\nexport default Handler;\n"
  },
  {
    "path": "zrender/esm/mixin/Draggable.d.ts",
    "code": "import Handler from '../Handler';\nimport Element, { ElementEvent } from '../Element';\nexport default class Draggable {\n    handler: Handler;\n    _draggingTarget: Element;\n    _dropTarget: Element;\n    _x: number;\n    _y: number;\n    constructor(handler: Handler);\n    _dragStart(e: ElementEvent): void;\n    _drag(e: ElementEvent): void;\n    _dragEnd(e: ElementEvent): void;\n}\n"
  },
  {
    "path": "zrender/esm/PainterBase.d.ts",
    "code": "import Path from './graphic/Path';\nimport ZRImage from './graphic/Image';\nimport { GradientObject } from './graphic/Gradient';\nimport { PatternObject } from './graphic/Pattern';\nimport { Dictionary } from './core/types';\nexport interface PainterBase {\n    type: string;\n    root: HTMLElement;\n    resize(width?: number | string, height?: number | string): void;\n    refresh(): void;\n    clear(): void;\n    getViewportRoot(): HTMLElement;\n    getType: () => string;\n    getWidth(): number;\n    getHeight(): number;\n    dispose(): void;\n    getViewportRoot: () => HTMLElement;\n    getViewportRootOffset: () => {\n        offsetLeft: number;\n        offsetTop: number;\n    };\n    refreshHover(): void;\n    pathToImage(e: Path, dpr: number): ZRImage;\n    configLayer(zlevel: number, config: Dictionary<any>): void;\n    setBackgroundColor(backgroundColor: string | GradientObject | PatternObject): void;\n}\n"
  },
  {
    "path": "zrender/esm/Storage.d.ts",
    "code": "import Element from './Element';\nimport Displayable from './graphic/Displayable';\ndeclare function shapeCompareFunc(a: Displayable, b: Displayable): number;\nexport default class Storage {\n    private _roots;\n    private _displayList;\n    private _displayListLen;\n    traverse<T>(cb: (this: T, el: Element) => void, context?: T): void;\n    getDisplayList(update?: boolean, includeIgnore?: boolean): Displayable[];\n    updateDisplayList(includeIgnore?: boolean): void;\n    private _updateAndAddDisplayable;\n    addRoot(el: Element): void;\n    delRoot(el: Element | Element[]): void;\n    delAllRoots(): void;\n    getRoots(): Element<import(\"./Element\").ElementProps>[];\n    dispose(): void;\n    displayableSortFunc: typeof shapeCompareFunc;\n}\nexport {};\n"
  },
  {
    "path": "zrender/esm/svg/core.d.ts",
    "code": "export declare function createElement(name: string): SVGElement;\n"
  },
  {
    "path": "zrender/esm/svg/graphic.d.ts",
    "code": "import { Path } from '../export';\nimport ZRImage from '../graphic/Image';\nimport TSpan from '../graphic/TSpan';\nexport interface SVGProxy<T> {\n    brush(el: T): void;\n}\ndeclare const svgPath: SVGProxy<Path>;\nexport { svgPath as path };\ndeclare const svgImage: SVGProxy<ZRImage>;\nexport { svgImage as image };\ndeclare const svgText: SVGProxy<TSpan>;\nexport { svgText as text };\n"
  },
  {
    "path": "zrender/esm/svg/helper/ClippathManager.d.ts",
    "code": "import Definable from './Definable';\nimport Displayable from '../../graphic/Displayable';\nimport Path from '../../graphic/Path';\nexport default class ClippathManager extends Definable {\n    constructor(zrId: number, svgRoot: SVGElement);\n    update(displayable: Displayable): void;\n    updateDom(parentEl: SVGElement, clipPaths: Path[], isText: boolean): void;\n    markUsed(displayable: Displayable): void;\n}\n"
  },
  {
    "path": "zrender/esm/svg/helper/Definable.d.ts",
    "code": "import { createElement } from '../core';\nimport Path from '../../graphic/Path';\nimport ZRImage from '../../graphic/Image';\nimport TSpan from '../../graphic/TSpan';\nimport Displayable from '../../graphic/Displayable';\nexport default class Definable {\n    nextId: number;\n    protected _zrId: number;\n    protected _svgRoot: SVGElement;\n    protected _tagNames: string[];\n    protected _markLabel: string;\n    protected _domName: string;\n    constructor(zrId: number, svgRoot: SVGElement, tagNames: string | string[], markLabel: string, domName?: string);\n    createElement: typeof createElement;\n    getDefs(isForceCreating?: boolean): SVGDefsElement;\n    doUpdate<T>(target: T, onUpdate?: (target: T) => void): void;\n    add(target: any): SVGElement;\n    addDom(dom: SVGElement): void;\n    removeDom<T>(target: T): void;\n    getDoms(): SVGElement[];\n    markAllUnused(): void;\n    markDomUsed(dom: SVGElement): void;\n    removeUnused(): void;\n    getSvgProxy(displayable: Displayable): import(\"../graphic\").SVGProxy<Path<import(\"../../graphic/Path\").PathProps>> | import(\"../graphic\").SVGProxy<ZRImage> | import(\"../graphic\").SVGProxy<TSpan>;\n    getSvgElement(displayable: Displayable): SVGElement;\n}\n"
  },
  {
    "path": "zrender/esm/svg/helper/GradientManager.d.ts",
    "code": "import Definable from './Definable';\nimport Displayable from '../../graphic/Displayable';\nimport { GradientObject } from '../../graphic/Gradient';\nexport default class GradientManager extends Definable {\n    constructor(zrId: number, svgRoot: SVGElement);\n    addWithoutUpdate(svgElement: SVGElement, displayable: Displayable): void;\n    add(gradient: GradientObject): SVGElement;\n    update(gradient: GradientObject): void;\n    updateDom(gradient: GradientObject, dom: SVGElement): void;\n    markUsed(displayable: Displayable): void;\n}\n"
  },
  {
    "path": "zrender/esm/svg/helper/ShadowManager.d.ts",
    "code": "import Definable from './Definable';\nimport Displayable from '../../graphic/Displayable';\nexport default class ShadowManager extends Definable {\n    constructor(zrId: number, svgRoot: SVGElement);\n    addWithoutUpdate(svgElement: SVGElement, displayable: Displayable): void;\n    add(displayable: Displayable): SVGElement;\n    update(svgElement: SVGElement, displayable: Displayable): void;\n    remove(svgElement: SVGElement, displayable: Displayable): void;\n    updateDom(displayable: Displayable, dom: SVGElement): void;\n    markUsed(displayable: Displayable): void;\n}\n"
  },
  {
    "path": "zrender/esm/svg/Painter.d.ts",
    "code": "import Path from '../graphic/Path';\nimport ZRImage from '../graphic/Image';\nimport Displayable from '../graphic/Displayable';\nimport Storage from '../Storage';\nimport { PainterBase } from '../PainterBase';\ninterface SVGPainterOption {\n    width?: number | string;\n    height?: number | string;\n}\ndeclare class SVGPainter implements PainterBase {\n    type: string;\n    root: HTMLElement;\n    storage: Storage;\n    private _opts;\n    private _svgDom;\n    private _svgRoot;\n    private _backgroundRoot;\n    private _backgroundNode;\n    private _gradientManager;\n    private _clipPathManager;\n    private _shadowManager;\n    private _viewport;\n    private _visibleList;\n    private _width;\n    private _height;\n    constructor(root: HTMLElement, storage: Storage, opts: SVGPainterOption, zrId: number);\n    getType(): string;\n    getViewportRoot(): HTMLDivElement;\n    getSvgDom(): SVGElement;\n    getSvgRoot(): SVGGElement;\n    getViewportRootOffset(): {\n        offsetLeft: number;\n        offsetTop: number;\n    };\n    refresh(): void;\n    setBackgroundColor(backgroundColor: string): void;\n    _paintList(list: Displayable[]): void;\n    _getDefs(isForceCreating?: boolean): SVGElement;\n    resize(width: number | string, height: number | string): void;\n    getWidth(): number;\n    getHeight(): number;\n    _getSize(whIdx: number): number;\n    dispose(): void;\n    clear(): void;\n    toDataURL(): string;\n    refreshHover: () => void;\n    pathToImage: (e: Path<import(\"../graphic/Path\").PathProps>, dpr: number) => ZRImage;\n    configLayer: (zlevel: number, config: import(\"../core/types\").Dictionary<any>) => void;\n}\nexport default SVGPainter;\n"
  },
  {
    "path": "zrender/esm/svg/svg.d.ts",
    "code": "import './graphic';\n"
  },
  {
    "path": "zrender/esm/tool/color.d.ts",
    "code": "export declare function parse(colorStr: string, rgbaArr?: number[]): number[];\nexport declare function lift(color: string, level: number): string;\nexport declare function toHex(color: string): string;\nexport declare function fastLerp(normalizedValue: number, colors: number[][], out?: number[]): number[];\nexport declare const fastMapToColor: typeof fastLerp;\ndeclare type LerpFullOutput = {\n    color: string;\n    leftIndex: number;\n    rightIndex: number;\n    value: number;\n};\nexport declare function lerp(normalizedValue: number, colors: string[], fullOutput?: boolean): string | LerpFullOutput;\nexport declare const mapToColor: typeof lerp;\nexport declare function modifyHSL(color: string, h?: number, s?: number, l?: number): string;\nexport declare function modifyAlpha(color: string, alpha?: number): string;\nexport declare function stringify(arrColor: number[], type: string): string;\nexport declare function lum(color: string, backgroundLum: number): number;\nexport declare function random(): string;\nexport {};\n"
  },
  {
    "path": "zrender/esm/tool/parseSVG.d.ts",
    "code": "import Group from '../graphic/Group';\nimport { RectLike } from '../core/BoundingRect';\ninterface SVGParserOption {\n    width?: number;\n    height?: number;\n    ignoreViewBox?: boolean;\n    ignoreRootClip?: boolean;\n}\ninterface SVGParserResult {\n    root: Group;\n    width: number;\n    height: number;\n    viewBoxRect: RectLike;\n    viewBoxTransform: {\n        x: number;\n        y: number;\n        scale: number;\n    };\n}\nexport declare function parseXML(svg: Document | string | SVGElement): SVGElement;\nexport declare function makeViewBoxTransform(viewBoxRect: RectLike, width: number, height: number): {\n    scale: number;\n    x: number;\n    y: number;\n};\nexport declare function parseSVG(xml: string | Document | SVGElement, opt: SVGParserOption): SVGParserResult;\nexport {};\n"
  },
  {
    "path": "zrender/esm/tool/path.d.ts",
    "code": "import Path, { PathProps } from '../graphic/Path';\nimport { MatrixArray } from '../core/matrix';\ndeclare type SVGPathOption = Omit<PathProps, 'shape' | 'buildPath'>;\ndeclare class SVGPath extends Path {\n    applyTransform(m: MatrixArray): void;\n}\nexport declare function createFromString(str: string, opts?: SVGPathOption): SVGPath;\nexport declare function extendFromString(str: string, defaultOpts?: SVGPathOption): typeof SVGPath;\nexport declare function mergePath(pathEls: Path[], opts: PathProps): Path<PathProps>;\nexport {};\n"
  },
  {
    "path": "zrender/esm/tool/transformPath.d.ts",
    "code": "import PathProxy from '../core/PathProxy';\nimport { MatrixArray } from '../core/matrix';\nexport default function (path: PathProxy, m: MatrixArray): void;\n"
  },
  {
    "path": "zrender/esm/vml/core.d.ts",
    "code": "export declare var doc: Document;\nexport declare function createNode(tagName: any): any;\nexport declare function initVML(): void;\n"
  },
  {
    "path": "zrender/esm/vml/graphic.d.ts",
    "code": "export {};\n"
  },
  {
    "path": "zrender/esm/vml/Painter.d.ts",
    "code": "declare function VMLPainter(root: any, storage: any): void;\nexport default VMLPainter;\n"
  },
  {
    "path": "zrender/esm/vml/vml.d.ts",
    "code": "import './graphic';\n"
  },
  {
    "path": "zrender/esm/zrender.d.ts",
    "code": "/*!\n* ZRender, a high performance 2d drawing library.\n*\n* Copyright (c) 2013, Baidu Inc.\n* All rights reserved.\n*\n* LICENSE\n* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n*/\nimport Handler from './Handler';\nimport Storage from './Storage';\nimport { PainterBase } from './PainterBase';\nimport Animation from './animation/Animation';\nimport Element, { ElementEventCallback, ElementEvent } from './Element';\nimport { ElementEventName } from './core/types';\nimport { LayerConfig } from './canvas/Layer';\nimport { GradientObject } from './graphic/Gradient';\nimport { PatternObject } from './graphic/Pattern';\nimport { Path } from './export';\nimport { EventCallback } from './core/Eventful';\nimport TSpan from './graphic/TSpan';\nimport ZRImage from './graphic/Image';\nimport Displayable from './graphic/Displayable';\ndeclare type PainterBaseCtor = {\n    new (dom: HTMLElement, storage: Storage, ...args: any[]): PainterBase;\n};\ndeclare class ZRender {\n    dom: HTMLElement;\n    id: number;\n    storage: Storage;\n    painter: PainterBase;\n    handler: Handler;\n    animation: Animation;\n    private _stillFrameAccum;\n    private _needsRefresh;\n    private _needsRefreshHover;\n    private _darkMode;\n    private _backgroundColor;\n    constructor(id: number, dom: HTMLElement, opts?: ZRenderInitOpt);\n    add(el: Element): void;\n    remove(el: Element): void;\n    configLayer(zLevel: number, config: LayerConfig): void;\n    setBackgroundColor(backgroundColor: string | GradientObject | PatternObject): void;\n    getBackgroundColor(): string | GradientObject | PatternObject;\n    setDarkMode(darkMode: boolean): void;\n    isDarkMode(): boolean;\n    refreshImmediately(fromInside?: boolean): void;\n    refresh(): void;\n    flush(): void;\n    wakeUp(): void;\n    addHover(el: Displayable): void;\n    removeHover(el: Path | TSpan | ZRImage): void;\n    clearHover(): void;\n    refreshHover(): void;\n    refreshHoverImmediately(): void;\n    resize(opts?: {\n        width?: number | string;\n        height?: number | string;\n    }): void;\n    clearAnimation(): void;\n    getWidth(): number;\n    getHeight(): number;\n    pathToImage(e: Path, dpr: number): ZRImage;\n    setCursorStyle(cursorStyle: string): void;\n    findHover(x: number, y: number): {\n        target: Displayable;\n        topTarget: Displayable;\n    };\n    on<Ctx>(eventName: ElementEventName, eventHandler: ElementEventCallback<Ctx, unknown>, context?: Ctx): this;\n    on<Ctx>(eventName: string, eventHandler: EventCallback<Ctx, unknown>, context?: Ctx): this;\n    off(eventName?: string, eventHandler?: EventCallback<unknown, unknown> | EventCallback<unknown, unknown, ElementEvent>): void;\n    trigger(eventName: string, event?: unknown): void;\n    clear(): void;\n    dispose(): void;\n}\nexport interface ZRenderInitOpt {\n    renderer?: string;\n    devicePixelRatio?: number;\n    width?: number | string;\n    height?: number | string;\n}\nexport declare function init(dom: HTMLElement, opts?: ZRenderInitOpt): ZRender;\nexport declare function dispose(zr: ZRender): void;\nexport declare function disposeAll(): void;\nexport declare function getInstance(id: number): ZRender;\nexport declare function registerPainter(name: string, Ctor: PainterBaseCtor): void;\nexport declare const version = \"5.0.0-alpha.1\";\nexport interface ZRenderType extends ZRender {\n}\nexport {};\n"
  },
  {
    "path": "zrender/index.d.ts",
    "code": "export * from './src/zrender';\nexport * from './src/export';"
  }
]